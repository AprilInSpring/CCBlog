/*
 Navicat Premium Data Transfer

 Source Server         : aliyun
 Source Server Type    : MySQL
 Source Server Version : 50739
 Source Host           : 8.142.134.180:3306
 Source Schema         : ccblog

 Target Server Type    : MySQL
 Target Server Version : 50739
 File Encoding         : 65001

 Date: 05/07/2023 16:20:21
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for cc_article
-- ----------------------------
DROP TABLE IF EXISTS `cc_article`;
CREATE TABLE `cc_article`  (
  `id` bigint(200) NOT NULL AUTO_INCREMENT,
  `title` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标题',
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '文章内容',
  `summary` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '文章摘要',
  `category_id` bigint(20) NULL DEFAULT NULL COMMENT '所属分类id',
  `thumbnail` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '缩略图',
  `is_top` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '是否置顶（0否，1是）',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '1' COMMENT '状态（0已发布，1草稿）',
  `view_count` bigint(200) NULL DEFAULT 0 COMMENT '访问量',
  `is_comment` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '1' COMMENT '是否允许评论 1是，0否',
  `create_by` bigint(20) NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_by` bigint(20) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `del_flag` int(1) NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `cid_status_flag`(`category_id`, `status`, `del_flag`) USING BTREE,
  INDEX `status_flag`(`status`, `del_flag`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 38 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of cc_article
-- ----------------------------
INSERT INTO `cc_article` VALUES (1, 'SpringSecurity从入门到精通', '## 课程介绍\n![image20211219121555979.png](https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/31/e7131718e9e64faeaf3fe16404186eb4.png)\n\n## 0. 简介1\n\n​	**Spring Security** 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架**Shiro**，它提供了更丰富的功能，社区资源也比Shiro丰富。\n\n​	一般来说中大型的项目都是使用**SpringSecurity** 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。\n\n​	 一般Web应用的需要进行**认证**和**授权**。\n\n​		**认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户**\n\n​		**授权：经过认证后判断当前用户是否有权限进行某个操作**\n\n​	而认证和授权也是SpringSecurity作为安全框架的核心功能。\n\n\n\n## 1. 快速入门\n\n### 1.1 准备工作\n\n​	我们先要搭建一个简单的SpringBoot工程\n\n① 设置父工程 添加依赖\n\n~~~~\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.5.0</version>\n    </parent>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n            <optional>true</optional>\n        </dependency>\n    </dependencies>\n~~~~\n\n② 创建启动类\n\n~~~~\n@SpringBootApplication\npublic class SecurityApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SecurityApplication.class,args);\n    }\n}\n\n~~~~\n\n③ 创建Controller\n\n~~~~java\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController {\n\n    @RequestMapping(\"/hello\")\n    public String hello(){\n        return \"hello\";\n    }\n}\n\n~~~~\n\n\n\n### 1.2 引入SpringSecurity\n\n​	在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。\n\n~~~~xml\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-security</artifactId>\n        </dependency>\n~~~~\n\n​	引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。\n\n​	必须登陆之后才能对接口进行访问。\n\n\n\n## 2. 认证\n\n### 2.1 登陆校验流程\n![image20211215094003288.png](https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/31/414a87eeed344828b5b00ffa80178958.png)', 'SpringSecurity框架教程-Spring Security+JWT实现项目级前端分离认证授权', 1, 'https://sg-blog-oss.oss-cn-beijing.aliyuncs.com/2022/01/31/948597e164614902ab1662ba8452e106.png', '1', '0', 142, '0', NULL, '2022-01-23 23:20:11', 1, '2023-05-15 15:04:30', 1);
INSERT INTO `cc_article` VALUES (9, 'VUE总结', '## 1.vue基础\n\n### 1.1模板语法\n\nhtml 中包含了一些 JS 语法代码，语法分为两种，分别为：\n\n插值语法（双大括号表达式）\n\n指令语法（以 v-开头）\n\n#### 1.1.1插值语法\n\n功能: 用于解析标签体内容\n\n语法: {{xxx}} ，xxxx 会作为 js 表达式解析\n\n#### 1.1.2指令语法\n\n功能: 解析标签属性、解析标签体内容、绑定事件\n\n语法：v-bind:href = \'xxxx\' ，xxxx 会作为 js 表达式被解析\n\n### 1.2数据绑定\n\n#### 1.2.1单向数据绑定\n\n语法：v-bind:href =\"xxx\" 或简写为 :href\n\n特点：数据只能从 data 流向页面\n\n#### 1.2.2双向数据绑定\n\n语法：v-mode:value=\"xxx\" 或简写为 v-model=\"xxx\" \n\n特点：数据不仅能从 data 流向页面，还能从页面流向 data，但是v-model只能作用于表单项\n\n### 1.3MVVM模型\n\nM：模型(Model) ：对应 data 中的数据\n\n V：视图(View) ：模板\n\nVM：视图模型(ViewModel) ： Vue 实例对象\n\n![image20230514195520405.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/14/7e21b3c7b3e44d44bfaa28e9e5075ca3.png)\n\n', 'vue笔记总结', 4, 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/14/a8834bd242ae45fba9ef93332f5f75a1.png', '0', '0', 14, '0', 1, '2023-05-14 20:00:04', 1, '2023-05-17 10:38:30', 1);
INSERT INTO `cc_article` VALUES (10, 'VUE学习日志', '# 							VUE学习总结\n\n## 1.快捷键\n\n1.！+ tab快速生成html模板\n\n2.ctrl + / 快速注释\n\n3.div#root 快速创建div容器\n\n## 2. 5/15日总结\n\n1.{{name}} 插值法完成数据插入\n\n2.一个实例对象只能被一个Vue对象接管，先到先得而属性则是覆盖\n\n3.{{xxx}里面可以写js表达式，还可以使用函数，例如日期函数和字符串函数\n\n4.v-bind，可以将标签属性中的值变成js表达式去执行，可以简写成：\n\n5.插值方法可以接管标签体的内容，指令方法可以接管标签属性的内容、标签体和事件\n\n6.v-bind单向绑定，v-model双向绑定\n\n7.v-model只能对表单项生效，v-model:value可以简写成v-model\n\n8.const vm = new Vue({}),v.$mount(\'#root\')另一种绑定的写法，替代el\n\n9.setTimeout(()->{},1000)	延迟1s执行\n\n10.data的另一种写法\n\n~~~js\nconst vm = new Vue({\n	data(){\n		return{\n			name:\'cc\',\n			age:24\n		}\n	}\n});\nvm.$mount(\'#root\');\n~~~\n\n11.一个重要原则，由vue管理的函数，一般不可以简写成箭头函数，一旦写了，this就不再指向vue实例了，而是window对象\n\n12.mvmm模型，m：model数据，v：view，dom视图，vm：vue对象，完成数据的绑定和数据的回传\n\n13.代码练习\n\n~~~html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <!-- 引入vue --> \n    <script type=\"text/javascript\" src=\"./js/vue.js\"></script>\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"root\">\n        <h1>Hello {{name}}</h1>\n        <hr>\n        <a v-bind:href=\"cc\">cc</a>\n        <hr>\n        <input v-model=\"user\"/>\n        <hr>\n        <input :value=\"user\"/>\n    </div>\n\n\n    <script type=\"text/javascript\">\n        Vue.config.productionTip = false //阻止生产提示    \n\n        new Vue({\n            el:\'#root\',\n            data:{\n                name:\'cc\',\n                cc:\'http://8.142.134.180\',\n                user:\'xxx\'    \n            }\n        })\n    </script>\n</body>\n</html>\n~~~\n## 3. 5/16日总结\n\n1.使用Object.defineProperty(对象，属性名，{属性数组})完成对象属性的添加，此方法添加的属性更加灵活，可以设置各种权限，以及提供getter和setter方法。\n\n~~~js\nObject.defineProperty(person,\'age\',{\n    // value:18,\n    // enumerable:true, //控制属性是否可以枚举，默认值是false\n    // writable:true, //控制属性是否可以被修改，默认值是false\n    // configurable:true //控制属性是否可以被删除，默认值是false\n\n    //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值\n    get(){\n        console.log(\'有人读取age属性了\')\n        return number\n    },\n\n    //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值\n    set(value){\n        console.log(\'有人修改了age属性，且值是\',value)\n        number = value\n    }\n\n})\n~~~\n\n2.数据代理，通过一个对象代理对另一个对象中属性的操作（读/写），简单来说就是get和set方法，可以通过对象的方法获取和修改一个对象的值\n\n~~~js\n<!-- \n    1.Vue中的数据代理：\n    通过vm对象来代理data对象中属性的操作（读/写）\n    2.Vue中数据代理的好处： \n    更加方便的操作data中的数据\n    3.基本原理：\n    通过Object.defineProperty()把data对象中所有属性添加到vm上。\n    为每一个添加到vm上的属性，都指定一个getter/setter。\n    在getter/setter内部去操作（读/写）data中对应的属性。\n	4.vue对象同时也会保存data对象进_data属性中，但是_data属性中的数据是经过处理的data数据（数据代理）\n -->\n~~~\n\n3.事件绑定\n\n~~~html\n<body>\n    <!-- \n        事件的基本使用：\n        1.使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名；\n        2.事件的回调需要配置在methods对象中，最终会在vm上；\n        3.methods中配置的函数，不要用箭头函数！否则this就不是vm了，而是window对象；\n        4.methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象；\n        5.@click=\"demo\" 和 @click=\"demo($event)\" 效果一致，但后者可以传参；\n    -->\n    <!-- 准备好一个容器-->\n    <div id=\"root\">\n        <h2>欢迎来到{{name}}学习</h2>\n        <!-- <button v-on:click=\"showInfo\">点我提示信息</button> -->\n        <button @click=\"showInfo1\">点我提示信息1（不传参）</button>\n        <button @click=\"showInfo2($event,66)\">点我提示信息2（传参）</button>\n    </div>\n</body>\n\n<script type=\"text/javascript\">\n    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。\n\n    const vm = new Vue({\n        el:\'#root\',\n        data:{\n            name:\'尚硅谷\',\n        },\n        methods:{\n            showInfo1(event){\n                // console.log(event.target.innerText)\n                // console.log(this) //此处的this是vm\n                alert(\'同学你好！\')\n            },\n            showInfo2(event,number){\n                console.log(event,number)\n                // console.log(event.target.innerText)\n                // console.log(this) //此处的this是vm\n                alert(\'同学你好！！\')\n            }\n        }\n    })\n</script>\n~~~\n\n\n', '日志', 4, 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/14/3358d9cf9b114b6f81b5d6015839bb80.jpg', '1', '0', 51, '0', 1, '2023-05-14 20:06:17', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (11, '基于阿里云和宝塔的博客项目部署', '# 				基于阿里云和宝塔的博客项目部署\n\n## 1.设置密码\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/fe705d74a6c64848a169c6e5b9a6f666.png)\n\n如果忘记密码了，可以选择重制你的实例密码，此密码后续用于远程连接服务器\n\n## 2.开放项目的相应端口\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/01307cd07f444565864a93c3d9c53993.png)\n\n我这里开放了6379、3306端口，用于redis和mysql数据库的访问，博客项目则开放5210-5213四个端口。前台前端：5213、前台后端：5212、后台前端：5211、后台后端：5210\n\n除了阿里云，宝塔也需要开放相应端口\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/cbe7f1281c7d4ad796650c618efaf67a.png)\n\n## 3.进行远程服务器连接测试\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/a033b18c0ead49a1b371d052c5c78575.png)\n\n添加数据库\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/e836d406ee324d25a69685a9b7e1e25e.png)\n\n设置数据库信息，这里用户名和密码我们不用，我们使用数据库的root用户进行登录，远程连接数据库后，运行sql文件。\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/a74bed3a2f82487e87b62008185a13a9.png)\n\n使用navicat远程连接数据库，账号密码是服务器数据库的账号密码，这里需要提前开放mysql的远程链接\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/19831ad3b85845ceb3b92ca0f404c6a7.png)\n\nXshell远程连接服务器\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/589c5d3cfeee4a3b8c5e2935f5ab2b5e.png)\n\n输入用户名，一般是root（这里是服务器的实例用户名）\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/e1c8df1e0a0f476985b33656352c83d8.png)\n\n输入密码，这里输入你的实例密码就可以进行连接\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/328b8472aa07482eb17a37d078ecca63.png)\n\n使用redis连接工具远程连接redis，这里也需要提前开放redis的远程连接，并设置密码，redis的远程连接是要求有密码的。具体的修改如下，不行的话，可以参考最后的博文链接，我也是参考别人的\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/4637e7f256474d5c8b971a0123db40b1.png)\n到这里，基本的数据库环境都配置好了。\n\n## 4.前端项目部署（宝塔nginx部署）\n\n### 4.1宝塔安装nginx\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/cd5d09fde6ff4f29851e9f8c4fd57ce8.png)\n\n### 4.2修改前端项目端口\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/f5d18e7e16e1456f96d5852908291b67.png)\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/8a5553b0e25a46d795bd8bf8b0b0929e.png)\n到这里前台vue项目修改完毕，在项目的根目录下先运行 npm install ，再npm run build进行打包，最后生成一个dist文件夹，打包完毕\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/279832e9ad0946668743f2922b1d1220.png)\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/cf5d83b2a1b544cc94002e9c1f815853.png)\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/6c7f7184f7864fc6a3fdf76a5ab79cc5.png)\n\n然后配置一下router下的index.js文件，有路由缺失，不配置的话，打包部署后，只能展示左侧目录，不能对应功能。**index.js配置如下：**\n\n```\nexport const constantRoutes = [\n  {\n    path: \'/login\',\n    component: () => import(\'@/views/login/index\'),\n    hidden: true\n  },\n  {\n    path: \'/\',\n    component: Layout,\n    redirect: \'/dashboard\',\n    children: [{\n      path: \'dashboard\',\n      name: \'Dashboard\',\n      component: () => import(\'@/views/dashboard/index\'),\n      meta: { title: \'首页\', icon: \'dashboard\' }\n    }]\n  },\n  {\n    path: \'/write\',\n    component: Layout,\n    children: [{\n      path: \'/\',\n      name: \'Write\',\n      component: () => import(\'@/views/content/article/write/index\'),\n      hidden: true\n    }]\n  },\n  {\n    path: \'/system/user\',\n    component: Layout,\n    children: [{\n      path: \'/\',\n      name: \'User\',\n      component: () => import(\'@/views/system/user\'),\n      hidden: true\n    }]\n  },\n  {\n    path: \'/system/role\',\n    component: Layout,\n    children: [{\n      path: \'/\',\n      name: \'role\',\n      component: () => import(\'@/views/system/role\'),\n      hidden: true\n    }]\n  },\n  {\n    path: \'/system/menu\',\n    component: Layout,\n    children: [{\n      path: \'/\',\n      name: \'menu\',\n      component: () => import(\'@/views/system/menu\'),\n      hidden: true\n    }]\n  },\n  {\n    path: \'/system/role\',\n    component: Layout,\n    children: [{\n      path: \'/\',\n      name: \'role\',\n      component: () => import(\'@/views/system/role\'),\n      hidden: true\n    }]\n  },\n  {\n    path: \'/content/article\',\n    component: Layout,\n    children: [{\n      path: \'/\',\n      name: \'article\',\n      component: () => import(\'@/views/content/article/index\'),\n      hidden: true\n    }]\n  },\n  {\n    path: \'/content/category\',\n    component: Layout,\n    children: [{\n      path: \'/\',\n      name: \'category\',\n      component: () => import(\'@/views/content/category/index\'),\n      hidden: true\n    }]\n  },\n  {\n    path: \'/content/link\',\n    component: Layout,\n    children: [{\n      path: \'/\',\n      name: \'link\',\n      component: () => import(\'@/views/content/link/index\'),\n      hidden: true\n    }]\n  },\n  {\n    path: \'/content/tag\',\n    component: Layout,\n    children: [{\n      path: \'/\',\n      name: \'tag\',\n      component: () => import(\'@/views/content/tag/index\'),\n      hidden: true\n    }]\n  }\n]\n\n```\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/82648e99c118413bac0ce2a35f2e334d.png)\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/500de96e761c423ea221dc66fd3ebec5.png)\n\n至此，后端vue项目也修改完毕，先npm install，再npm run build:prod，进行打包，同样也会生成一个dist文件夹。若是，还出现问题的话，可以拉取我github上的项目，安装上述方法修改端口就可以\n\ngithub地址：https://github.com/AprilInSpring/CCBlog.git\n\n### 4.3修改nginx配置文件\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/abddda0baa6d414185f806831727c66a.png)\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/90d7ae51d28d487e97e15e459a7b36fb.png)\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/9789949441e54a479ab5d6755872f6a8.png)\n\n```\nserver {\n #监听端口\n      listen       5211;\n      server_name  localhost;\n  \n      #access_log  logs/host.access.log  main;\n  \n      location / {\n      #dist文件所在目录\n             root   html/blog-admin;\n             index  index.html index.htm;\n      #解决刷新404的问题\n             try_files $uri $uri/ /index.html;\n      }\n\n}\n\nserver {\n #监听端口\n      listen       5213;\n      server_name  localhost;\n  \n      #access_log  logs/host.access.log  main;\n  \n      location / {\n      #dist文件所在目录\n             root   html/blog-user;\n             index  index.html index.htm;\n      #解决刷新404的问题\n             try_files $uri $uri/ /index.html;\n      }\n\n}\n```\n\n### 4.4上传vue项目dist文件\n\n注意，文件的路径要和配置文件的路径一致，上传到nginx的html目录下，这里我把dist文件的内容放到了blog-admin文件夹下\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/b4cb770442af48f0be190463d6431ff5.png)\n\n### 4.5启动nginx进行测试\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/8c0021e28d8942bf9c1f8c0518caf846.png)\n\n访问地址，测试成功	8.142.134.180:5213	8.142.134.180:5211\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/0e2df9ce041a41c1b38d396a64ed7514.png)\n\n## 5.后端项目部署（宝塔jar包部署）\n\n### 5.1添加打包依赖\n\n在framework基础模块中添加以下依赖\n\n```xml\n<build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.10.1</version>\n            </plugin>\n            <!-- 此插件必须放在父 POM 中  -->\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-assembly-plugin</artifactId>\n                <version>3.3.0</version>\n                <executions>\n                    <!--\n                    执行本插件的方法为，在主目录下执行如下命令：\n                    mvn package assembly:single\n\n                    对于 IntelliJ IDEA，生成的 JAR 包位于每个模块下的文件夹 target\n                    -->\n                    <execution>\n                        <id>make-assembly</id>\n                        <phase>package</phase>\n                        <goals>\n                            <!-- 此处 IntelliJ IDEA 可能会报红，这是正常现象  -->\n                            <goal>single</goal>\n                        </goals>\n                    </execution>\n                </executions>\n                <configuration>\n                    <archive>\n                        <manifest>\n                            <!-- 配置程序运行入口所在的类 -->\n                             <!-- 自己的启动类path-->\n                            <mainClass>com.mest.BlogAdminApplication</mainClass>\n                        </manifest>\n                        <manifest>\n                            <!-- 配置程序运行入口所在的类 -->\n                            <mainClass>com.mest.MestBlogApplication</mainClass>\n                        </manifest>\n                    </archive>\n                    <!-- 设置 JAR 包输出目录 -->\n                    <outputDirectory>${project.build.directory}/#maven-assembly-plugin</outputDirectory>\n                    <!-- 设置打包后的 JAR 包的目录结构为默认 -->\n                    <descriptorRefs>\n                        <descriptorRef>jar-with-dependencies</descriptorRef>\n                    </descriptorRefs>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n```\n\n在blog-user和blog-admin模块中添加如下依赖\n\n~~~xml\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n                <version>2.6.2</version>\n\n                <executions>\n                    <execution>\n                        <goals>\n                            <goal>repackage</goal>\n                        </goals>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n        <finalName>${project.artifactId}</finalName>\n    </build>\n\n~~~\n\n### 5.2修改项目的配置文件\n\n主要是修改mysql和redis的连接信息，注意，redis需要设置密码，这里我就不一一赘述了\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/d4980faaf31b4ecf9117b096e467f351.png)\n\n### 5.3项目打包\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/11eb4c5b65184272961a0bcb1e0b2d28.png)\n\n先对framework项目进行clean再install\n\n分别对blog-admin和blog-user先clean，再package\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/c33bf4e36766485280d7272c4c3af1f6.png)\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/ab11a4a9f7c0448daba4bdb832c328de.png)\n\n至此，项目打包完毕\n\n### 5.4部署jar包项目\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/cd1f4120e2024d6f913323c09440b9ca.png)\n\n上传jar包到服务器\n\n部署项目\n\n![image.png](http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/8e791d7354674e029848a3bf92585aec.png)\n\n保存项目，启动成功\n\n## 6.参考文章\n\n通过宝塔面板部署一个SpringBoot+Vue前后端分离项目的指南（三更）：https://blog.csdn.net/weixin_51285339/article/details/128839388\n\n超详细Docker部署SpringBoot+Vue项目（三更博客项目部署）：https://blog.csdn.net/qq_52030824/article/details/127982206?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127982206%22%2C%22source%22%3A%22qq_52030824%22%7D\n\nSpringBoot项目打包成jar包部署到宝塔面板(详细)：https://blog.csdn.net/weixin_47390965/article/details/124666474?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168398532516782427493813%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168398532516782427493813&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-124666474-null-null.142^v87^insert_down28,239^v2^insert_chatgpt&utm_term=%E5%AE%9D%E5%A1%94%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2jar%E5%8C%85%E9%A1%B9%E7%9B%AE&spm=1018.2226.3001.4187\n\n阿里云上远程连接redis：https://blog.csdn.net/lilong329329/article/details/90451657\n\nNavicat如何连接远程服务器的MySQL：https://blog.csdn.net/a648119398/article/details/122420906\n\n## 7.个人博客地址&GitHub地址\n\n个人博客：8.142.134.180:5213\n\ngithub:https://github.com/AprilInSpring/CCBlog.git\n\n个人博客后续会每周更新一些不知道有没有用的功能、修改bug以及修改前端样式，欢迎大家参观\n\n有关三更项目的代码问题也可以在博客链接下进行提问，有时间的话我就会回复大家\n\n', '项目部署', 1, 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/15/ed226425691c4454b8d10cfcdfe71fe6.jpg', '1', '0', 69, '0', 1, '2023-05-15 15:02:30', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (12, '博客系统开发记录', '# 									博客系统\n\n## 1.父版本管理\n\n在父项目中使用dependencyManagement管理依赖，并不会引入依赖，而是对依赖进行版本控制，等到子项目引入相应的依赖后就不需要填写版本，进行了版本控制。\n\n```xml\n<dependencyManagement>\n        <dependencies>\n            <!-- SpringBoot的依赖配置-->\n            <!--对SpringBoot的版本进行配置，以后引入boot的相关依赖则不需要配置版本-->\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-dependencies</artifactId>\n                <version>2.5.0</version>\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n            <!--fastjson依赖-->\n            <dependency>\n                <groupId>com.alibaba</groupId>\n                <artifactId>fastjson</artifactId>\n                <version>1.2.33</version>\n            </dependency>\n            <!--jwt依赖-->\n            <dependency>\n                <groupId>io.jsonwebtoken</groupId>\n                <artifactId>jjwt</artifactId>\n                <version>0.9.0</version>\n            </dependency>\n\n            <!--mybatisPlus依赖-->\n            <dependency>\n                <groupId>com.baomidou</groupId>\n                <artifactId>mybatis-plus-boot-starter</artifactId>\n                <version>3.4.3</version>\n            </dependency>\n\n            <!--阿里云OSS-->\n            <dependency>\n                <groupId>com.aliyun.oss</groupId>\n                <artifactId>aliyun-sdk-oss</artifactId>\n                <version>3.10.2</version>\n            </dependency>\n\n\n            <dependency>\n                <groupId>com.alibaba</groupId>\n                <artifactId>easyexcel</artifactId>\n                <version>3.0.5</version>\n            </dependency>\n\n            <dependency>\n                <groupId>io.springfox</groupId>\n                <artifactId>springfox-swagger2</artifactId>\n                <version>2.9.2</version>\n            </dependency>\n            <dependency>\n                <groupId>io.springfox</groupId>\n                <artifactId>springfox-swagger-ui</artifactId>\n                <version>2.9.2</version>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n\n## 2. Bean对象复制工具类\n\n使用spring的BeanUtils工具类进行属性复制，并使用工作流、反射和泛型集成系统通用的工具类，对数据库返回的一级对象，进行属性的过滤，减少空间和提高安全性。工具的复制原理是根据实体类属性的类型和名称做复制。\n\n```java\n/**\n     * @param source 原对象\n     * @param clazz 复制目标对象的类属性\n     * @return: V   目标对象的泛型\n     * @decription 通过spring的工具类进行对象复制\n     * @date 2023/4/25 13:18\n    */\n    public static <V> V copyBean(Object source,Class<V> clazz){\n        V resutl = null;\n        try {\n            resutl = clazz.newInstance();\n            //复制\n            BeanUtils.copyProperties(source,resutl);\n        } catch (InstantiationException e) {\n            throw new RuntimeException(e);\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n        return resutl;\n    }\n\n    /**\n     * @param sources 原目标集合\n     * @param clazz 目标集合类型\n     * @return: java.util.List<V>\n     * @decription 通过spring工具类与工作流对集合的全部对象进行属性复制\n     * @date 2023/4/25 13:23\n    */\n    public static <O,V> List<V> copyBeans(List<O> sources,Class<V> clazz){\n        List<V> list = sources.stream()\n                .map(o -> copyBean(o, clazz))\n                .collect(Collectors.toList());\n        return list;\n    }\n```\n\n## 3. QueryWrapper对象进行限制结果条数\n\n### 3.1使用last方法进行limit处理\n\n```java\nLambdaQueryWrapper<Article> wrapper = new LambdaQueryWrapper<>();\n//排除草稿\nwrapper.eq(Article::getStatus, SystemConstant.ARTICLE_STATUS_NORMAL);\n//降序\nwrapper.orderByDesc(Article::getViewCount);\n//最多10条\nwrapper.last(\"limit 10\");\nList<Article> articles = articleMapper.selectList(wrapper);\nreturn articles;\n```\n\n### 3.2使用分页进行limit处理\n\n```java\nLambdaQueryWrapper<Article> wrapper = new LambdaQueryWrapper<>();\n//排除草稿\nwrapper.eq(Article::getStatus, SystemConstant.ARTICLE_STATUS_NORMAL);\n//降序\nwrapper.orderByDesc(Article::getViewCount);\n//最多10条\nPage<Article> page = articleMapper.selectPage(new Page<Article>(1,10),wrapper);\nList<Article> articles = page.getRecords();\nreturn articles;\n```\n\n## 4.跨域处理\n\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        // 设置允许跨域的路径\n        registry.addMapping(\"/**\")\n                // 设置允许跨域请求的域名\n                .allowedOriginPatterns(\"*\")\n                // 是否允许cookie\n                .allowCredentials(true)\n                // 设置允许的请求方式\n                .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\")\n                // 设置允许的header属性\n                .allowedHeaders(\"*\")\n                // 跨域允许时间\n                .maxAge(3600);\n    }\n\n}\n```\n\n## 5.日期格式转换\n\n后端传日期数据到前端的时候，系统使用默认的json转换，不适合阅读习惯，可以使用SpringBoot的@jsonFormat注解，指定json格式。\n\n### 5.1日期格式转换工具类\n\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n\n    @Bean//使用@Bean注入fastJsonHttpMessageConvert\n    public HttpMessageConverter fastJsonHttpMessageConverters() {\n        //1.需要定义一个Convert转换消息的对象\n        FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();\n        FastJsonConfig fastJsonConfig = new FastJsonConfig();\n        fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);\n        fastJsonConfig.setDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n        SerializeConfig.globalInstance.put(Long.class, ToStringSerializer.instance);\n\n        fastJsonConfig.setSerializeConfig(SerializeConfig.globalInstance);\n        fastConverter.setFastJsonConfig(fastJsonConfig);\n        HttpMessageConverter<?> converter = fastConverter;\n        return converter;\n    }\n\n    @Override\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\n        converters.add(fastJsonHttpMessageConverters());\n    }\n}\n```\n\n\n\n## 6.动态wrapper\n\n可以使用queryWrapper完成参数的动态注入，类似于动态标签，仅当条件成立的时候，才会添加条件限定\n\n```java\nLambdaQueryWrapper<Article> wrapper = new LambdaQueryWrapper<>();\n        //状态正常\n        wrapper.eq(Article::getStatus,SystemConstant.ARTICLE_STATUS_NORMAL);\n        wrapper.eq(Article::getDelFlag,SystemConstant.ARTICLE_STATUS_NORMAL);\n        //是否根据博文分类id分页,eq方法的重载，若第一个条件成立，则加入该条件限制查询\n        wrapper.eq(Objects.nonNull(categoryId)&&categoryId > 0,Article::getCategoryId,categoryId);\n        //排序，根据isTop字段，进行降序排序\n        wrapper.orderByDesc(Article::getIsTop);\n        //分页查询\n        Page<Article> articlePage = articleMapper.selectPage(new Page<Article>(pageNum, pageSize), wrapper);\n        articlePage.getRecords().stream()\n                .forEach(article -> {\n                    Category category = categoryService.getCategoryById(article.getCategoryId());\n                    article.setCategoryName(category.getName());\n                });\n```\n\n## 7. jwt登录工具	\n\n待更新\n\n## 8. SpringSecurity登录认证处理类\n\n区别于一般的SpringSecurity登录流程，此时可以自己调用方法进行认证，底层都是使用UserDetailsService，前者是SpringSecurity自己调用完成用户校验，后者是自己使用AuthenticationManager完成用户认证，并拿到用户令牌，而前者需要在securityContextholder（安全上下文）中获取。但是前者验证通过后会把用户的身份信息放入上下文中，而后者需要自己放入。\n\n```java\n@Service\npublic class BlogLoginServiceImpl implements BlogLoginService {\n\n    //用户认证管理器\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Autowired\n    private RedisTemplate<String,Object> redisTemplate;\n\n    @Override\n    public ResponseResult<BlogUserLoginVo> login(User user) {\n        //登录权证\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\n        //认证信息，该方法会调用userDetailService的认证逻辑，进行判断，此方法会使用UserDetailService进行逻辑判断\n        Authentication authentication = authenticationManager.authenticate(authenticationToken);\n        //获取认证用户信息\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n        //认证通过，生成token\n        String userId = loginUser.getUser().getId().toString();\n        String token = JwtUtil.createJWT(userId);\n        //把用户id和用户信息存入redis，过期时间为10分钟\n        redisTemplate.opsForValue().set(\"loginUser:\"+userId,loginUser,10, TimeUnit.MINUTES);\n\n        //把token和userInfo封装并返回\n        UserInfoVo userInfoVo = BeanCopyUtils.copyBean(loginUser.getUser(), UserInfoVo.class);\n        BlogUserLoginVo blogUserLoginVo = new BlogUserLoginVo(token, userInfoVo);\n        return ResponseResult.okResult(blogUserLoginVo);\n    }\n}\n```\n\n需要在springSecurity的配置文件中配置使用登录管理器AuthenticationManager\n\n```java\n//登录认证器，使用这个类可以管理登录信息，并进行相应处理\n    @Bean\n    @Override\n    protected AuthenticationManager authenticationManager() throws Exception {\n        return super.authenticationManager();\n    }\n```\n\n## 9.登录校验过滤器\n\n使用jwt进行token生成加密，并发送到前端之后，后续请求都会在请求头中附带token信息。此时需要一个过滤器，拦截请求，判断是否可以进行相应的操作。这种做法区别于先前的handlerInterceptor。\n\n### 9.1HandlerInterceptor\n\n```java\n//创建登录拦截器\npublic class JWTInterceptor implements HandlerInterceptor {\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n        String token = request.getHeader(\"token\");\n        //对令牌进行拦截验证\n        JWTUtils.verify(token);\n        return true;\n    }\n}\n\n//配置使用登录拦截器\n@Configuration\npublic class InterceptorConfig implements WebMvcConfigurer {\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) {\n        registry.addInterceptor(new JWTInterceptor())\n                .addPathPatterns(\"/**\")    //拦截全部请求\n                .excludePathPatterns(\n                        \"/user/goodsSearch/autoSuggest\"           //自动补齐关键字\n                );                         //放行的请求\n    }\n}\n```\n\n### 9.2 OncePerRequestFilter\n\n```java\n//创建登录拦截器\n@Component\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\n\n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {\n        //获取请求头中的token\n        String token = httpServletRequest.getHeader(\"token\");\n        //没有token则需要进行登录\n        if(!StringUtils.hasText(token)){\n            System.out.println(\"没有token身份信息，直接放行\");\n            filterChain.doFilter(httpServletRequest,httpServletResponse);\n            return;\n        }\n        //解析token\n        Claims claims = null;\n        try {\n            claims = JwtUtil.parseJWT(token);\n        } catch (Exception e) {\n            //token解析错误，重新登录\n            System.out.println(\"token解析错误\");\n            e.printStackTrace();\n            ResponseResult errorResult = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);\n            WebUtils.renderString(httpServletResponse, JSON.toJSONString(errorResult));\n            return;\n        }\n        //获取userId\n        String userId = claims.getSubject();\n        //从redis中获取用户信息\n        LoginUser loginUser = (LoginUser) redisTemplate.opsForValue().get(\"loginUser:\" + userId);\n        if(Objects.isNull(loginUser)){\n            System.out.println(\"redis身份信息过期，重新登录\");\n            ResponseResult errorResult = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);\n            WebUtils.renderString(httpServletResponse, JSON.toJSONString(errorResult));\n            return;\n        }\n        //将身份信息存入securityContext\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, null);\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n        //请求跳转\n        filterChain.doFilter(httpServletRequest,httpServletResponse);\n    }\n}\n\n//配置使用拦截器\n@Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //开启跨域\n        http.cors();\n        //关闭csrf\n        http.csrf().disable();\n        //配置权限\n        http.authorizeRequests().antMatchers(\"/login\").permitAll()\n                .antMatchers(\"/link/getAllLink\").authenticated()\n                //前台不需要仅限权限管理，不需要登录也可以进行全部操作\n                .anyRequest().permitAll();\n        //配置登录检验过滤器\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n    }\n```\n\n### 9.3 SpringSecurity安全框架知识补充\n\n1.使用该框架进行登录之后，系统框架会自动把用户的信息存入SecurityContextHolder中，这样下次再进行某些	需要登录才能访问的请求的时候，就不需要再重新登录。\n\n2.SecurityContextHolder是基于ThreadLocal实现的，每个线程的身份凭证都是独立的，互不影响。\n\n3.InsufficientAuthenticationException，用户未登录异常类，当用户请求一些需要登录才可以访问的路径的时	        	候，就会抛出此异常\n\n4.BadCredentialsException，当用户输入的密码不匹配的时候，就会抛出此类异常\n\n5.SecurityContextHolder，使用该上下文类，可以设置，获取以及消除认证用户，setContext 可以进行认证用户	的设置；getContext 获取到当前认证用户。clearContext 清除当前的认证用户。\n\n\n\n### 9.4 使用自定退出登录功能\n\n```java\npublic ResponseResult logout() {\n        //1.清除redis缓存\n        LoginUser loginUser = (LoginUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n        Long userId = loginUser.getUser().getId();\n        redisTemplate.delete(\"loginUser:\"+userId.toString());\n        //2.清除SecurityContext中的凭证信息\n        SecurityContextHolder.clearContext();\n        return ResponseResult.okResult();\n    }\n```\n\n```java\n//并在security的配置类中取消系统自带的退出登录功能\n//禁止security自带的推出登录\nhttp.logout().disable();\n```\n\n## 10.afterPropertiesSet方法\n\n在spring的bean的生命周期中，实例化->生成对象->属性填充后会进行afterPropertiesSet方法，这个方法可以用在一些特殊情况中，也就是某个对象的某个属性需要经过外界得到，比如说查询数据库等方式，这时候可以用到spring的该特性，只需要实现InitializingBean即可。而在redis之中，该方法已经别被redis的模板重写，具体的作用是对redis的连接工厂进行一个非空的判断。\n\n![image-20230505101746023](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230505101746023.png)\n\n![image-20230505101748896](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230505101748896.png)\n\n## 11.Redis序列化\n\n```java\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {\n        //创建模板\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        //设置工厂\n        template.setConnectionFactory(connectionFactory);\n\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\n        template.setKeySerializer(new StringRedisSerializer());\n        //	使用redis自带的序列化工具，完成值的序列化处理\n        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());\n\n        // Hash的key也采用StringRedisSerializer的序列化方式\n        template.setHashKeySerializer(new StringRedisSerializer());\n        //	使用redis自带的序列化工具，完成值的序列化处理\n        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());\n\n        //已解决，在redisTemplate完成属性注入之后，进行一些初始化操作，具体为设置模板的连接工厂判断，不能为null，否则会抛出异常，\n        //该方法就是设置抛出异常，并设置异常信息\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n```\n\n## 12.OSS七牛云图片存储服务\n\n### 12.1进行七牛图片服务的配置\n\n```yml\noss:\n  accessKey: 5-2GlwUhAhcdzxRewexQrBqAVhmfBlOXyi1b5fVH\n  secretKey: _HUU99Np_NNMUr--WWPjrpCKGJZqRBvocm8UVvfP\n  bucket: ccg\n  url: http://ru8h77emb.hn-bkt.clouddn.com/\n```\n\n### 12.2使用官方模板进行图片上传并回传图片路径\n\n~~~~java\n/**\n * @ClassName UploadServiceImpl\n * @Description 图片上传服务\n * @Author cc\n * @Date 2023/5/6 20:15\n * @Version 1.0\n */\n@Service\npublic class UploadServiceImpl implements UploadService {\n\n    @Value(\"${oss.accessKey}\")\n    private String accessKey;\n\n    @Value(\"${oss.secretKey}\")\n    private String secretKey;\n\n    @Value(\"${oss.bucket}\")\n    private String bucket;\n\n    @Value(\"${oss.url}\")\n    private String url;\n\n    @Override\n    public ResponseResult uploadImg(MultipartFile img) {\n        //获取源文件名\n        String originalFilename = img.getOriginalFilename();\n        //判断文件后缀，目前只支持jpg和png\n        if(!(originalFilename.endsWith(\"jpg\")||originalFilename.endsWith(\"png\"))){\n            throw new SystemException(AppHttpCodeEnum.IMG_TYPE_ERROR);\n        }\n        String imgPath = PathUtils.generateFilePath(originalFilename);\n        //进行图片上传到oss，并返回url地址\n        String imgUrl = uploadToOOS(img, imgPath);\n        return ResponseResult.okResult(imgUrl);\n    }\n\n    private String uploadToOOS(MultipartFile img,String filePath){\n        //构造一个带指定 Region 对象的配置类\n        Configuration cfg = new Configuration(Region.autoRegion());\n        //...其他参数参考类注释\n        UploadManager uploadManager = new UploadManager(cfg);\n        //默认不指定key的情况下，以文件内容的hash值作为文件名\n        String key = filePath;\n\n        try {\n            InputStream inputStream = img.getInputStream();\n            Auth auth = Auth.create(accessKey, secretKey);\n            String upToken = auth.uploadToken(bucket);\n\n            try {\n                Response response = uploadManager.put(inputStream,key,upToken,null, null);\n                //解析上传成功的结果\n                DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class);\n                return url+key;\n            } catch (QiniuException ex) {\n                Response r = ex.response;\n                System.err.println(r.toString());\n                try {\n                    System.err.println(r.bodyString());\n                } catch (QiniuException ex2) {\n                    //ignore\n                }\n            }\n        } catch (Exception ex) {\n            //ignore\n        }\n        return null;\n    }\n}\n~~~~\n\n## 13.参数校验\n\nSpringBoot自带了validation工具可以从后端对前端传来的参数进行校验，用法如下：添加起步依赖\n\n~~~~xml\n<!-- 参数校验 -->\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-validation</artifactId>\n</dependency>\n~~~~\n\n~~~~java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@ApiModel(\"用户表(CcUser)表实体类\")\npublic class User {\n    //主键\n    private Long id;\n    //用户名\n    @NotNull(message = \"用户名不能为空\")\n    @NotBlank(message = \"用户名不能为空\")\n    @ApiModelProperty(\"用户名\")\n    private String userName;\n    //昵称\n    @NotNull(message = \"昵称不能为空\")\n    @NotBlank(message = \"昵称不能为空\")\n    @ApiModelProperty(\"昵称\")\n    private String nickName;\n    //密码\n    @NotNull(message = \"密码不能为空\")\n    @NotBlank(message = \"密码不能为空\")\n    @ApiModelProperty(\"密码\")\n    private String password;\n    //用户类型：0代表普通用户，1代表管理员\n    @ApiModelProperty(\"用户类型：0代表普通用户，1代表管理员\")\n    private String type;\n    //账号状态（0正常 1停用）\n    @ApiModelProperty(\"账号状态（0正常 1停用）\")\n    private String status;\n    //邮箱\n    @NotNull(message = \"邮箱不能为空\")\n    @NotBlank(message = \"邮箱不能为空\")\n    @Email(message = \"邮箱格式不合法\")\n    @ApiModelProperty(\"邮箱\")\n    private String email;\n    //手机号\n    @ApiModelProperty(\"手机号\")\n    private String phonenumber;\n    //用户性别（0男，1女，2未知）\n    @ApiModelProperty(\"用户性别（0男，1女，2未知）\")\n    private String sex;\n    //头像\n    @ApiModelProperty(\"头像\")\n    private String avatar;\n    //创建人的用户id\n    private Long createBy;\n    //创建时间\n    private Date createTime;\n    //更新人\n    private Long updateBy;\n    //更新时间\n    private Date updateTime;\n    //删除标志（0代表未删除，1代表已删除）\n    private Integer delFlag;\n\n}\n~~~~\n\n详情请看后续个人博客SpringBoot专栏\n\n## 14.AspectJ框架实现aop日志功能\n\n### 14.1自定义注解，实现注解开启代理\n\n~~~java\n//自定义注解实现AOP日志功能\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface SystemLog {\n    String Description();\n}\n~~~\n\n### 14.2配置切面\n\n~~~java\n/**\n * @ClassName LogAspect\n * @Description 日志功能工具类\n * @Author cc\n * @Date 2023/5/7 11:29\n * @Version 1.0\n */\n@Component\n@Aspect\n@Slf4j\npublic class LogAspect {\n\n    {\n        System.out.println(\"对象创建成功\");\n    }\n\n    //切点，使用了该注解的方法都会被代理\n    @Pointcut(\"@annotation(com.zxnk.annotation.SystemLog)\")\n    public void pointCut(){}\n\n    //配置环绕通知\n    @Around(\"pointCut()\")\n    public Object aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n        Object result = null;\n        try {\n            //前置通知\n            beforeAdvice(proceedingJoinPoint);\n            //方法执行，此代码一定要执行，否则被代理的方法不会执行，没有返回值\n            result = proceedingJoinPoint.proceed();\n            //后置通知\n            afterAdvice(result);\n        }finally {\n            // 结束后换行\n            log.info(\"=======End=======\" + System.lineSeparator());\n        }\n        return result;\n    }\n\n    //前置打印消息\n    private void beforeAdvice(ProceedingJoinPoint proceedingJoinPoint){\n        //获取请求对象,带有contextHolder的对象都是上下文对象，javaWeb基于面向对象的理念，把请求也封装成上下文对象\n        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = requestAttributes.getRequest();\n\n        //获取注解对象\n        SystemLog systemLog = getSystemLog(proceedingJoinPoint);\n\n        log.info(\"=======Start=======\");\n        // 打印请求 URL\n        log.info(\"URL            : {}\",request.getRequestURL());\n        // 打印描述信息\n        log.info(\"Description   : {}\",systemLog.Description());\n        // 打印 Http method\n        log.info(\"HTTP Method    : {}\",request.getMethod());\n        // 打印调用 controller 的全路径以及执行方法\n        log.info(\"Class Method   : {}.{}\",proceedingJoinPoint.getTarget().getClass().getName(),proceedingJoinPoint.getSignature().getName());\n        // 打印请求的 IP\n        log.info(\"IP             : {}\",request.getRemoteHost());\n        // 打印请求入参\n        log.info(\"Request Args   : {}\", JSON.toJSON(proceedingJoinPoint.getArgs()));\n    }\n\n    //后置打印消息\n    private void afterAdvice(Object result){\n        // 打印出参\n        log.info(\"Response       : {}\",JSON.toJSONString(result));\n    }\n\n    //获取注解对象\n    private SystemLog getSystemLog(ProceedingJoinPoint proceedingJoinPoint){\n        //获取具体的代理方法\n        MethodSignature signature = (MethodSignature) proceedingJoinPoint.getSignature();\n        //通过方法获取注解\n        SystemLog systemLog = signature.getMethod().getAnnotation(SystemLog.class);\n        return systemLog;\n    }\n}\n~~~\n\n### 14.3配置切点\n\n~~~java\n    @PostMapping(\"/register\")\n    @ApiOperation(value = \"进行新用户的注册\",notes = \"用名户、昵称不能重复,密码必须是小写英文字母加数字且长度大于6，而且各类数据均不可为空\")\n    @SystemLog(Description = \"进行用户注册\")\n    public ResponseResult register(@RequestBody User user){\n        return userService.register(user);\n    }\n~~~\n\n### 14.4知识总结\n\n```java\n@Retention(RetentionPolicy.RUNTIME)	//元注解，表示运行时起作用\n@Target(ElementType.METHOD)			//元注解，表示该注解作用在方法上\n```\n\n```java\n//切点，使用了该注解的方法都会被代理\n@Pointcut(\"@annotation(com.zxnk.annotation.SystemLog)\")\npublic void pointCut(){}\n```\n\n配置环绕通知的时候，一定要执行proceed方法，否则切点方法无法正常执行\n\n~~~java\n//配置环绕通知\n    @Around(\"pointCut()\")\n    public Object aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {\n        Object result = null;\n        try {\n            //前置通知\n            beforeAdvice(proceedingJoinPoint);\n            //方法执行，此代码一定要执行，否则被代理的方法不会执行，没有返回值\n            result = proceedingJoinPoint.proceed();\n            //后置通知\n            afterAdvice(result);\n        }finally {\n            // 结束后换行\n            log.info(\"=======End=======\" + System.lineSeparator());\n        }\n        return result;\n    }\n~~~\n\n~~~java\n//获取请求对象,带有contextHolder的对象都是上下文对象，javaWeb基于面向对象的理念，把请求也封装成上下文对象，使用该上下文对象可以获取http请求对象，接而获取请求的基本信息\n        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n        HttpServletRequest request = requestAttributes.getRequest();\n~~~\n\n通过切点对象的签名方法进而获取到注解\n\n~~~java\n//获取具体的代理方法\nMethodSignature signature = (MethodSignature) proceedingJoinPoint.getSignature();\n//通过方法获取注解\nSystemLog systemLog = signature.getMethod().getAnnotation(SystemLog.class);\n~~~\n\n## 15.项目启动任务\n\n### 15.1starter起步依赖\n\n需要后续学习\n\n### 15.2类加载时机\n\n```java\nstatic{\n	sout(\"do something\")\n}\n```\n\njvm完成该类的加载之后就会执行相应的静态代码块，可实现项目启动任务\n\n### 15.3对象创建时机\n\n```java\n@Component\npublic MyBean{\n    {\n        sout(\"do something\")\n    }\n}\n```\n\n创建一个bean对象并交给spring容器管理，当spring完成容器初始化，就会创建bean对象放入容器进行管理，此时执行对象创建逻辑，实现项目启动任务\n\n### 15.4Bean对象afterpropertiesSet方法\n\n详情请看文档的第10条总结\n\n### 15.5@postconstruct注解\n\nBean对象的生命周期包含创建——使用——销毁，Spring可以配置Bean对象在创建和销毁时自动执行的方法：\n\n在bean对象上方使用@postconstruct注解，定义初始化方法\n\n使用@predestory注解，定义销毁时机方法\n\n### 15.6CommandLineRunner接口\n\n实现CommandLineRunner接口，实现run方法，完成数据预热功能\n\n~~~java\n/**\n * @ClassName ViewCountRunner\n * @Description 数据预热类，在应用启动成功时，查询数据库，将所有的文章浏览次数存入redis\n * @Author cc\n * @Date 2023/5/7 17:01\n * @Version 1.0\n */\n@Component\npublic class ViewCountRunner implements CommandLineRunner {\n\n    @Autowired\n    private ArticleService articleService;\n    @Autowired\n    private RedisTemplate redisTemplate;\n\n    //启动成功时执行的方法\n    @Override\n    public void run(String... args) throws Exception {\n        //查询所有博文\n        List<Article> articles = articleService.findAll();\n        //将博文集合转成hashmap存入redis中\n        Map<String, Integer> map = articles.stream()\n                .collect(Collectors.toMap(article -> article.getId().toString(), article -> article.getViewCount().intValue()));\n        //存入redis中\n        redisTemplate.opsForHash().putAll(\"viewCount\",map);\n    }\n}\n~~~\n\n## 16.Swagger2入门\n\n### 16.1引入依赖\n\n```xml\n		 <dependency>\n            <groupId>io.springfox</groupId>\n            <artifactId>springfox-swagger2</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>io.springfox</groupId>\n            <artifactId>springfox-swagger-ui</artifactId>\n        </dependency>\n```\n\n### 16.2开启swagger2功能注解\n\n```java\n@SpringBootApplication\n@MapperScan(\"com.zxnk.mapper\")\n@EnableAspectJAutoProxy\n//开启定时任务\n@EnableScheduling\n//开启swagger2接口文档\n@EnableSwagger2\npublic class BlogAdminApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(BlogAdminApplication.class,args);\n        System.out.println(\"博客前台项目启动成功\");\n    }\n}\n```\n\n### 16.3接口文档地址\n\nlocalhost:port/swagger-ui.html\n\n### 16.4具体用法\n\n~~~java\n@RestController\n@RequestMapping(\"/article\")\n@Api(tags = \"博客文章控制类\",description = \"博客文章相应接口\")\npublic class ArticleController {\n\n    @Autowired\n    private ArticleService articleService;\n    @Autowired\n    private CategoryService categoryService;\n\n    @GetMapping(\"/list\")\n    @ApiOperation(value = \"获取全部文章\")\n    public List<Article> findAll(){\n        return articleService.findAll();\n    }\n\n    /**\n     * @return: com.zxnk.util.ResponseResult<java.util.List<com.zxnk.dto.HotArticleVo>>\n     * @decription 返回最做多点击的10条博文，排除草稿\n     * @date 2023/4/25 13:30\n    */\n    @GetMapping(\"/hotArticleList\")\n    @ApiOperation(\"返回最做多点击的10条博文，排除草稿\")\n    public ResponseResult<List<HotArticleVo>> hotArticleList(){\n        List<Article> result = articleService.hotArticleList();\n        List<HotArticleVo> hotArticleVos = BeanCopyUtils.copyBeans(result, HotArticleVo.class);\n        return ResponseResult.okResult(hotArticleVos);\n    }\n\n    /**\n     * @param pageNum 初始页\n     * @param pageSize 每页条数\n     * @param categoryId 博文类别id\n     * @return: com.zxnk.util.ResponseResult<com.zxnk.dto.PageVo>\n     * @decription 根据分页条件，对博文进行分页查询，并判断是否选择同一类别下的博文，并且博文的状态必须是正常的，而且对数据采用置顶的排序\n     * @date 2023/4/26 10:39\n    */\n    @GetMapping(\"/articleList\")\n    @ApiOperation(\"根据分页条件，对博文进行分页查询，并判断是否选择同一类别下的博文，并且博文的状态必须是正常的，而且对数据采用置顶的排序\")\n    @ApiImplicitParams({\n            @ApiImplicitParam(name = \"pageNum\",value = \"分页页号\"),\n            @ApiImplicitParam(name = \"pageSize\",value = \"分页大小\"),\n            @ApiImplicitParam(name = \"categoryId\",value = \"文章类别id\")\n    })\n    public ResponseResult<PageVo> articleList(@RequestParam(defaultValue = \"0\")Integer pageNum,\n                                              @RequestParam(defaultValue = \"10\") Integer pageSize,\n                                              Long categoryId){\n        //获取分页对象\n        Page<Article> articlePage = articleService.articleList(pageNum, pageSize, categoryId);\n        //获取博文对象\n        List<Article> articleList = articlePage.getRecords();\n        //完成数据的封装\n        List<ArticleVo> articleVoList = BeanCopyUtils.copyBeans(articleList, ArticleVo.class);\n        PageVo pageVo = new PageVo(articleVoList, articlePage.getTotal());\n        return ResponseResult.okResult(pageVo);\n    }\n\n    @ApiOperation(\"根据id查询相应的文章详情\")\n    @GetMapping(\"/{id}\")\n    @ApiImplicitParam(name = \"id\",value = \"文章id\")\n    public ResponseResult<ArticleDetailVo> getArticleDetailById(@PathVariable Long id){\n        return ResponseResult.okResult(articleService.findById(id));\n    }\n\n    @ApiOperation(\"根据id更新文章的浏览量\")\n    @PutMapping(\"/updateViewCount/{id}\")\n    @ApiImplicitParam(name = \"id\",value = \"文章id\")\n    public ResponseResult updateViewCount(@PathVariable Long id){\n        return articleService.updateViewCountById(id);\n    }\n}\n~~~\n\n```java\n//描述类信息\n@Api(tags = \"博客文章控制类\",description = \"博客文章相应接口\")\n//描述方法信息\n@ApiOperation(\"根据id更新文章的浏览量\")\n//描述请求参数信息\n@ApiImplicitParams({\n            @ApiImplicitParam(name = \"pageNum\",value = \"分页页号\"),\n            @ApiImplicitParam(name = \"pageSize\",value = \"分页大小\"),\n            @ApiImplicitParam(name = \"categoryId\",value = \"文章类别id\")\n})\n//描述实体类信息\n@ApiModel(\"用户表(CcUser)表实体类\")\n//描述实体类属性信息\n@ApiModelProperty(\"用户名\")\n```\n\n### 16.5配置类，描述接口文档的配置信息\n\n~~~java\n/**\n * @ClassName Swagger2Config\n * @Description swagger2配置类\n * @Author cc\n * @Date 2023/5/7 20:39\n * @Version 1.0\n */\n@Configuration\npublic class Swagger2Config {\n\n    @Bean\n    public Docket customDocket() {\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo())\n                .select()\n                .apis(RequestHandlerSelectors.basePackage(\"com.zxnk.controller\"))\n                .build();\n    }\n\n    private ApiInfo apiInfo() {\n        Contact contact = new Contact(\"ccg\", \"http://8.142.134.180\", \"ccgccg@yeah.net\");\n        return new ApiInfoBuilder()\n                .title(\"博客系统\")\n                .description(\"以下是博客系统的开发文档\")\n                .contact(contact)   // 联系方式\n                .version(\"1.0.0\")  // 版本\n                .build();\n    }\n}\n~~~\n\n## 17.EasyExcel框架\n\n### 17.1开发手册\n\n使用EasyExcel实现Excel的导出操作。\n\n博客地址：https://github.com/alibaba/easyexcel\n\n开发文档：https://easyexcel.opensource.alibaba.com/docs/current/quickstart/write#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1\n\n### 17.2示例代码\n\n~~~java\n    /**\n     * 文件下载并且失败的时候返回json（默认失败了会返回一个有部分数据的Excel）\n     *\n     * @since 2.1.1\n     */\n    @GetMapping(\"downloadFailedUsingJson\")\n    public void downloadFailedUsingJson(HttpServletResponse response) throws IOException {\n        // 这里注意 有同学反应使用swagger 会导致各种问题，请直接用浏览器或者用postman\n        try {\n            response.setContentType(\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\");\n            response.setCharacterEncoding(\"utf-8\");\n            // 这里URLEncoder.encode可以防止中文乱码 当然和easyexcel没有关系\n            String fileName = URLEncoder.encode(\"测试\", \"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n            response.setHeader(\"Content-disposition\", \"attachment;filename*=utf-8\'\'\" + fileName + \".xlsx\");\n            // 这里需要设置不关闭流\n            EasyExcel.write(response.getOutputStream(), DownloadData.class).autoCloseStream(Boolean.FALSE).sheet(\"模板\")\n                .doWrite(data());\n        } catch (Exception e) {\n            // 重置response\n            response.reset();\n            response.setContentType(\"application/json\");\n            response.setCharacterEncoding(\"utf-8\");\n            Map<String, String> map = MapUtils.newHashMap();\n            map.put(\"status\", \"failure\");\n            map.put(\"message\", \"下载文件失败\" + e.getMessage());\n            response.getWriter().println(JSON.toJSONString(map));\n        }\n    }\n~~~\n\n### 17.3个人开发代码\n\n~~~java\n@GetMapping(\"/export\")\n    public void export(HttpServletResponse response) throws IOException {\n        try {\n            //设置下载响应头信息\n            WebUtils.setDownLoadHeader(\"CC博客项目文章分类表.xlsx\",response);\n            //获取所有可用的博文分类\n            List<Category> allCategories = categoryService.getAllCategories();\n            //完成属性赋值，简化对象的属性\n            List<ExcelCategoryVo> excelCategoryVos = BeanCopyUtils.copyBeans(allCategories, ExcelCategoryVo.class);\n            //调用框架完成下载输出\n            EasyExcel.write(response.getOutputStream(), ExcelCategoryVo.class)  //响应对象流，响应对象的模板类属性\n                    .autoCloseStream(Boolean.FALSE)              //不关闭流\n                    .sheet(\"CC博文分类\")                //excel顶部的命名\n                    .doWrite(excelCategoryVos);                  //写出的数据\n        } catch (Exception e) {\n            // 重置response，清除数据和响应参数\n            response.reset();\n            response.setContentType(\"application/json\");\n            response.setCharacterEncoding(\"utf-8\");\n            //写出错误信息\n            response.getWriter().println(JSON.toJSONString(ResponseResult.errorResult(AppHttpCodeEnum.SYSTEM_ERROR)));\n        }\n    }\n~~~\n\n### 17.4配置输出对象属性\n\n~~~java\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Builder\npublic class ExcelCategoryVo {\n\n    //name\n    @ExcelProperty(value = \"分类名\")	//指定excel列的名称\n    private String name;\n\n    //描述\n    @ExcelProperty(value = \"描述\")\n    private String description;\n\n    //状态\n    @ExcelProperty(value = \"状态\")\n    private String status;\n}\n~~~\n\n### 17.5设置响应头\n\n~~~java\n/**\n     * @param filename 下载的文件名\n     * @param response 响应对象\n     * @return: void\n     * @decription 创建exel表下载请求\n     * @date 2023/5/9 20:56\n    */\n    public static void setDownLoadHeader(String filename, HttpServletResponse response) throws UnsupportedEncodingException {\n        //设置下载的响应类型\n        response.setContentType(\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\");\n        //设置编码\n        response.setCharacterEncoding(\"utf-8\");\n        //设置文件名，防止乱码\n        String fname= URLEncoder.encode(filename,\"UTF-8\").replaceAll(\"\\\\+\", \"%20\");\n        //设置下载的响应头\n        response.setHeader(\"Content-disposition\",\"attachment; filename=\"+fname);\n    }\n~~~\n\n## 18.自定义权限校验\n\n### 18.1权限校验类\n\n~~~java\n@Service(\"permissions\")\npublic class PermissionsService {\n\n    /**\n     * @param permission 权限\n     * @return: boolean  是否具有权限\n     * @decription 判断当前用户是否具有该权限\n     * @date 2023/5/9 21:35\n    */\n    public boolean hasAnyAuthorities(String permission){\n        LoginUser loginUser = SecurityUtils.getLoginUser();\n        //如果是超级管理员，直接返回true\n        if(loginUser.getUser().getId().equals(1L)){\n            return true;\n        }else {\n            //获取当前用户的权限列表，判断是否拥有该权限\n            List<String> permissions = loginUser.getPermissions();\n            return permissions.contains(permission);\n        }\n    }\n}\n~~~\n\n### 18.2进行校验配置\n\n~~~java\n@Configuration\n//开启注解权限方法\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {}\n\n//拥有该权限才可以调用此方法，permissions是服务类的bean名称，hasAnyAuthorities是服务类的方法，括号里	//面的参数是方法的输入值\n@PreAuthorize(\"@permissions.hasAnyAuthorities(\'content:category:export\')\")\n@GetMapping(\"/export\")\npublic void export(HttpServletResponse response) throws IOException {}\n~~~\n\n', '记录用到的技术', 1, 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/17/62436dbc5d684c2bb177349d2c873052.jpg', '1', '0', 36, '0', 1, '2023-05-15 15:26:20', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (13, 'stream流demo', '## 8.stream工作流\n\n### 8.1创建流\n\n1.单例集合 list/set.stream()\n\n2.数组 Arrays.stream(Object[] arr) / Stream.of(Object[] arr)\n\n3.双例集合 map.entryset().stream()\n\n### 8.2中间操作\n\n1.filter 可以对流中的数据进行条件过滤，符合条件的数据继续留在流中\n\nstream.filter(book -> book.price > 100.0);\n\n2.map 可以把流中的元素进行计算或者转换（数据类型转换）\n\nstream.map(book -> book.price+10)\n\n3.distinct可以去除流中的重复元素,通过对象的equals方法进行判断\n\nstream.distinct()\n\n4.sorted可以对流中的元素进行排序，如果调用空参的sorted()方法，需要实现comparable接口\n\nstream.sort((b1,b2) -> b1.price-b2.price)\n\n5.limit可以设置流的最大长度，超出的部分被抛弃\n\nstream.limit(2)\n\n6.skip跳过流中的前几个元素，返回剩下的元素\n\nstream.skip(2)\n\n7.flatmap map只能把一个对象转换成另一个对象来作为流中的元素，而flatmap可以把一个对象转换成多个对象	作为流中的元素\n\nstream.flatmap(book -> book.categories)\n\n### 8.3终结操作\n\n1.foreach 对流中的数据进行遍历操作\n\nstream.forEach(book -> sout(book.author))\n\n2.count 可以用来获取当前流中的元素个数\n\nstream.count()\n\n3.max&min 可以用来获取流中的最值，实现comparable接口或者自定义比较规则\n\nstream.min((b1,b2) -> b1.price- b2.price)\n\n4.collect把当前流转换成一个集合\n\nstream.collect(Collectors.toList())\n\nstream.collect(Collectors.toSet)\n\nstream.collect(Collectors.toMap(book -> book.author,book -> book.name))\n\n5.anyMatch 可以用来判断是否有任意符合匹配规条件的元素，结果为Boolean类型\n\nstream.anyMatch(book -> book.price > 100.0)\n\n6.allMath 可以用来判断是否都符合匹配条件，结果为Boolean类型\n\nstream.allMatch(book -> book.price > 100.0)\n\n7.noneMatch可以用来判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则为false\n\nstream.noneMatch(book -> book.price > 100.0)\n\n8.findAny 随机获取流中的元素，不保证顺序\n\nstream.findAny()\n\n9.findFirst 获取流中的第一个元素\n\nstream.findFirst()', 'demo', 1, '', '1', '0', 3, '0', 1, '2023-05-17 15:27:28', 1, '2023-05-20 16:42:30', 1);
INSERT INTO `cc_article` VALUES (14, '5-17Vue学习总结', '## 4. 5/17日总结\n\n### 4.1事件修饰符\n\n在绑定事件的后面可以使用“.事件修饰符”的方式，给事件加一个修饰属性，限制事件的行为，并且修饰符可以连续写，常用的修饰符有\n\n```html\n<!-- \nVue中的事件修饰符：\n1.prevent：阻止默认事件（常用）；\n2.stop：阻止事件冒泡（常用）；\n3.once：事件只触发一次（常用）；\n4.capture：使用事件的捕获模式；\n5.self：只有event.target是当前操作的元素时才触发事件；\n6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕；\n-->\n<!-- 准备好一个容器-->\n<h2>欢迎来到{{name}}学习</h2>\n<!-- 阻止默认事件（常用） -->\n<a href=\"http://www.atguigu.com\" @click.prevent=\"showInfo\">点我提示信息</a>\n\n<!-- 阻止事件冒泡（常用） -->\n<div class=\"demo1\" @click=\"showInfo\">\n    <button @click.stop=\"showInfo\">点我提示信息</button>\n    <!-- 修饰符可以连续写 -->\n    <!-- <a href=\"http:xx\" @click.prevent.stop=\"showInfo\">点我提示信息</a> -->\n</div>\n\n<!-- 事件只触发一次（常用） -->\n<button @click.once=\"showInfo\">点我提示信息</button>\n\n<!-- 使用事件的捕获模式 -->\n<div class=\"box1\" @click.capture=\"showMsg(1)\">\n    div1\n    <div class=\"box2\" @click=\"showMsg(2)\">\n        div2\n    </div>\n</div>\n\n<!-- 只有event.target是当前操作的元素时才触发事件； -->\n<div class=\"demo1\" @click.self=\"showInfo\">\n    <button @click=\"showInfo\">点我提示信息</button>\n</div>\n<!-- @wheel滚轮事件-->\n<!-- 事件的默认行为立即执行，无需等待事件回调执行完毕； -->\n<ul @wheel.passive=\"demo\" class=\"list\">\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n</ul>\n```\n\n### 4.2键盘事件\n\n按键事件，例如keydown和keyup可以在后面使用“.enter”增加按键属性，当按下该键时才会触发相应的事件\n\n~~~html\n<body>\n<!-- \n    1.Vue中常用的按键别名：\n    回车 => enter\n    删除 => delete (捕获“删除”和“退格”键)\n    退出 => esc\n    空格 => space\n    换行 => tab (特殊，必须配合keydown去使用)\n    上 => up\n    下 => down\n    左 => left\n    右 => right\n\n    2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）\n	  可以使用事件方法，传输事件属性，来获取事件的按键名称和按键编码，console.log(e.key,e.keyCode)\n\n    3.系统修饰键（用法特殊）：ctrl、alt、shift、meta(wins键)\n    (1).配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。\n    (2).配合keydown使用：正常触发事件。\n\n    4.也可以使用keyCode去指定具体的按键（不推荐，需要做到见名知意）\n\n    5.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名\n-->\n    <!-- 准备好一个容器-->\n		<div id=\"root\">\n			<h2>欢迎来到{{name}}学习</h2>\n			<input type=\"text\" placeholder=\"按下回车提示输入\" @keydown.huiche=\"showInfo\">\n		</div>\n</body>\n\n<script type=\"text/javascript\">\n    Vue.config.keyCodes.huiche = 13 //定义了一个别名按键\n\n    new Vue({\n        el:\'#root\',\n        data:{\n            name:\'尚硅谷\'\n        },\n        methods: {\n            showInfo(e){\n                // console.log(e.key,e.keyCode)\n                console.log(e.target.value)\n            }\n        },\n    })\n</script>\n~~~\n\n### 4.3计算方法\n\n计算属性，可以用来执行一些复杂的处理逻辑，并将结果返回。而且计算属性里面的对象会作为vm的属性，可以直接调用，底层借助了Objcet.defineproperty方法提供的getter和setter。\n\n~~~html\n<body>\n<!-- \n    计算属性：\n    1.定义：要用的属性不存在，要通过已有属性计算得来。\n    2.原理：底层借助了Objcet.defineproperty方法提供的getter和setter。\n    3.get函数什么时候执行？\n        (1).初次读取时会执行一次。\n        (2).当依赖的数据发生改变时会被再次调用。\n    4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。\n    5.备注：\n        1.计算属性最终会出现在vm上，直接读取使用即可。\n        2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。\n-->\n    <!-- 准备好一个容器-->\n    <div id=\"root\">\n        姓：<input type=\"text\" v-model=\"firstName\"> <br/><br/>\n        名：<input type=\"text\" v-model=\"lastName\"> <br/><br/>\n        全名：<span>{{fullName}}</span> <br/><br/>\n    </div>\n</body>\n\n<script type=\"text/javascript\">\n       const vm = new Vue({\n        el:\'#root\',\n        data:{\n            firstName:\'张\',\n            lastName:\'三\'\n        },\n        computed:{\n            fullName:{\n                //get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值\n                //get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。\n                get(){\n                    console.log(\'get被调用了\')\n                    // console.log(this) //此处的this是vm\n                    return this.firstName + \'-\' + this.lastName\n                },\n                //set什么时候调用? 当fullName被修改时。\n                set(value){\n                    console.log(\'set\',value)\n                    const arr = value.split(\'-\')\n                    this.firstName = arr[0]\n                    this.lastName = arr[1]\n                }\n            }\n            //当对象中只有get方法，就可以进行简写\n            // fullName(){\n            // 	console.log(\'get被调用了\')\n            // 	return this.firstName + \'-\' + this.lastName\n            // }\n        }\n    })\n</script>\n~~~\n\n### 4.4代码练习\n\n~~~html\n<body>\n    <div id=\"root\">\n        <!-- \n				Vue中的事件修饰符：\n						1.prevent：阻止默认事件（常用）；\n						2.stop：阻止事件冒泡（常用）；\n						3.once：事件只触发一次（常用）；\n		-->\n        <input type=\"button\" value=\"click me\" @click.once=\"func0\">\n        <br>\n        <input type=\"text\" v-model:value=\"name\">\n        <br>\n        <a href=\"http://8.142.134.180:5213\" v-on:click.prevent=\"func1\">{{name}}</a>\n        <br>\n\n        <div class=\"ccc\" @click=\"func2\">\n            \n            <input type=\"button\" @click.stop=\"func2\" value=\"click here\">\n            \n        </div>\n    </div>\n    <!-- \n	1.Vue中常用的按键别名：\n		回车 => enter\n		删除 => delete (捕获“删除”和“退格”键)\n		退出 => esc\n		空格 => space\n		换行 => tab (特殊，必须配合keydown去使用)\n		上 => up\n		下 => down\n		左 => left\n		右 => right\n\n	2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名）\n	3.Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名\n		-->\n    <div id=\"cc2\">\n        <textarea placeholder=\"进行输入记录\" @keydown.a=\"tips($event)\" ></textarea>\n        <textarea placeholder=\"按下回车触发彩蛋\" @keydown.enter=\"surprise\"></textarea>\n    </div>\n    <div id=\"cc1\">\n        <input type=\"text\" v-model:value=\"firstname\">\n        <input type=\"text\" v-model:value=\"secondname\">\n        <h1>{{firstname}}-{{secondname}}</h1>\n        全名:<span>{{funcname()}}</span>\n        <br>\n        计算属性：{{computedName}}\n        <br>\n        简写属性:{{shortName}}\n    </div>\n    \n    <script>\n\n        new Vue({\n            el:\"#root\",\n            data:{\n                name:\"cc\"\n            },\n            methods:{\n                func0(){\n                    alert(this.name)\n                },\n                func1(){\n                    alert(\"do not switch\");\n                },\n                func2(){\n                    alert(\"do something\");\n                }\n                \n            }\n        })\n\n        new Vue({\n            el:\"#cc2\",\n            methods:{\n                tips(event){\n                    //alert(event.key,event.keycode)\n                    console.log(event);\n                },\n                surprise(){\n                    alert(\"congratulation!\")\n                }\n            }\n        })\n\n        let vm = new Vue({\n            el:\"#cc1\",\n            data:{\n                firstname:\"c\",\n                secondname:\"c\"\n            },\n            // 使用函数的返回值作为变量，当函数设计到的变量发生更改的时候，函数就会重新编译执行\n            // 从而引起返回值的变化\n            methods:{\n                funcname(){\n                    return this.firstname+\"-\"+this.secondname;\n                }\n            },\n            computed:{\n                //在控制台输入vm.computedName可以触发set函数的调用，直接用computedName不行\n                computedName:{\n                    get(){\n                        console.log(\"someone get the name\")\n                        return this.firstname+\"-\"+this.secondname;\n                    },\n                    set(value){\n                        alert(\"someone change the name\")\n                        this.firstname = value;\n                        this.secondname = value;\n                    }\n                },\n                //计算方法的简写形式\n                shortName(){\n                    return this.firstname+\"-\"+this.secondname;\n                }\n            }\n        })\n    </script>\n</body>\n~~~\n\n', 'vue学习记录', 4, 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/19/897ee9d33eed43aea42c9819930b6f7a.jpg', '1', '0', 11, '0', 1, '2023-05-19 10:40:26', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (15, '5-18Vue学习总结', '## 5. 5/18日总结\n\n### 5.1监视属性\n\nvue的监视属性watch，可以监听vue的对象属性，当属性发生改变的时候，就会执行handler处理函数，进行相应的逻辑处理，与方法的绑定类似，监听也有两种写法，可以直接在vue对象中声明，也可在后续进行$绑定\n\n~~~html\n<body>\n    <!-- \n        监视属性watch：\n        1.当被监视的属性变化时, 回调函数自动调用, 进行相关操作\n        2.监视的两种写法：\n            (1).new Vue时传入watch配置\n            (2).通过vm.$watch监视\n-->\n    <div id=\"root\">\n        <h2>今天天气很{{info}}</h2>\n        <button @click=\"changeWeather\">切换天气</button>\n    </div>\n</body>\n\n<script type=\"text/javascript\">\n    const vm = new Vue({\n        el:\'#root\',\n        data:{\n            isHot:true,\n        },\n        computed:{\n            info(){\n                return this.isHot ? \'炎热\' : \'凉爽\'\n            }\n        },\n        methods: {\n            changeWeather(){\n                this.isHot = !this.isHot\n            }\n        },\n        /* watch:{\n				isHot:{\n					immediate:true, //初始化时让handler调用一下\n					//handler什么时候调用？当isHot发生改变时。\n					handler(newValue,oldValue){\n						console.log(\'isHot被修改了\',newValue,oldValue)\n					}\n				}\n				//简写\n				/* isHot(newValue,oldValue){\n					console.log(\'isHot被修改了\',newValue,oldValue,this)\n				} */\n			} */\n    })\n\n    vm.$watch(\'isHot\',{\n        immediate:true, //初始化时让handler调用一下\n        //handler什么时候调用？当isHot发生改变时。\n        handler(newValue,oldValue){\n            console.log(\'isHot被修改了\',newValue,oldValue)\n        }\n    })\n    //简写\n    /* vm.$watch(\'isHot\',(newValue,oldValue)=>{\n			console.log(\'isHot被修改了\',newValue,oldValue,this)\n		}) */\n</script>\n~~~\n\n### 5.2 深度监视\n\n深度监视：\n\n(1).Vue中的watch默认不监测对象内部值的改变（一层）。\n\n(2).配置deep:true可以监测对象内部值改变（多层）。\n\n备注：\n\n(1).Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！\n\n(2).使用watch时根据数据的具体结构，决定是否采用深度监视。\n\n~~~js\nnew Vue({\n    el:\'#root\',\n    data:{\n        numbers:{\n            a:1,\n            b:1,\n            c:{\n                d:{\n                    e:100\n        		}\n        	}\n        }\n    },\n    watch:{\n    //监视多级结构中某个属性的变化\n    /* \'numbers.a\':{\n            handler(){\n            console.log(\'a被改变了\')\n    	}\n    } */\n    //监视多级结构中所有属性的变化\n        numbers:{\n            deep:true,\n            handler(){\n                console.log(\'numbers改变了\')\n            }\n        }\n    }\n})\n~~~\n\n### 5.3 watch、computed和methods的比较\n\ncomputed和watch之间的区别：\n\n1.computed能完成的功能，watch都可以完成。\n\n2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。\n\n两个重要的小原则：\n\n1.所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。\n\n2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头数，这样this的指向才是vm 或 组件实例对象。这些函数不是被vue管理的，所以this不指向vue，写成箭头函数的话，会默认无this管理，这样就会跳到外层函数去寻找this对象，这样就可以找到vue作为this对象。\n\n~~~js\nwatch:{\n    firstName(val){\n        //定时任务\n        setTimeout(()=>{\n            console.log(this)\n            this.fullName = val + \'-\' + this.lastName\n        },1000);\n    },\n    lastName(val){\n        this.fullName = this.firstName + \'-\' + val\n    }\n}\n~~~\n\n而methods属性，可以将其函数的返回值作为插值语法进行绑定，注意书写插值语法的时候需要绑定的是方法，要写成方法的形式，即{{function()}}\n\n~~~html\n<body>\n    <!-- 准备好一个容器-->\n    <div id=\"root\">\n        姓：<input type=\"text\" v-model=\"firstName\"> <br/><br/>\n        名：<input type=\"text\" v-model=\"lastName\"> <br/><br/>\n        全名：<span>{{fullName()}}</span>\n    </div>\n</body>\n\n<script type=\"text/javascript\">\n    new Vue({\n        el:\'#root\',\n        data:{\n            firstName:\'张\',\n            lastName:\'三\'\n        },\n        methods: {\n            fullName(){\n                console.log(\'@---fullName\')\n                return this.firstName + \'-\' + this.lastName\n            }\n        },\n    })\n</script>\n~~~\n\n### 5.4 代码练习\n\n~~~html\n<body>\n    <div id=\"root\">\n        <h1>今天天气{{weather}}</h1>\n        <button @click=\"change\">切换天气</button>\n        <br>\n        <h1>{{number}}</h1>\n        <button @click=\"plus\">加</button>\n        <button @click=\"cc\">树</button>\n    </div>\n    \n    <script>\n        let arr = [\"晴朗\",\"阴\",\"雨\"];\n        new Vue({\n            el:\"#root\",\n            data:{\n               weather: arr[1],\n               number: 0,\n               tree:{\n                a:1,\n                b:2\n               }\n\n            },\n            methods: {\n                change(){\n                    let index = parseInt(Math.random()*3);\n                    console.log(index);\n                    this.weather = arr[index];\n                    console.log(this.weather);\n                },\n                plus(){\n                    this.number++;\n                },\n                cc(){\n                    this.tree.a++;\n                    this.tree.b++;\n                } \n            },\n            watch:{\n                //事件监听，监听vue对象number属性的变化，变化时，执行该函数\n                //事件监听简写形式\n                number(){\n                    console.log(\"number++\")\n                },\n                //事件监听，设置为初始调用\n                //事件监听，设置为深度监听\n                tree:{\n                    immediate:true,\n                    deep:true,\n                    handler(){\n                        console.log(\"someone change\")\n                    }\n                }\n                \n                \n            }\n        })\n    </script>\n</body>\n~~~\n\n', 'vue学习日记', 4, 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/19/cbbbd0fc81bf4dd098056a67764d7c5b.jpg', '1', '0', 21, '0', 1, '2023-05-19 19:38:37', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (16, '5-19Vue学习总结', '## 6. 5/19日总结\n\n### 6.1样式绑定\n\n绑定样式（使用v-bind进行绑定）：class样式\n\n写法:class=\"xxx\" xxx可以是字符串、对象、数组。\n\n字符串写法适用于：类名不确定，要动态获取。\n\n对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。\n\n数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。\n\nstyle样式\n\n写法:style=\"xxx\" xxx可以是对象，对象数组，需要注意的是属性名不可以有\"-\"，要转成驼峰\n\n~~~html\n<html>\n	<head>\n		<meta charset=\"UTF-8\" />\n		<title>绑定样式</title>\n		<style>\n			.basic{\n				width: 400px;\n				height: 100px;\n				border: 1px solid black;\n			}\n			\n			.happy{\n				border: 4px solid red;;\n				background-color: rgba(255, 255, 0, 0.644);\n				background: linear-gradient(30deg,yellow,pink,orange,yellow);\n			}\n			.sad{\n				border: 4px dashed rgb(2, 197, 2);\n				background-color: gray;\n			}\n			.normal{\n				background-color: skyblue;\n			}\n\n			.atguigu1{\n				background-color: yellowgreen;\n			}\n			.atguigu2{\n				font-size: 30px;\n				text-shadow:2px 2px 10px red;\n			}\n			.atguigu3{\n				border-radius: 20px;\n			}\n		</style>\n		<script type=\"text/javascript\" src=\"../js/vue.js\"></script>\n	</head>\n	<body>\n		<div id=\"root\">\n			<!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 -->\n			<div class=\"basic\" :class=\"mood\" @click=\"changeMood\">{{name}}</div> \n            <br/><br/>\n			<!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 -->\n			<div class=\"basic\" :class=\"classArr\">{{name}}</div> <br/><br/>\n\n			<!-- 绑定class样式--对象写法 -->\n			<div class=\"basic\" :class=\"classObj\">{{name}}</div> <br/><br/>\n\n			<!-- 绑定style样式--对象写法 -->\n			<div class=\"basic\" :style=\"styleObj\">{{name}}</div> <br/><br/>\n			<!-- 绑定style样式--数组写法 -->\n			<div class=\"basic\" :style=\"styleArr\">{{name}}</div>\n		</div>\n	</body>\n\n	<script type=\"text/javascript\">\n		Vue.config.productionTip = false\n		\n		const vm = new Vue({\n			el:\'#root\',\n			data:{\n				name:\'尚硅谷\',\n				mood:\'normal\',\n				classArr:[\'atguigu1\',\'atguigu2\',\'atguigu3\'],\n				classObj:{\n					atguigu1:false,\n					atguigu2:false,\n				},\n				styleObj:{\n					fontSize: \'40px\',\n					color:\'red\',\n				},\n				styleObj2:{\n					backgroundColor:\'orange\'\n				},\n				styleArr:[\n					{\n						fontSize: \'40px\',\n						color:\'blue\',\n					},\n					{\n						backgroundColor:\'gray\'\n					}\n				]\n			},\n			methods: {\n				changeMood(){\n					const arr = [\'happy\',\'sad\',\'normal\']\n					const index = Math.floor(Math.random()*3)\n					this.mood = arr[index]\n				}\n			},\n		})\n	</script>\n	\n</html>\n~~~\n\n### 6.2条件渲染\n\n1.v-if写法：\n\n (1).v-if=\"表达式\" \n\n(2).v-else-if=\"表达式\"\n\n(3).v-else=\"表达式\"\n\n适用于：切换频率较低的场景。\n\n特点：不展示的DOM元素直接被移除。\n\n注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”，即v-if标签之间不可以有其他标签。\n\n 2.v-show\n\n写法：v-show=\"表达式\"\n\n 适用于：切换频率较高的场景。\n\n特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉\n\n3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。\n\n~~~html\n<body>\n    <div id=\"root\">\n        <h2>当前的n值是:{{n}}</h2>\n        <button @click=\"n++\">点我n+1</button>\n        <!-- 使用v-show做条件渲染 -->\n        <!-- <h2 v-show=\"false\">欢迎来到{{name}}</h2> -->\n        <!-- <h2 v-show=\"1 === 1\">欢迎来到{{name}}</h2> -->\n\n        <!-- 使用v-if做条件渲染 -->\n        <!-- <h2 v-if=\"false\">欢迎来到{{name}}</h2> -->\n        <!-- <h2 v-if=\"1 === 1\">欢迎来到{{name}}</h2> -->\n\n        <!-- v-else和v-else-if -->\n        <!-- <div v-if=\"n === 1\">Angular</div>\n        <div v-else-if=\"n === 2\">React</div>\n        <div v-else-if=\"n === 3\">Vue</div>\n        <div v-else>哈哈</div> -->\n\n        <!-- v-if与template的配合使用 -->\n        <template v-if=\"n === 1\">\n            <h2>你好</h2>\n            <h2>尚硅谷</h2>\n            <h2>北京</h2>\n        </template>\n\n    </div>\n</body>\n\n<script type=\"text/javascript\">\n    Vue.config.productionTip = false\n\n    const vm = new Vue({\n        el:\'#root\',\n        data:{\n            name:\'尚硅谷\',\n            n:0\n        }\n    })\n</script>\n~~~\n\n### 6.3代码练习\n\n~~~html\n<style>\n    .basic{\n        width: 400px;\n        height: 100px;\n        border: 1px solid black;\n    }\n    \n    .happy{\n        border: 4px solid red;;\n        background-color: rgba(255, 255, 0, 0.644);\n        background: linear-gradient(30deg,yellow,pink,orange,yellow);\n    }\n    .sad{\n        border: 4px dashed rgb(2, 197, 2);\n        background-color: gray;\n    }\n    .normal{\n        background-color: skyblue;\n    }\n\n    .atguigu1{\n        background-color: yellowgreen;\n    }\n    .atguigu2{\n        font-size: 30px;\n        text-shadow:2px 2px 10px red;\n    }\n    .atguigu3{\n        border-radius: 20px;\n    }\n</style>\n<body>\n    <div id=\"root\">\n        <!-- 动态修改样式 -->\n        <!-- 字符串写法 -->\n        <div id=\"cc1\" class=\"basic\" :class=\"classStr\" @click=\"click1\">\n            <h1>cc1</h1>\n        </div>\n        <!-- 数组写法 -->\n        <div id=\"cc2\" class=\"basic\" :class=\"arr\" @click=\"click2\">\n            <h1>cc2</h1>\n        </div>\n        <!-- 对象写法 -->\n        <div id=\"cc3\" class=\"basic\" :class=\"classobj\" @click=\"click3\">\n            <h1>cc3</h1>\n        </div>\n    </div>\n\n    <div id=\"cc\">\n        <h1>{{number}}</h1>\n        <button @click=\"plus\">++</button>\n        <!--与java语法一样，都是条件判断-->\n        <h1 v-show=\"number === 1\">1</h1>\n        <h1 v-show=\"number === 2\">2</h1>\n        <h1 v-show=\"number === 3\">3</h1>\n\n        <!-- 与java语法一样，都是条件判断 -->\n        <h1 v-if=\"number === 1\">1</h1>\n        <h1 v-else-if=\"number === 2\">2</h1>\n        <h1 v-else=\"number === 3\">3</h1>\n\n        <!-- 模板语法，必须配合v-if使用，真正编译的时候，不会出现template标签 -->\n        <template v-if=\"number == 1\">\n            <h1>sunshine</h1>\n        </template>\n    </div>\n\n    <script>\n        let classArr = [\"happy\",\"sad\"];\n\n        let getIndex = function(){\n            console.log(\"0\");\n            return parseInt(Math.random()*2);\n        }\n\n        new Vue({\n            el:\"#root\",\n            data:{\n                classStr:\"\",\n                arr:[],\n                classobj:{\n                    happy:false,\n                    sad:false\n                }\n            },\n            methods: {\n                //对字符串进行动态赋值\n                click1(){\n                    console.log(\"1\");\n                    this.classStr = classArr[getIndex()];\n                },\n                //动态改变数组的长度和属性\n                click2(){\n                    console.log(\"2\");\n                    let index = getIndex();\n\n                    if(index === 1){\n                        //往数组压入一个元素\n                        this.arr.push(classArr[getIndex()]);\n                    }else{\n                        //从数组头去掉一个元素\n                        this.arr.shift();\n                    }\n                },\n                //动态对对象的属性取反\n                click3(){\n                    console.log(\"3\");\n                    let index = getIndex();\n\n                    if(index === 1){\n                        this.classobj.happy = !this.classobj.happy;\n                    }else{\n                        this.classobj.sad = !this.classobj.sads;\n                    }\n                }\n            },\n        })\n        new Vue({\n            el:\"#cc\",\n            data:{\n                number:0\n            },\n            methods:{\n                plus(){\n                    this.number++;\n                }\n            }\n        })\n    </script>\n</body>\n~~~\n\n', 'Vue学习总结', 4, 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/20/d9d862b54ef845428897daf2c0e58247.jpg', '1', '0', 14, '0', 1, '2023-05-20 11:53:13', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (17, '5-23Vue学习总结', '## 7. 5/23总结\n\n### 7.1 v-for遍历\n\n1.用于展示列表数据\n\n2.语法：v-for=\"(item, index) in xxx\" :key=\"yyy\"\n\n3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）\n\n4.key最好使用数据本身的属性，不适用系统自带的index，避免dom混乱\n\n~~~html\n<body>\n    <div id=\"root\">\n        <!-- 遍历数组 -->\n        <h2>人员列表（遍历数组）</h2>\n        <ul>\n            <li v-for=\"(p,index) of persons\" :key=\"index\">\n                {{p.name}}-{{p.age}}\n            </li>\n        </ul>\n\n        <!-- 遍历对象 -->\n        <h2>汽车信息（遍历对象）</h2>\n        <ul>\n            <li v-for=\"(value,k) of car\" :key=\"k\">\n                {{k}}-{{value}}\n            </li>\n        </ul>\n\n        <!-- 遍历字符串 -->\n        <h2>测试遍历字符串（用得少）</h2>\n        <ul>\n            <li v-for=\"(char,index) of str\" :key=\"index\">\n                {{char}}-{{index}}\n            </li>\n        </ul>\n\n        <!-- 遍历指定次数 -->\n        <h2>测试遍历指定次数（用得少）</h2>\n        <ul>\n            <li v-for=\"(number,index) of 5\" :key=\"index\">\n                {{index}}-{{number}}\n            </li>\n        </ul>\n    </div>\n\n    <script type=\"text/javascript\">\n        Vue.config.productionTip = false\n\n        new Vue({\n            el:\'#root\',\n            data:{\n                persons:[\n                    {id:\'001\',name:\'张三\',age:18},\n                    {id:\'002\',name:\'李四\',age:19},\n                    {id:\'003\',name:\'王五\',age:20}\n                ],\n                car:{\n                    name:\'奥迪A8\',\n                    price:\'70万\',\n                    color:\'黑色\'\n                },\n                str:\'hello\'\n            }\n        })\n    </script>\n</body>	\n~~~\n\n### 7.2 遍历的key问题\n\n1.虚拟DOM中key的作用：\n\n key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：\n\n2.对比规则：\n\n (1).旧虚拟DOM中找到了与新虚拟DOM相同的key：\n\n​      ①.若虚拟DOM中内容没变, 直接使用之前的真实DOM！\n\n​      ②.若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。\n\n (2).旧虚拟DOM中未找到与新虚拟DOM相同的key创建新的真实DOM，随后渲染到到页面。\n\n3.用index作为key可能会引发的问题：\n\n   1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 ==> 界面效果				没问题, 但效率低。\n   2.  如果结构中还包含输入类的DOM：会产生错误DOM更新 ==> 界面有问题。\n\n 4. 开发中如何选择key?:\n\n​      1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。\n\n​      2.如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是		没有问题的。\n\n### 7.3 列表过滤\n\n使用数组的filter方法可行过滤，并使用字符串的indexOf方法进行判定字符串是否含有该字符，在前端空字符的索引位置为0，而在后端空字符的索引为数组length-1\n\n~~~html\n<div id=\"root\">\n    <h2>人员列表</h2>\n    <input type=\"text\" placeholder=\"请输入名字\" v-model=\"keyWord\">\n    <ul>\n        <li v-for=\"(p,index) of filPerons\" :key=\"index\">\n            {{p.name}}-{{p.age}}-{{p.sex}}\n        </li>\n    </ul>\n</div>\n\n<script type=\"text/javascript\">\n    Vue.config.productionTip = false\n\n    //用watch实现\n    //#region \n    /* new Vue({\n				el:\'#root\',\n				data:{\n					keyWord:\'\',\n					persons:[\n						{id:\'001\',name:\'马冬梅\',age:19,sex:\'女\'},\n						{id:\'002\',name:\'周冬雨\',age:20,sex:\'女\'},\n						{id:\'003\',name:\'周杰伦\',age:21,sex:\'男\'},\n						{id:\'004\',name:\'温兆伦\',age:22,sex:\'男\'}\n					],\n					filPerons:[]\n				},\n				watch:{\n					keyWord:{\n						immediate:true,\n						handler(val){\n							this.filPerons = this.persons.filter((p)=>{\n								return p.name.indexOf(val) !== -1\n							})\n						}\n					}\n				}\n			}) */\n    //#endregion\n\n    //用computed实现\n    new Vue({\n        el:\'#root\',\n        data:{\n            keyWord:\'\',\n            persons:[\n                {id:\'001\',name:\'马冬梅\',age:19,sex:\'女\'},\n                {id:\'002\',name:\'周冬雨\',age:20,sex:\'女\'},\n                {id:\'003\',name:\'周杰伦\',age:21,sex:\'男\'},\n                {id:\'004\',name:\'温兆伦\',age:22,sex:\'男\'}\n            ]\n        },\n        computed:{\n            filPerons(){\n                return this.persons.filter((p)=>{\n                    return p.name.indexOf(this.keyWord) !== -1\n                })\n            }\n        }\n    }) \n</script>\n~~~\n\n### 7.4列表排序\n\n~~~html\n<div id=\"root\">\n    <h2>人员列表</h2>\n    <input type=\"text\" placeholder=\"请输入名字\" v-model=\"keyWord\">\n    <button @click=\"sortType = 2\">年龄升序</button>\n    <button @click=\"sortType = 1\">年龄降序</button>\n    <button @click=\"sortType = 0\">原顺序</button>\n    <ul>\n        <li v-for=\"(p,index) of filPerons\" :key=\"p.id\">\n            {{p.name}}-{{p.age}}-{{p.sex}}\n            <input type=\"text\">\n        </li>\n    </ul>\n</div>\n\n<script type=\"text/javascript\">\n    new Vue({\n        el:\'#root\',\n        data:{\n            keyWord:\'\',\n            sortType:0, //0原顺序 1降序 2升序\n            persons:[\n                {id:\'001\',name:\'马冬梅\',age:30,sex:\'女\'},\n                {id:\'002\',name:\'周冬雨\',age:31,sex:\'女\'},\n                {id:\'003\',name:\'周杰伦\',age:18,sex:\'男\'},\n                {id:\'004\',name:\'温兆伦\',age:19,sex:\'男\'}\n            ]\n        },\n        computed:{\n            filPerons(){\n                const arr = this.persons.filter((p)=>{\n                    return p.name.indexOf(this.keyWord) !== -1\n                })\n                //判断一下是否需要排序\n                if(this.sortType){\n                    arr.sort((p1,p2)=>{\n                        return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age\n                    })\n                }\n                return arr\n            }\n        }\n    }) \n</script>\n~~~\n\n### 7.5数组更新\n\n注意,更新数组的不可以直接更新数组的整个下标元素，这样vue是监测不到的，模板不会重新渲染，需要使用数组的更新方法（触及数组元素变化的方法）或者改变数组中元素的值（数组中对象的属性值），还可以使用vue的set方法进行数组元素的修改，修改整个下标元素，也可以对普通元素进行修改，有两种方式：Vue.set(对象，key，value)或者vm.$set(对象，key，value)\n\n~~~html\n<script type=\"text/javascript\">\n    const vm = new Vue({\n        el:\'#root\',\n        data:{\n            persons:[\n                {id:\'001\',name:\'马冬梅\',age:30,sex:\'女\'},\n                {id:\'002\',name:\'周冬雨\',age:31,sex:\'女\'},\n                {id:\'003\',name:\'周杰伦\',age:18,sex:\'男\'},\n                {id:\'004\',name:\'温兆伦\',age:19,sex:\'男\'}\n            ]\n        },\n        methods: {\n            updateMei(){\n                // this.persons[0].name = \'马老师\' //奏效\n                // this.persons[0].age = 50 //奏效\n                // this.persons[0].sex = \'男\' //奏效\n                // this.persons[0] = {id:\'001\',name:\'马老师\',age:50,sex:\'男\'} //不奏效\n                this.persons.splice(0,1,{id:\'001\',name:\'马老师\',age:50,sex:\'男\'})\n            }\n        }\n    }) \n</script>\n~~~\n\n### 7.6 总结\n\nVue监视数据的原理：\n\n1.vue会监视data中所有层次的数据。\n\n2.如何监测对象中的数据？\n\n​                通过setter实现监视，且要在new Vue时就传入要监测的数据。\n\n​                  (1).对象中后追加的属性，Vue默认不做响应式处理\n\n​                  (2).如需给后添加的属性做响应式，请使用如下API：\n\n​                          Vue.set(target，propertyName/index，value) 或 \n\n​                          vm.$set(target，propertyName/index，value)\n\n3.如何监测数组中的数据？\n\n​                  通过包裹数组更新元素的方法实现，本质就是做了两件事：\n\n​                    (1).调用原生对应的方法对数组进行更新。\n\n​                    (2).重新解析模板，进而更新页面。\n\n4.在Vue修改数组中的某个元素一定要用如下方法：\n\n​              1.使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse()\n\n​              2.Vue.set() 或 vm.$set()\n\n特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！\n\n### 7.7代码练习\n\n~~~html\n<body>\n    <div id=\"cc\">\n        遍历数组\n        <ol>\n            <li v-for=\"(one,index) in arr\">{{one.name}}-{{one.age}}</li>\n        </ol>\n        遍历对象\n        <ol>\n            <li v-for=\"(value,key) in ccg\">{{key}}-{{value}}</li>\n        </ol>\n        遍历字符串\n        <ol>\n            <li v-for=\"(char,index) in str\">{{index}}-{{char}}</li>\n        </ol>\n        <hr>\n        遍历数组\n        <input type=\"text\" v-model:keyword=\"keyword\" placeholder=\"keyword\">\n        <button @click=\"sort = 1\">升序</button>\n        <button @click=\"sort = 2\">倒叙</button>\n        <button @click=\"sort = 0\">正常</button>\n        <button @click=\"inputOne\">插入一个对象</button>\n        <button @click=\"deleteOne\">删除一个对象</button>\n        <button @click=\"changeOne\">修改一个对象</button>\n        <ol>\n            <li v-for=\"(person,index) in personsComputed\" ::key=\"person.id\">		\n                {{person.name}}-{{person.age}}\n            </li>\n        </ol>\n    </div>\n    <script>\n        new Vue({\n            el:\"#cc\",\n            data:{\n                arr:[{name:\"cc1\",age:24},{name:\"cc2\",age:24}],\n                ccg:{\n                    name:\"ccg\",\n                    age:24\n                },\n                str:\"ccg\",\n                persons:[\n                    {id:\'001\',name:\'张三\',age:28},\n                    {id:\'002\',name:\'李四\',age:19},\n                    {id:\'003\',name:\'王五\',age:10},\n                    {id:\'004\',name:\"六子\",age:21}\n				],\n                keyword:\"\",\n                sort:0\n            },\n            computed:{\n                personsComputed:{\n                    get(){\n                        let arr =  this.persons.filter((p)=>{\n                            return p.name.indexOf(this.keyword) !== -1;\n                        });\n\n                        if(this.sort !== 0){\n                            arr.sort((p1,p2)=>{\n                                return this.sort === 1 ? p1.age-p2.age : p2.age-p1.age;\n                            })\n                        }\n                        return arr;\n                    }\n                }\n            },\n            methods: {\n                inputOne(){\n                    this.persons.unshift({id:\"005\",name:\"老七\",age:33});\n                },\n                deleteOne(){\n                    this.persons.shift();\n                },\n                changeOne(){\n                    Vue.set(this.ccg,\"sex\",1);\n                    this.$set(this.ccg,\"weight\",110);\n                    this.$set(this.persons,0,{id:\'001\',name:\'张三疯\',age:28})\n                }\n            },\n        })\n    </script>\n</body>\n~~~\n\n', 'Vue学习总结', 4, 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/24/0ff4b778d4054436b17ee792122ef1e1.jpg', '1', '0', 4, '0', 1, '2023-05-24 20:37:51', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (18, '5-24Vue学习日记', '## 8. 5/24日总结\n\n### 8.1数据绑定\n\n收集表单数据：\n\n若：<input type=\"text\"/>，则v-model收集的是value值，用户输入的就是value值。\n\n若：<input type=\"radio\"/>，则v-model收集的是value值，且要给标签配置value值。\n\n若：<input type=\"checkbox\"/>\n\n1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值）\n\n2.配置input的value属性:\n\n​     (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值）\n\n​      (2)v-model的初始值是数组，那么收集的的就是value组成的数组\n\n备注：v-model的三个修饰符：\n\nlazy：失去焦点再收集数据\n\nnumber：输入字符串转为有效的数字\n\ntrim：输入首尾空格过滤\n\n3.input标签的类型也可以是number，限制用户的输入，只有输入数字才会被识别\n\n~~~html\n<div id=\"root\">\n    <form @submit.prevent=\"demo\">\n        账号：<input type=\"text\" v-model.trim=\"userInfo.account\"> <br/><br/>\n        密码：<input type=\"password\" v-model=\"userInfo.password\"> <br/><br/>\n        年龄：<input type=\"number\" v-model.number=\"userInfo.age\"> <br/><br/>\n        性别：\n        男<input type=\"radio\" name=\"sex\" v-model=\"userInfo.sex\" value=\"male\">\n        女<input type=\"radio\" name=\"sex\" v-model=\"userInfo.sex\" value=\"female\"> <br/>\n        爱好：\n        学习<input type=\"checkbox\" v-model=\"userInfo.hobby\" value=\"study\">\n        打游戏<input type=\"checkbox\" v-model=\"userInfo.hobby\" value=\"game\">\n        吃饭<input type=\"checkbox\" v-model=\"userInfo.hobby\" value=\"eat\">\n        <br/><br/>\n        所属校区\n        <select v-model=\"userInfo.city\">\n            <option value=\"\">请选择校区</option>\n            <option value=\"beijing\">北京</option>\n            <option value=\"shanghai\">上海</option>\n            <option value=\"shenzhen\">深圳</option>\n            <option value=\"wuhan\">武汉</option>\n        </select>\n        <br/><br/>\n        其他信息：\n        <textarea v-model.lazy=\"userInfo.other\"></textarea> <br/><br/>\n        <input type=\"checkbox\" v-model=\"userInfo.agree\">阅读并接受\n        <a href=\"http://www.atguigu.com\">《用户协议》</a>\n        <button>提交</button>\n    </form>\n</div>\n\n<script type=\"text/javascript\">\n    new Vue({\n        el:\'#root\',\n        data:{\n            userInfo:{\n                account:\'\',\n                password:\'\',\n                age:18,\n                sex:\'female\',\n                hobby:[],\n                city:\'beijing\',\n                other:\'\',\n                agree:\'\'\n            }\n        },\n        methods: {\n            demo(){\n                console.log(JSON.stringify(this.userInfo))\n            }\n        }\n    })\n</script>\n~~~\n\n### 8.2过滤器\n\n过滤器：\n\n定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。\n\n语法：\n\n1.注册过滤器：Vue.filter(name,callback) （全局过滤器）或 new Vue{filters:{}}（局部过滤器）\n\n 2.使用过滤器：{{ xxx | 过滤器名}}  或  v-bind:属性 = \"xxx | 过滤器名\"，与linux的管道符类似可以套用\n\n备注：\n\n1.过滤器也可以接收额外参数、多个过滤器也可以串联\n\n2.并没有改变原本的数据, 是产生新的对应的数据\n\n3.在vue3中，过滤器已经被废弃，官方也推荐使用计算方法来实现\n\n~~~html\n<div id=\"root\">\n    <h2>显示格式化后的时间</h2>\n    <!-- 计算属性实现 -->\n    <h3>现在是：{{fmtTime}}</h3>\n    <!-- methods实现 -->\n    <h3>现在是：{{getFmtTime()}}</h3>\n    <!-- 过滤器实现 -->\n    <h3>现在是：{{time | timeFormater}}</h3>\n    <!-- 过滤器实现（传参） -->\n    <h3>现在是：{{time | timeFormater(\'YYYY_MM_DD\') | mySlice}}</h3>\n    <h3 :x=\"msg | mySlice\">尚硅谷</h3>\n</div>\n\n<div id=\"root2\">\n    <h2>{{msg | mySlice}}</h2>\n</div>\n\n<script type=\"text/javascript\">\n    //全局过滤器\n    Vue.filter(\'mySlice\',function(value){\n        return value.slice(0,4)\n    })\n\n    new Vue({\n        el:\'#root\',\n        data:{\n            time:1621561377603, //时间戳\n            msg:\'你好，尚硅谷\'\n        },\n        computed: {\n            fmtTime(){\n                return dayjs(this.time).format(\'YYYY年MM月DD日 HH:mm:ss\')\n            }\n        },\n        methods: {\n            getFmtTime(){\n                return dayjs(this.time).format(\'YYYY年MM月DD日 HH:mm:ss\')\n            }\n        },\n        //局部过滤器\n        filters:{\n            timeFormater(value,str=\'YYYY年MM月DD日 HH:mm:ss\'){\n                // console.log(\'@\',value)\n                return dayjs(value).format(str)\n            }\n        }\n    })\n\n    new Vue({\n        el:\'#root2\',\n        data:{\n            msg:\'hello,atguigu!\'\n        }\n    })\n</script>\n~~~\n\n### 8.3 代码练习\n\n~~~html\n<div id=\"root\">\n    <h1>当前时间：{{userinfo.nowTime | formatTime}}</h1>\n    <h1>{{computedTime}}</h1>\n    账号：<input type=\"text\" v-model.trim=\"userinfo.username\" > <br><br>\n    密码：<input type=\"password\" v-model.trim=\"userinfo.password\" > <br><br>\n    年龄：<input type=\"number\" v-model.number=\"userinfo.age\" > <br><br>\n    性别：  男 <input type=\"radio\" name=\"sex\" v-model=\"userinfo.sex\" value=\"man\">\n    女 <input type=\"radio\" name=\"sex\" v-model=\"userinfo.sex\" value=\"women\"><br><br>\n    爱好：  学习<input type=\"checkbox\" name=\"hobby\" v-model=\"userinfo.hobby\" value=\"study\">\n    打游戏<input type=\"checkbox\" name=\"hobby\" v-model=\"userinfo.hobby\" value=\"game\">\n    吃饭<input type=\"checkbox\" name=\"hobby\" v-model=\"userinfo.hobby\" value=\"eat\">\n    <br><br>\n    所属校区<select v-model=\"userinfo.city\">\n    <option value=\"\">请选择校区</option>\n    <option value=\"wc\">吴川</option>\n    <option value=\"zj\">湛江</option>\n    </select>\n    <br><br>\n    其他信息：<textarea></textarea>\n    <br><br>\n    <input type=\"checkbox\"> 阅读并接受<a href=\"http://8.142.134.180:5213\">《用户协议》</a>\n    <button @click=\"submit\">提交</button>\n\n</div>\n<script>\n    new Vue({\n        el:\"#root\",\n        data:{\n            userinfo:{\n                username:\"\",\n                password:\"\",\n                age:\"\",\n                sex:\"\",\n                hobby:[],\n                city:\"\",\n                nowTime:new Date()\n            }\n        },\n        methods: {\n            submit(){\n                console.log(JSON.stringify(this.userinfo))\n            }\n        },\n        filters:{\n            formatTime(nowTime){\n                return dayjs(nowTime).format(\"YYYY-MM-DD HH:mm:ss\");\n            }\n        },\n        computed:{\n            computedTime(){\n                return dayjs(this.userinfo.nowTime).format(\"YYYY-MM-DD HH:mm:ss\");\n            }\n        }\n    })\n</script>\n~~~\n\n', 'Vue日记', 4, 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/26/931fd1a565d94f72b1f59e45970bb5d3.jpg', '1', '0', 8, '0', 1, '2023-05-25 21:39:45', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (19, '5-25Vue学习日记', '## 9. 5/25日总结\n\n### 9.1内置指令\n\nv-bind  : 单向绑定解析表达式, 可简写为 :xxx\n\nv-model : 双向数据绑定\n\nv-for  : 遍历数组/对象/字符串\n\nv-on   : 绑定事件监听, 可简写为@\n\nv-if     : 条件渲染（动态控制节点是否存存在）\n\nv-else  : 条件渲染（动态控制节点是否存存在）\n\nv-show  : 条件渲染 (动态控制节点是否展示)\n\nv-text指令：\n\n​            1.作用：向其所在的节点中渲染文本内容。\n\n​            2.与插值语法的区别：v-text会替换掉节点中的内容，{{xx}}则不会。\n\nv-html指令：\n\n​            1.作用：向指定节点中渲染包含html结构的内容。\n\n​            2.与插值语法的区别：\n\n​                  (1).v-html会替换掉节点中所有的内容，{{xx}}则不会。\n\n​                  (2).v-html可以识别html结构。\n\n​            3.严重注意：v-html有安全性问题！！！！\n\n​                  (1).在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。\n\n​                  (2).一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！\n\nv-cloak指令（没有值）：\n\n​            1.本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。\n\n​            2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的问题。\n\nv-once指令：\n\n​            1.v-once所在节点在初次动态渲染后，就视为静态内容了。\n\n​            2.以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。\n\nv-pre指令：\n\n​          1.跳过其所在节点的编译过程。\n\n​          2.可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。\n\n### 9.2自定义指令\n\n  一、定义语法：\n\n​                  (1).局部指令：\n\n​                        new Vue({                              new Vue({\n\n​                          directives:{指令名:配置对象}  或      directives{指令名:回调函数}\n\n​                        })                                    })\n\n​                  (2).全局指令：\n\n​                          Vue.directive(指令名,配置对象) 或  Vue.directive(指令名,回调函数)\n\n二、配置对象中常用的3个回调：\n\n​                  (1).bind：指令与元素成功绑定时调用。\n\n​                  (2).inserted：指令所在元素被插入页面时调用。\n\n​                  (3).update：指令所在模板结构被重新解析时调用。\n\n三、备注：\n\n​                  1.指令定义时不加v-，但使用时要加v-；\n\n​                  2.指令名如果是多个单词，要使用kebab-case命名方式并使用引号括起来，不要用camelCase命名。\n\n​				  3.直接全小写，不要写大写就完事\n\n~~~html\n<body>\n    <div id=\"root\">\n        <h2>{{name}}</h2>\n        <h2>当前的n值是：<span v-text=\"n\"></span> </h2>\n        <!-- <h2>放大10倍后的n值是：<span v-big-number=\"n\"></span> </h2> -->\n        <h2>放大10倍后的n值是：<span v-big=\"n\"></span> </h2>\n        <button @click=\"n++\">点我n+1</button>\n        <hr/>\n        <input type=\"text\" v-fbind:value=\"n\">\n    </div>\n</body>\n\n<script type=\"text/javascript\">\n    Vue.config.productionTip = false\n\n    //定义全局指令\n    /* Vue.directive(\'fbind\',{\n			//指令与元素成功绑定时（一上来）\n			bind(element,binding){\n				element.value = binding.value\n			},\n			//指令所在元素被插入页面时\n			inserted(element,binding){\n				element.focus()\n			},\n			//指令所在的模板被重新解析时\n			update(element,binding){\n				element.value = binding.value\n			}\n		}) */\n\n    new Vue({\n        el:\'#root\',\n        data:{\n            name:\'尚硅谷\',\n            n:1\n        },\n        directives:{\n            //big函数何时会被调用？1.指令与元素成功绑定时（一上来）。2.指令所在的模板被重新解析时。\n            /* \'big-number\'(element,binding){\n					// console.log(\'big\')\n					element.innerText = binding.value * 10\n				}, */\n            big(element,binding){\n                console.log(\'big\',this) //注意此处的this是window\n                // console.log(\'big\')\n                element.innerText = binding.value * 10\n            },\n            fbind:{\n                //指令与元素成功绑定时（一上来）\n                bind(element,binding){\n                    element.value = binding.value\n                },\n                //指令所在元素被插入页面时\n                inserted(element,binding){\n                    element.focus()\n                },\n                //指令所在的模板被重新解析时\n                update(element,binding){\n                    element.value = binding.value\n                }\n            }\n        }\n    })\n</script>\n~~~\n\n### 9.3代码练习\n\n~~~html\n<body>\n    <div id=\"root\">\n        <input type=\"text\" v-model=\"name\">\n        <h1 v-cloak>{{name}}</h1>\n        <h1 v-text=\"name\"></h1>\n        <h1 v-html=\"name\"></h1>\n        <button @click=\"n++\">点击加1</button>\n        <h1 v-once>只加一次{{n}}</h1>\n        <h1>{{n}}</h1>\n        <h1 v-pre>直接摆烂{{n}}</h1>\n        <span>超级加倍+<h1 v-big=\"n\"></h1></span>\n        <br>\n        <input type=\"text\" v-getfoucs:value=\"n\">\n    </div>\n    <script>\n        Vue.directive(\'big\',function(element,binding){\n            element.innerText = binding.value * 10;\n        });\n        new Vue({\n            el:\"#root\",\n            data:{\n                name:\"cc\",\n                n:1\n            },\n            directives:{\n                //这里要写标签的名字，element:外层标签对象，binding：绑定的参数\n                //注意一般使用它的value值，即后面的参数n，在这个函数里面this指的是window对象\n                // big(element,binding){\n                //     element.innerText = binding.value * 10;\n                // },\n                getfoucs:{\n                    bind(element,binding){\n                        element.value = binding.value;\n                    },\n                    inserted(element,binding){\n                        element.focus();\n                    },\n                    update(element,binding){\n                        element.value = binding.value;\n                        element.focus();\n                    }\n                }        \n            }   \n        })\n    </script>\n</body>\n~~~\n\n', 'Vue学习日记', 4, 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/27/479a4d5ab53a4cb8930b21d264cd7124.png', '1', '0', 1, '0', 1, '2023-05-27 18:16:15', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (20, 'SpringSecurity总结', '# 								Spring Security\n\n## 1. Spring Security简介\n\nSpring Security是spring项目组提供的安全服务框架，核心功能包括认证和授权。\n\n## 2.安全认证\n\n### 2.1内存认证\n\nInMemoryUserDetailsManager内存认证\n\n```java\n// Security配置类\n@Configuration\npublic class SecurityConfig {\n    // 定义认证逻辑\n    @Bean\n    public UserDetailsService userDetailsService(){\n        // 1.使用内存数据进行认证\n        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();\n        // 2.创建两个用户\n        UserDetails user1 = User.withUsername(\"baizhan\").password(\"123\")\n								.authorities(\"admin\").build();\n        UserDetails user2 = User.withUsername(\"sxt\").password(\"456\")\n            					.authorities(\"admin\").build();\n        // 3.将这两个用户添加到内存中\n        manager.createUser(user1);\n        manager.createUser(user2);\n        return manager;\n   }\n\n    //密码编码器，不解析密码\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return NoOpPasswordEncoder.getInstance();\n   	}\n}\n```\n\n### 2.2自定义认证逻辑\n\n​	在实际项目中，认证逻辑是需要自定义控制的。将 UserDetailsService 接口的实现类放入Spring容器即可自定义认证逻辑。InMemoryUserDetailsManager 就是 UserDetailsService 接口的一个实现类，它将登录页传来的用户名密码和内存中用户名密码做匹配认证。当然我们也可以自定义 UserDetailsService 接口的实现类。UserDetailsService 的实现类必须重写 loadUserByUsername 方法，该方法定义了具体的认证逻辑，参数 username 是前端传来的用户名，我们需要根据传来的用户名查询到该用户（一般是从数据库查询），并将查询到的用户封装成一个UserDetails对象，该对象是Spring Security提供的用户对象，包含用户名、密码、权限。Spring Security会根据UserDetails对象中的密码和客户端提供密码进行比较。相同则认证通过，不相同则认证失败。\n\n\n```java\n@Service\npublic class MyUserDetailsService implements UserDetailsService {\n    @Autowired\n    private UsersMapper usersMapper;\n    // 自定义认证逻辑\n    @Override\n    public UserDetails loadUserByUsername(String username) throws 																					UsernameNotFoundException {\n        // 1.构造查询条件\n        QueryWrapper<Users> wrapper = new QueryWrapper<Users>().eq(\"username\",username);\n        // 2.查询用户\n        Users users = usersMapper.selectOne(wrapper);\n        // 3.封装为UserDetails对象\n        UserDetails userDetails = User.withUsername(users.getUsername())\n                                       .password(users.getPassword())\n                                       .authorities(\"admin\")\n                                       .build();\n        // 4.返回封装好的UserDetails对象\n        return userDetails;\n   }\n}\n```\n\n实现UserDetailsService接口，重写loadUserByUsername方法。该方法的目的，是通过username，从数据库查询相应的用户信息，封装成UserDetails对象，返回给SpringSecurity。然后SpringSecurity将该对象与用户输入的密码进行比较。\n\n### 2.3密码管理器\n\n​	在实际开发中，为了数据安全性，在数据库中存放密码时不会存放原密码，而是会存放加密后的密码。而用户传入的参数是明文密码。此时必须使用密码解析器才能将加密密码与明文密码做比对。Spring Security中的密码解析器是 PasswordEncoder 。Spring Security要求容器中必须有 PasswordEncoder 实例，之前使用的NoOpPasswordEncoder 是 PasswordEncoder 的实现类，意思是不解析密码，使用明文密码。Spring Security官方推荐的密码解析器是 BCryptPasswordEncoder 。\n\n```java\n//密码编码器\n @Bean\n public PasswordEncoder passwordEncoder() {\n    return new BCryptPasswordEncoder();\n }\n```\n\n```java\n@SpringBootTest\n public class PasswordEncoderTest {\n    @Test\n    public void testBCryptPasswordEncoder(){\n        //创建解析器\n        PasswordEncoder encoder = new BCryptPasswordEncoder();\n        //密码加密\n\n        String password = encoder.encode(\"baizhan\");\n        System.out.println(\"加密后:\"+password);\n\n        //密码校验\n        /**\n         * 参数1:明文密码\n         * 参数2:加密密码\n         * 返回值：是否校验成功\n         */\n        boolean result = encoder.matches(\"baizhan\",                                  							\"$2a$10$/MImcrpDO21HAP2amayhme8j2SM0YM50/WO8YBH.NC1hEGGSU9ByO\");\n        System.out.println(result);\n   }\n}\n```\n\n## 3.配置类\n\n```java\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter{\n    //Spring Security配置\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        // 自定义表单登录\n        http.formLogin()\n           .loginPage(\"/login.html\") //自定义登录页面\n           .usernameParameter(\"username\")// 表单中的用户名项\n           .passwordParameter(\"password\")// 表单中的密码项\n           .loginProcessingUrl(\"/login\")// 登录路径，表单向该路径提交，提交后自动执行													UserDetailsService的方法\n           .successForwardUrl(\"/main\")//登录成功后跳转的路径\n           .failureForwardUrl(\"/fail\");//登录失败后跳转的路径\n        \n        // 需要认证的资源\n        http.authorizeRequests()           \n        	.antMatchers(\"/login.html\").permitAll() //登录页不需要认证\n            .anyRequest().authenticated();//其余所有请求都需要认证\n\n        //关闭csrf防护\n        http.csrf().disable();\n   }\n}\n```\n\n## 4.会话管理\n\nSpring Security将用户信息保存在会话中，并提供会话管理，我们可以从 SecurityContext 对象中获取用户信息，\n\nSecurityContext 对象与当前线程进行绑定。\n\n```java\n@RestController\npublic class MyController {\n    // 获取当前登录用户名\n    @RequestMapping(\"/users/username\")\n    public String getUsername(){\n        // 1.获取会话对象\n        SecurityContext context = SecurityContextHolder.getContext();\n        // 2.获取认证对象\n        Authentication authentication = context.getAuthentication();\n        // 3.获取登录用户信息\n        UserDetails userDetails = (UserDetails) authentication.getPrincipal();\n        return userDetails.getUsername();\n   }\n}\n```\n\n## 5.自定义管理器\n\n### 5.1成功登录处理器AuthenticationSuccessHandler\n\n```java\npublic class MyLoginSuccessHandler implements AuthenticationSuccessHandler {\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, \n                                        HttpServletResponse response,\n										Authentication authentication) throws\n										IOException, ServletException {\n        // 拿到登录用户的信息\n        UserDetails userDetails = (UserDetails)authentication.getPrincipal();\n        System.out.println(\"用户名:\"+userDetails.getUsername());\n        System.out.println(\"一些操作...\");\n        // 重定向到主页\n        response.sendRedirect(\"/main\");\n   }\n}\n```\n\n配置登录成功处理器\n\n.successForwardUrl(\"/main\") //登录成功后跳转的路径\n\n.successHandler(new MyLoginSuccessHandler()) //登录成功处理器\n\n### 5.2登录失败处理器AuthenticationFailureHandler\n\n```java\npublic class MyLoginFailureHandler implements AuthenticationFailureHandler {\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request, \n                                        HttpServletResponse response,\n										AuthenticationException exception) \n        								throws IOException, ServletException {\n        System.out.println(\"记录失败日志...\");\n        response.sendRedirect(\"/fail\");\n   }\n}\n```\n\n配置登录失败处理器\n\n.failureForwardUrl(\"/fail\") //登录失败后跳转的路径\n\n.failureHandler(new MyLoginFailureHandler()); //登录失败处理器\n\n## 6.退出登录\n\n在系统中一般都有退出登录的操作。退出登录后，Spring Security进行了以下操作：\n\n1.清除认证状态\n\n2.销毁HttpSession对象\n\n3.跳转到登录页面/或进行一些日志操作\n\n```java\n// 退出登录配置\nhttp.logout()\n   .logoutUrl(\"/logout\") // 退出登录路径\n   .logoutSuccessUrl(\"/login.html\") // 退出登录后跳转的路径\n   .clearAuthentication(true) //清除认证状态，默认为true\n   .invalidateHttpSession(true); // 销毁HttpSession对象，默认为true\n```\n\n配置退出登录成功处理器\n\n```java\npublic class MyLogoutSuccessHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccess(HttpServletRequest request, \n                                HttpServletResponse response,\n								Authentication authentication) \n        						throws IOException, ServletException {\n        System.out.println(\"清除一些数据...\");\n		response.sendRedirect(\"/login.html\");\n   }\n}\n```\n\n.logoutSuccessUrl(\"/login.html\") // 退出登录后跳转的路径\n\n.logoutSuccessHandler(new MyLogoutSuccessHandler()); //自定义退出成功处理器\n\n## 7.记住我\n\n​	Spring Security中Remember Me为“记住我”功能，即下次访问系统时无需重新登录。当使用“记住我”功能登录后，Spring Security会生成一个令牌，令牌一方面保存到数据库中，另一方面生成一个叫remember-me 的Cookie保存到客户端。之后客户端访问项目时自动携带令牌，不登录即可完成认证。\n\n\n```java\n@Configuration\npublic class RememberMeConfig {\n    @Autowired\n    private DataSource dataSource;\n    //令牌Repository\n    @Bean\n    public PersistentTokenRepository getPersistentTokenRepository() {\n        // 为Spring Security自带的令牌控制器设置数据源\n        JdbcTokenRepositoryImpl jdbcTokenRepositoryImpl = new JdbcTokenRepositoryImpl();\n      	jdbcTokenRepositoryImpl.setDataSource(dataSource);\n        //自动建表，第一次启动时需要，第二次启动时注释掉      \n		jdbcTokenRepositoryImpl.setCreateTableOnStartup(true);\n        return jdbcTokenRepositoryImpl;\n   }\n}\n```\n\n配置记住登录\n\n```java\n// 记住我配置\nhttp.rememberMe()    \n	.userDetailsService(userDetailsService)//登录逻辑交给哪个对象\n    .tokenRepository(repository) //持久层对象\n    .tokenValiditySeconds(30); //保存时间，单位：秒\n```\n\n## 8.RBAC\n\n**Resource-Based Access Control**\n\n基于资源的访问控制，即按资源（或权限）进行授权。比如在企业管理系统中，用户必须 具有查询报表权限才可以查询企业运营报表。即具体该资源的权限才能进行访问。\n\n### 8.1封装用户权限\n\n```java\n// 自定义认证逻辑\n@Override\npublic UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n    // 1.构造查询条件\n    QueryWrapper<Users> wrapper = new QueryWrapper<Users>().eq(\"username\",username);\n    // 2.查询用户\n    Users users = userMapper.selectOne(wrapper);\n    if (users == null){\n        return null;\n   	}\n    // 3.查询用户权限\n    List<Permission> permissions = userMapper.findPermissionByUsername(username);\n    // 4.将自定义权限集合转为Security的权限类型集合\n    List<GrantedAuthority> grantedAuthorities = new ArrayList<>();\n    for (Permission permission :permissions) {\n        grantedAuthorities.add(new SimpleGrantedAuthority(permission.getUrl()));\n    }\n    // 5.封装为UserDetails对象\n    UserDetails userDetails = User.withUsername(users.getUsername())\n                                   .password(users.getPassword())\n                                   .authorities(grantedAuthorities)\n                                   .build();\n    // 6.返回封装好的UserDetails对象\n    return userDetails;\n}\n```\n\n### 8.2基于配置的访问限制\n\n```java\n// 权限拦截配置\nhttp.authorizeRequests()       \n	.antMatchers(\"/login.html\").permitAll() //表示任何权限都可以访问\n	.antMatchers(\"/reportform/find\").hasAnyAuthority(\"/reportform/find\") // 给资源配置需要的																			权限\n	.antMatchers(\"/salary/find\").hasAnyAuthority(\"/salary/find\")\n	.antMatchers(\"/staff/find\").hasAnyAuthority(\"/staff/find\")\n    .anyRequest().authenticated();  //表示任何请求都需要认证后才能访问\n```\n\n由于没有权限被拦截访问时会抛出403异常\n\n### 8.3基于注解的访问控制\n\n**@PreAuthorize**\n\n该注解可以在方法执行前判断用户是否具有权限\n\n在启动类中配置访问允许\n\n@EnableGlobalMethodSecurity(prePostEnabled= true)\n\n在控制器上配置访问注解\n\n```java\n@PreAuthorize(\"hasAnyAuthority(\'/reportform/find\')\")\n@GetMapping(\"/reportform/find\")\npublic String findReportForm() {\n    return \"查询报表\";\n}\n```\n\n### 8.4 基于自定义类的访问控制\n\n权限校验类\n\n~~~java\n@Service(\"permissions\")\npublic class PermissionsService {\n\n    /**\n     * @param permission 权限\n     * @return: boolean  是否具有权限\n     * @decription 判断当前用户是否具有该权限\n     * @date 2023/5/9 21:35\n    */\n    public boolean hasAnyAuthorities(String permission){\n        LoginUser loginUser = SecurityUtils.getLoginUser();\n        //如果是超级管理员，直接返回true\n        if(loginUser.getUser().getId().equals(1L)){\n            return true;\n        }else {\n            //获取当前用户的权限列表，判断是否拥有该权限\n            List<String> permissions = loginUser.getPermissions();\n            return permissions.contains(permission);\n        }\n    }\n}\n~~~\n\n进行校验配置\n\n~~~java\n@Configuration\n//开启注解权限方法\n@EnableGlobalMethodSecurity(prePostEnabled = true)\npublic class SecurityConfig extends WebSecurityConfigurerAdapter {}\n\n//拥有该权限才可以调用此方法，permissions是服务类的bean名称，hasAnyAuthorities是服务类的方法，括号里	//面的参数是方法的输入值\n@PreAuthorize(\"@permissions.hasAnyAuthorities(\'content:category:export\')\")\n@GetMapping(\"/export\")\npublic void export(HttpServletResponse response) throws IOException {}\n~~~\n\n## \n\n## 9.异常处理器\n\n### 9.1权限不足异常处理器\n\n```java\npublic class MyAccessDeniedHandler implements AccessDeniedHandler {\n    @Override\n    public void handle(HttpServletRequest request,\n                       HttpServletResponse response,\n					   AccessDeniedException accessDeniedException) \n        			   throws IOException,ServletException {\n		response.sendRedirect(\"/noPermission.html\");\n   }\n}\n```\n\n\n\n### 9.2未登录异常处理器\n\n```java\npublic class MyAuthenticationEntryPoint implements AuthencationEntryPoint{\n    @Override\n    public void commence(HttpServletRequest request, \n                         HttpServletResponse response, 															 AuthenticationException authException) \n        				 throws IOException, ServletException {\n        response.setContentType(\"text/json;charset=utf-8\");\n        BaseResult result = new BaseResult(401, \"用户未登录\", null);\n        response.getWriter().write(JSON.toJSONString(result));\n    }\n}\n```\n\n### 9.3配置异常处理器\n\n```java\n//异常处理\nhttp.exceptionHandling()\n                .accessDeniedHandler(new MyAccessDeniedHandler())\n                .authenticationEntryPoint(new MyAuthenticationEntryPoint());\n```\n\n', 'SpringSecurity个人总结-暂未更新完毕', 1, 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/30/89060050e46447539d65dc01621acb74.jpg', '1', '0', 6, '0', 1, '2023-05-30 17:13:31', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (21, 'Java总结笔记', '# 									 JavaSE\n\n## 1.流程标签\n\n如果想让break跳出外层循环，可使用java提供的标签功能，使程序跳到指定的位置\n\n```java\nflag:for(int i = 0;i++;i<5){\n        for(int j = 0;j++;j<5){\n            if(i = 1){\n                break flag;\n            }\n        }\n    }\n```\n\n与break语法一样，continue也支持标签，语法一样。不过break是跳出循环，而continue是继续下一次循环。\n\n## 2.字符串函数\n\n如果lastIndexOf()方法中，参数是空字符串，则返回的结果与调用该字符串的length()方法的返回结果相同。\n\n如果想定义多个分隔符，可以使用\"|\"，例如，\",|=\"，表示分割符为\",\"和\"=\"。\n\n常见的字符串函数\n\nchar charAt(int index):\n\nint compareTo(String string):\n\nboolean contains(String string):\n\nboolean startsWith(String string):\n\nboolean endsWith(String string):\n\nString toLowerCase():\n\nString toUpperCase():\n\nboolean equalsIngoreCase(String string):\n\nbyte[] getBytes():\n\nboolean isEmpty():\n\nchar[] toCharArray():\n\nint indexOf(String string):\n\nint lastIndexOf(String string):\n\nString replace(String s1,String s2):\n\nString[] split(String regax):\n\nString subString(int beginIndex):\n\nString trim():\n\nvoid deleteCharAt(int index):\n\n## 3.StirngBuilder\n\nString、StringBuilder、StringBuffer底层都是采用char[]数组，不同的是，String是final修饰的，意为不可变；StringBuffer中所有的方法都有对象锁，意为线程安全的；而StringBuilder则没有上述限制\n\nStringBuilder和StringBuffer默认分配16个单位长度，当拼接字符串的时候，如果数组长度不够，会进行自动扩容，新的长度为原长度x2+2，构建出新的数组，然后再进行值的复制\n\n## 4.IO流\n\n### 4.1try-with-resource语法糖\n\n在java.lang.AutoCloseable接口中包含了一个close方法，该方法用于关闭资源。\n\n只要是实现了java.lang.AutoCloseable接口的对象，都可以使用try-with-resource关闭资源。具体如下述代码\n\n### 4.2流的分类\n\n**按流的方向分类：**\n\n输入流：数据流向是数据源到程序（以InputStream、Reader结尾的流）\n\n输出流：数据流向是程序到目的地（以OutPutStream、Writer结尾的流）\n\n**按处理的数据单元分类：**\n\n字节流：以字节为单位获取数据，命名上以Stream结尾的流一般是字节流，如FileInputStream、\n\nFileOutputStream\n\n字符流：以字符为单位获取数据，命名上以Reader/Writer结尾的流一般是字符流，如\n\nFileReader、FileWriter\n\n**按处理对象不同分类：**\n\n节点流：可以直接从数据源或目的地读写数据，如FileInputStream、FileReader、\n\nDataInputStream等。\n\n处理流：不直接连接到数据源或目的地，是”处理流的流”。通过对其他流的处理提高程序的性能，\n\n如BufferedInputStream、BufferedReader等。处理流也叫包装流。\n\n### 4.3各种流介绍\n\nInputStream/OutputStream：字节流的抽象类。\n\nReader/Writer：字符流的抽象类。\n\nFileInputStream/FileOutputStream：节点流以字节为单位直接操作“文件”。\n\nByteArrayInputStream/ByteArrayOutputStream：节点流以字节为单位直接操作“字节数组对象”。\n\nObjectInputStream/ObjectOutputStream：处理流以字节为单位直接操作“对象”。\n\nDataInputStream/DataOutputStream：处理流以字节为单位直接操作“基本数据类型与字符串类型”。\n\nFileReader/FileWriter：节点流以字符为单位直接操作“文本文件”（注意：只能读写文本文件）。\n\nBufferedReader/BufferedWriter：处理流将Reader/Writer对象进行包装，增加缓存功能，提高读写效率。\n\nBufferedInputStream/BufferedOutputStream：处理流将InputStream/OutputStream对象进行包装，增加缓存																								功能，提高读写效率\n\nInputStreamReader/OutputStreamWriter：处理流将字节流对象转化成字符流对象。\n\nPrintStream：处理流将OutputStream进行包装，可以方便地输出字符，更加灵活。\n\n### 4.4各种流示例\n\n​																				**普通字节流**\n\n~~~java\ntry(FileInputStream fis = new FileInputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档.txt\");\n    FileOutputStream fos = new FileOutputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档														1.txt\")) {\n    //读取到的数据\n    int data;\n    //当读不到数据的时候，返回-1\n    while ((data = fis.read()) != -1){\n        //边读边写\n        fos.write((char)data);\n    }\n    fos.flush();\n} catch (FileNotFoundException e) {\n    throw new RuntimeException(e);\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n~~~\n\n​																		**带缓冲数组的字节流**\n\n~~~java\ntry(FileInputStream fis = new FileInputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档.txt\");\n    FileOutputStream fos = new FileOutputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档														2.txt\")) {\n    //用于接收数据的字节数组\n    byte[] data = new byte[1024];\n    //记录读取的数据数\n    int count;\n    while ((count = fis.read(data)) != -1){\n        //边读边写\n        System.out.println(data);\n        fos.write(data,0,count);\n    }\n    fos.flush();\n} catch (FileNotFoundException e) {\n    throw new RuntimeException(e);\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n~~~\n\n​																		**使用缓冲流的字节流**\n\n~~~java\ntry(FileInputStream fis = new FileInputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档.txt\");\n    FileOutputStream fos = new FileOutputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档														3.txt\");\n    BufferedInputStream bis = new BufferedInputStream(fis);\n    BufferedOutputStream bos = new BufferedOutputStream(fos)) {\n\n    int count = -1;\n    byte[] datas = new byte[1024];\n    while ((count = bis.read(datas)) != -1){\n        System.out.println(datas);\n        bos.write(datas);\n    }\n} catch (FileNotFoundException e) {\n    throw new RuntimeException(e);\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n~~~\n\n​																		**使用转换流的字符流**\n\n~~~java\ntry(FileInputStream fis = new FileInputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档.txt\");\n    FileOutputStream fos = new FileOutputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档														4.txt\");\n    InputStreamReader isr = new InputStreamReader(fis);\n    OutputStreamWriter osr = new OutputStreamWriter(fos)) {\n\n    int data = -1;\n    while ((data = isr.read()) != -1){\n        System.out.println(data);\n        osr.write(data);\n    }\n    osr.flush();\n} catch (FileNotFoundException e) {\n    throw new RuntimeException(e);\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n~~~\n\n​															**使用转换流实现键盘输入，屏幕输出**\n\n~~~java\ntry(InputStreamReader inputStreamReader = new InputStreamReader(System.in);\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(System.out);\n    BufferedReader reader = new BufferedReader(inputStreamReader);\n    BufferedWriter writer = new BufferedWriter(outputStreamWriter)) {\n\n    String input = reader.readLine();\n    while (!input.equals(\"exit\")){\n        writer.write(input);\n        writer.newLine();\n        writer.flush();\n        input = reader.readLine();\n    }\n} catch (FileNotFoundException e) {\n    throw new RuntimeException(e);\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n~~~\n\n​															**使用转换流实现屏幕输入到文件**\n\n~~~java\ntry(PrintWriter pw = new PrintWriter(new FileOutputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本		文档1.txt\"));\n    InputStreamReader inputStreamReader = new InputStreamReader(System.in);\n    BufferedReader reader = new BufferedReader(inputStreamReader)) {\n\n    String input = reader.readLine();\n    while (!input.equals(\"exit\")){\n        pw.println(input);\n        pw.flush();\n        input = reader.readLine();\n    }\n} catch (FileNotFoundException e) {\n    throw new RuntimeException(e);\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n~~~\n\n​																			**数据流使用**\n\n~~~java\n//创建数据输出流对象与文件字节输出流对象\ntry(DataOutputStream dos = new DataOutputStream(new FileOutputStream(\"d:/data\"));\n    //创建数据输入流对象与文件字节输入流对象\n    DataInputStream dis = new DataInputStream(new FileInputStream(\"d:/data\"))){\n    //将如下数据写入到文件中\n    dos.writeChar(\'a\');\n    dos.writeInt(10);\n    dos.writeDouble(Math.random());\n    dos.writeBoolean(true);\n    dos.writeUTF(\"北京尚学堂\");\n    //手动刷新缓冲区：将流中数据写入到文件\n\n    dos.flush();\n    //直接读取数据：读取的顺序要与写入的顺序一致，否则不能正确读取数据。\n    System.out.println(\"char: \" + dis.readChar());\n    System.out.println(\"int: \" + dis.readInt());\n    System.out.println(\"double: \" + dis.readDouble());\n    System.out.println(\"boolean: \" + dis.readBoolean());\n    System.out.println(\"String: \" + dis.readUTF());\n}catch(IOException e){\n    e.printStackTrace();\n}\n~~~\n\n​																			**对象流使用**\n\n~~~java\ntry(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"d:/data2\"));\n    //创建对象输入流对象与文件字节输入流对象\n    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"d:/data2\"))){\n\n    //将如下数据写入到文件中\n    oos.writeInt(10);\n    oos.writeDouble(Math.random());\n    oos.writeChar(\'a\');\n    oos.writeBoolean(true);\n    oos.writeUTF(\"你好Oldlu\");\n    oos.flush();\n\n    //必须要按照写入的顺序读取数据\n    System.out.println(\"int: \"+ois.readInt());\n    System.out.println(\"double: \"+ois.readDouble());\n    System.out.println(\"char: \"+ois.readChar());\n    System.out.println(\"boolean: \"+ois.readBoolean());\n    System.out.println(\"String: \"+ois.readUTF());\n}catch(IOException e){\n    e.printStackTrace();\n}\n~~~\n\n### 4.5缓冲流优势详解\n\n![image-20230522102635541](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230522102635541.png)\n\n### 4.6文件复制\n\n~~~java\n//完成源目录到目标目录的复制\npublic void copy(String src,String desc){\n    File srcFile = new File(src);\n    if(srcFile == null){\n        throw new RuntimeException(\"目标文件为空\"+src);\n    }\n    File descFile = new File(desc);\n    //目标文件是目录，进行递归\n    if(srcFile.isDirectory()){\n        //创建目录\n        descFile.mkdir();\n        //获取目录中的文件列表\n        File[] files = srcFile.listFiles();\n        //遍历文件列表\n        for (File file : files) {\n            copy(file.getAbsolutePath(), file.getAbsolutePath().replace(src,desc));\n        }\n    }else {\n        //目标是文件，直接复制\n        try(BufferedInputStream bis = new BufferedInputStream(new 																	FileInputStream(srcFile));\n            BufferedOutputStream bos = new BufferedOutputStream(new 																FileOutputStream(descFile))) {\n            //完成复制\n            int count = -1;\n            byte[] data = new byte[8192];\n            while ((count = bis.read(data)) != -1){\n                bos.write(data,0,count);\n                bos.flush();\n            }\n        } catch (FileNotFoundException e) {\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n~~~\n\n\n\n## 5.Object方法与常用api\n\nint hashCode():\n\nboolean equals():\n\nString toString():\n\nClass getClass():\n\nvoid wait():\n\nvoid notify():\n\nvoid notifyAll():\n\nSystem.gc():	调用垃圾回收线程\n\nSystem.currentTimeMills():	获取系统当前时间\n\nSystem.arrayCopy(int[] arr1,int start1,int[] arr2,int start2,int length):	完成数组的拷贝\n\nArrays.sort(int[] arr):	数组排序\n\nArrays.binarySearch(int[] arr ,int target):	二分法查找\n\nArrays.copy(int[] arr ,int lenth):	数组拷贝\n\nArrays.copyOfRange(int[] arr ,int begin ,int end):	数组拷贝\n\nprivate void finalize():	对象销毁时机\n\n## 6.定时器\n\n作用：间隔特定的时间，执行特定的程序\n\n1.使用sleep()方法\n\n2.使用java.util.Timer\n\n```java\nTimer timer = new Timer();//任务启动\n//task任务类，date启动事件，long间隔事件\n//添加任务\ntimer.schedule(new TimerTask(){	\n	@Override\n	public void run(){\n		sout();\n	}\n},Date date,long long);\n\n```\n\n3.Spring的SpringTask框架（详情看SpringBoot篇）\n\n## 7.反射\n\n### 7.1获取反射的三种方法\n\n```java\nClass class  = Class.forName(\"java.lang.String\");\n\n//通过对象获取\nString cc = \"cc\";\nClass class = cc.getClass;\n\n//通过类属性获取\nClass class = String.class;\n```\n\n### 7.2反射属性\n\n```java\nClass aclass = Class.forName(\"xxxx\");\nObject obj = aclass.newInstance();\n//获取类的属性对象\nField field = aclass.getDeclaredField(\"属性名\");\nField[] fields = aclass.getDeclareFields();\n//修改类的属性，field已经指定属性\nfield.set(obj,Object object);\n//获取类的指定属性\nfield.get(obj);\n//打破封装可以获取私有属性\nfield.setAccessiable(true);\n```\n\n### 7.3反射方法\n\n```java\n//获取所有的类方法\nMethod[] methods = aclass.getDeclareMethods();\n//获取方法的修饰符\nint i = method.getModifiers;\nModifiers.toString(i);\n//获取方法的返回值类型\nClass aclass = Method.getReturnType();\n//获取方法的名字\nString name = method.getName();\n//获取方法的参数列表\nClass[] types = method.getParameterTypes();\n//调用方法\nMethod method = aclass.getDeclaredMethod(\"login\",String.class,String.class);\nObject value = method.invoke(Object object,String username,String password);\n```\n\n### 7.4反射构造方法\n\n```java\n//获取全部构造方法\nConstruct[] constructors = aclass.getDeclaredConstructors();\n//获取修饰符\nint i = constructor.getModifiers();\nString name = Modifiers.toString(i);\n//获取构造方法名\nString name = constructor.getSimpleName();\n//获取参数列表\nClass[] types = constructor.getParameterTypes();\n//获取指定的构造方法\nConstructor constructor = aclass.getDeclaredConstructor(String.class,int.class);\n//根据构造方法创建对象\nObject obj = constructor.newInstance(\"string\",int);\n```\n\n### 7.5反射父类和接口\n\n```java\n//获取父类\nClass superClass = aclass.getSuperClass();\n//获取父类接口\nClass[] interfaces = superClass.getInterfaces();\n```\n\nfield、method、constructor都有setAccessiable方法,因为他们都继承了Accessiable接口\n\ngetMethod方法会返回继承的父类方法，而getDeclaredMethod则不会返回父类方法\n\n### 7.6反射基本数据类型\n\n~~~java\nClass<Integer> integerClass = int.class;\nClass<Integer> type = Integer.TYPE;\n\n//二者是同一个class对象，其他基本类型和包装类型都基本这样\nSystem.out.println(integerClass);\nSystem.out.println(type);\n~~~\n\n### 7.7类加载知识\n\n反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载。\n\n1.静态加载：编译时加载相关的类，如果没有则报错，依赖性太强（使用到就加载相应的类）\n\n2.动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，也不会报错，降低了依赖性\n\n**类加载时机**\n\n1.当创建对象时（new）//静态加载\n\n2.当子类被加载时，父类也加载 //静态加载\n\n3.调用类中的静态成员时 //静态加载\n\n4.通过反射 //动态加载\n\n![image-20230519154436373](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230519154436373.png)\n\n### 7.8类加载过程详解\n\n![image-20230519155007018](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230519155007018.png)\n\n#### 7.8.1加载\n\nJVM在这阶段的主要目的是将字节码从不同的数据源（class文件，jar包，网络）转化为二进制字节流加载到内存中，并生成一个代表类的java.lang.Class对象\n\n#### 7.8.2连接\n\n##### 7.8.2.1验证\n\n1.目的是为了确保CLass文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全，在此过	程中会获取一个SecurityManager对象来进行安全校验\n\n~~~java\n//ClassLoader的loadClass方法，把class文件加载到方法区中（此时字节码文件是以二进制的形式存在的）\npublic Class<?> loadClass(String name) throws ClassNotFoundException {\n    return loadClass(name, false);\n}\n//具体的loadClass方法\npublic Class<?> loadClass(String var1, boolean var2) throws ClassNotFoundException {\n    int var3 = var1.lastIndexOf(46);\n    if (var3 != -1) {\n        //此时会拿到一个SecurityManager对象，进行安全校验\n        SecurityManager var4 = System.getSecurityManager();\n        if (var4 != null) {\n            var4.checkPackageAccess(var1.substring(0, var3));\n        }\n    }\n}\n~~~\n\n\n\n2.包括：文件格式验证（是否以魔数oxcafe babe开头）、元数据验证、字节码验证和符号引用验证\n\n3.可以考虑使用-Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间。\n\n##### 7.8.2.2准备\n\nJVM会在该阶段对静态变量，分配内存并默认初始化（对应数据类型的默认初始值，如0、0L、null、false等）。\n\n首先会对静态变量分配内存地址，并进行值的初始化，这里不会真正的赋值，而是设成默认值。例如int类型会默认设成0，而long则是0L。如果变量被final static修饰，则会在此阶段直接赋值，因为被final static修饰的是常量\n\n##### 7.8.2.3解析\n\n虚拟机将常量池内的符号引用替换为直接引用（jvm内存地址）的过程\n\n#### 7.8.3初始化\n\n1.到初始化阶段，jvm会调用clinit方法。clinit方法是由编译器按语句在源文件中出现的顺序，一次收集类中的所有静态变量的赋值动作和静态代码块中的语句，进行合并（jvm代码优化）执行。\n\n2.虚拟机会保证一个类的clinit方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit方法，其他线程都需要阻塞等待，直到活动线程方法执行完毕\n\n~~~java\n//装载字节码\npublic Class<?> loadClass(String name) throws ClassNotFoundException {\n    return loadClass(name, false);\n}\n//方法重载，真正执行的也是这个方法的loadClass\nprotected Class<?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n    //加锁，多线程阻塞等待\n    synchronized (getClassLoadingLock(name)) {\n        // First, check if the class has already been loaded\n        Class<?> c = findLoadedClass(name);\n        if (c == null) {\n            long t0 = System.nanoTime();\n            try {\n                if (parent != null) {\n                    c = parent.loadClass(name, false);\n                } else {\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                // ClassNotFoundException thrown if class not found\n                // from the non-null parent class loader\n            }\n\n            if (c == null) {\n                // If still not found, then invoke findClass in order\n                // to find the class.\n                long t1 = System.nanoTime();\n                c = findClass(name);\n\n                // this is the defining class loader; record the stats\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            }\n        }\n        if (resolve) {\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n~~~\n\n\n\n## 8.stream工作流\n\n### 8.1创建流\n\n1.单例集合 list/set.stream()\n\n2.数组 Arrays.stream(Object[] arr) / Stream.of(Object[] arr)\n\n3.双例集合 map.entryset().stream()\n\n### 8.2中间操作\n\n1.filter 可以对流中的数据进行条件过滤，符合条件的数据继续留在流中\n\nstream.filter(book -> book.price > 100.0);\n\n2.map 可以把流中的元素进行计算或者转换（数据类型转换）\n\nstream.map(book -> book.price+10)\n\n3.distinct可以去除流中的重复元素,通过对象的equals方法进行判断\n\nstream.distinct()\n\n4.sorted可以对流中的元素进行排序，如果调用空参的sorted()方法，需要实现comparable接口\n\nstream.sort((b1,b2) -> b1.price-b2.price)\n\n5.limit可以设置流的最大长度，超出的部分被抛弃\n\nstream.limit(2)\n\n6.skip跳过流中的前几个元素，返回剩下的元素\n\nstream.skip(2)\n\n7.flatmap map只能把一个对象转换成另一个对象来作为流中的元素，而flatmap可以把一个对象转换成多个对象	作为流中的元素\n\nstream.flatmap(book -> book.categories)\n\n### 8.3终结操作\n\n1.foreach 对流中的数据进行遍历操作\n\nstream.forEach(book -> sout(book.author))\n\n2.count 可以用来获取当前流中的元素个数\n\nstream.count()\n\n3.max&min 可以用来获取流中的最值，实现comparable接口或者自定义比较规则\n\nstream.min((b1,b2) -> b1.price- b2.price)\n\n4.collect把当前流转换成一个集合\n\nstream.collect(Collectors.toList())\n\nstream.collect(Collectors.toSet)\n\nstream.collect(Collectors.toMap(book -> book.author,book -> book.name))\n\n5.anyMatch 可以用来判断是否有任意符合匹配规条件的元素，结果为Boolean类型\n\nstream.anyMatch(book -> book.price > 100.0)\n\n6.allMath 可以用来判断是否都符合匹配条件，结果为Boolean类型\n\nstream.allMatch(book -> book.price > 100.0)\n\n7.noneMatch可以用来判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则为false\n\nstream.noneMatch(book -> book.price > 100.0)\n\n8.findAny 随机获取流中的元素，不保证顺序\n\nstream.findAny()\n\n9.findFirst 获取流中的第一个元素\n\nstream.findFirst()\n\n## 9.集合\n\ncollection接口下有list接口和set接口，map是单独一个接口\n\nlist接口下常用的集合有arraylist、vector和linkedlist\n\nset接口下常用的集合有hashset和treeset\n\nmap接口下常用的集合有hashmap和hashtable\n\n### 9.1ArrayList知识点\n\njdk1.7创建集合的时候，立刻将数组初始化，初始长度为10\n\njdk1.8创建集合的时候不会对数组进行初始化，而是在使用的时候再赋值为10，这样可以减少内存开销\n\n当数组长度不足时，扩容为原来长度的1.5倍\n\n调用add方法的时候，会先判断数组容量，是否需要扩容，再进行元素添加\n\n### 9.2Vector知识点\n\nvector是线程安全的（实例对象锁），而且在创建集合的时候就会立马对数组进行初始化，初始容量为10\n\n当容量不足的时候，会对数组进行扩容，长度为原本的长度的两倍\n\n### 9.3LinkedList知识点\n\nlinkedlist底层采用双向链表，维护了两个属性first和last，分别指向首节点和尾节点。每个节点（Node对象）里面又维护了pre、next和item三个属性，其中，通过pre指向前一个，next指向后一个，最终实现双向链表。所有LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高。\n\n### 9.4HashSet知识点\n\nhashset就是value值为null的hashmap集合，所以也是无序（取出和存入顺序不一致），不可重复的集合（可存入一个null值），存放的位置取决于hash后确定的索引结果\n\n扩容机制和hashmap一样，其他基本相同\n\n### 9.5TreeSet知识点\n\ntreeset也是无序不可重复的集合，但是可以排序，这就以为着集合中的元素需要实现comparable接口，重写compareTo方法，或者，创建集合的时候就传入比较器对象（实现comparator接口，重写compareTo方法）\n\n### 9.6HashTable知识点\n\nHashTable的键和值都不能为null，否则会抛出NUllPointerException。HashTable的使用方法和hashMap一样，hashtable是线程安全的，hashmap是线程不安全的。\n\n### 9.7HashMap知识点\n\n默认容量是16，最大容量为2的30次方，扩容时机是0.75，红黑树阈值是8，链表阈值是6，树形化处理阈值是64，即当数组长度大于64，且链表长度大于8，才会转换成红黑树。当数组需要扩容的时候，容量变为原容量的两倍\n\n在jdk1.8中对数组的初始化采用了延迟初始化，即调用add()方法时才会初始化\n\n进行hash值计算的时候，先用hashcode的高16位和低6位进行异或运算，得到的结果再和数组的长度-1进行&运算，最后返回索引在数组中的位置\n\nMap中的key和value可以是任何引用类型的数据，会封装到HashMap的Node静态内部类中\n\nMap中的key不允许重复，value允许重复，key重复的时候，底层会进行value的赋值更新\n\nMap的key可以为null，value也可以为null，但是key只能有一个，value可以有多个\n\n### 9.8LinkedHashSet\n\nLinkedHashSet继承了HashSet，实现了Set接口，linkedHashSet底层是一个LinkedHashMap，维护了一个数组加双向链表，根据元素的hashcode值来决定元素的存储位置，同时使用链表维护元素的顺序，不允许添加重复元素，但是元素是有序的，存入和取出元素次序相同\n\n![image-20230508203254158](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230508203254158.png)\n\n## 10.集合详解\n\n### 10.1集合关系图\n\n![image-20230508133147847](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230508133147847.png)\n\n![image-20230508133229431](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230508133229431.png)\n\n​																		**Collection接口常用方法**\n\n![image-20230508133348196](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230508133348196.png)\n\n### 10.2Iterable迭代器接口（itit快捷键）\n\n```java\nIterator<Integer> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n	Integer next =  iterator.next();\n	iterator.remove();\n}\n```\n\n需要注意的是\n\n~~~java\nInteger[] ints = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nList<Integer> list = Arrays.asList(ints);\n//使用Arrays.asList方法构建的list集合无法使用remove方法，直接创建的list集合才可以使用，否则会报错\n//UnsupportedOperationException，因为这样构建出来的list没有重写remove方法\n//也可以使用增强for循环进行迭代，但是底层仍是使用iterator迭代器\n//迭代删除元素可以使用removeif方法\n\n~~~\n\n### 10.3list接口（有序，可重复）\n\n#### 10.3.1ArrayList源码\n\n1.ArrayList中维护了一个Object数组elementData transient Object[] elementData;\n\n~~~java\n//无参构造器\npublic ArrayList() {\n	this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n//赋值为空数组\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n~~~\n\n2.当创建ArrayList对象时，如果使用的无参构造器，则初始elementData容量为0，第一次添加的时候，则扩容elementData为10，如需再次扩容，则扩容elementData为1.5倍\n\n~~~java\n//添加元素时，进行扩容判定\npublic boolean add(E e) {\n    //扩容判定\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    //添加元素\n    elementData[size++] = e;\n    return true;\n}\n//扩容判定\nprivate void ensureCapacityInternal(int minCapacity) {\n	ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n//初始判定\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    //判定当前数组容量是否为0\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        //为0，则返回10，即初始化为10\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n//精确判定\nprivate void ensureExplicitCapacity(int minCapacity) {\n    //记录更改次数，多线程冲突\n    modCount++;\n\n    //若当前容量大于数组长度，则进行扩容\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n//扩容机制\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    //长度右移+长度，即扩容为1.5倍\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    //解释了为什么初始容量为10\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    //数组拷贝\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n~~~\n\n3.如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如需再次扩容，则直接扩容为elementData的1.5倍\n\n~~~java\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        //数组容量赋值为指定大小\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    }\n}\n~~~\n\n4.remove()方法源码\n\n~~~java\n//删除元素\npublic E remove(int index) {\n    //越界检查\n    rangeCheck(index);\n\n    modCount++;\n    E oldValue = elementData(index);\n\n    //判断后续需要移动的元素数量\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        //完成数组元素迁移\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    //末尾置空，触发GC\n    elementData[--size] = null; // clear to let GC do its work\n\n    return oldValue;\n}\n//判断删除元素的索引位置，是否越界\nprivate void rangeCheck(int index) {\n    if (index >= size)\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n~~~\n\n​																		**元素迁移图解**\n\n![image-20230508160605638](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230508160605638.png)\n\n#### 10.3.2Vector源码\n\n~~~java\n//无参构造器\npublic Vector() {\n    //默认赋值为10，即刻赋值\n    this(10);\n}\n//有参构造器，默认增量为0\npublic Vector(int initialCapacity) {\n    this(initialCapacity, 0);\n}\n//有参构造器，指定初始大小和增量\npublic Vector(int initialCapacity, int capacityIncrement) {\n    super();\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    this.elementData = new Object[initialCapacity];\n    this.capacityIncrement = capacityIncrement;\n}\n//添加元素\npublic synchronized boolean add(E e) {\n    modCount++;\n    //进行容量大小判断\n    ensureCapacityHelper(elementCount + 1);\n    elementData[elementCount++] = e;\n    return true;\n}\n//判定大小\nprivate void ensureCapacityHelper(int minCapacity) {\n    //当元素数量大于数组容量，进行扩容\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    //判断增量，增量为0，则两倍扩容，否则增量扩容\n    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?\n                                     capacityIncrement : oldCapacity);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    //元素拷贝\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n~~~\n\n#### 10.3.3LinkedList源码\n\n**添加元素到指定位置**\n\n~~~java\n//添加元素\npublic void add(int index, E element) {\n    //检查元素越界异常\n    checkPositionIndex(index);\n	//若索引为长度大小，则直接添加到末尾\n    if (index == size)\n        linkLast(element);\n    else\n        //否则添加到指定位置的节点前面\n        linkBefore(element, node(index));\n}\n//检查元素越界异常\nprivate void checkPositionIndex(int index) {\n    if (!isPositionIndex(index))\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n//当索引小于0或者大于链表长度，则判定为越界\nprivate boolean isPositionIndex(int index) {\n    return index >= 0 && index <= size;\n}\n//添加到末尾\nvoid linkLast(E e) {\n    //获取尾节点\n    final Node<E> l = last;\n    final Node<E> newNode = new Node<>(l, e, null);\n    //尾节点指向新节点\n    last = newNode;\n    if (l == null)\n        first = newNode;\n    else\n        //旧尾节点next指向新尾节点\n        l.next = newNode;\n    size++;\n    modCount++;\n}\n//找到指定位置的节点\nNode<E> node(int index) {\n    //折半查找，前则正序，后则倒叙\n    if (index < (size >> 1)) {\n        //正序\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        //倒叙\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n//添加到指定节点前面\nvoid linkBefore(E e, Node<E> succ) {\n    // assert succ != null;\n    final Node<E> pred = succ.prev;\n    final Node<E> newNode = new Node<>(pred, e, succ);\n    succ.prev = newNode;\n    if (pred == null)\n        first = newNode;\n    else\n        pred.next = newNode;\n    size++;\n    modCount++;\n}\n~~~\n\n**删除指定位置的元素**\n\n~~~java\n//与上述流程相似，不再赘述，详细看图解\npublic E remove(int index) {\n    checkElementIndex(index);\n    return unlink(node(index));\n}\nE unlink(Node<E> x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n\n    if (prev == null) {\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n\n    if (next == null) {\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n~~~\n\n​																						**图解删除节点**\n\n![image-20230508163408618](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230508163408618.png)\n\n### 10.4Set接口（无序，不可重复，可排序）\n\n#### 10.4.1HashSet源码\n\n​																			**初始扩容方法源码**\n\n```java\nfinal Node<K,V>[] resize() {\n    //获取集合数组属性\n    Node<K,V>[] oldTab = table;\n    //判断旧数组对象，刚开始为null，旧容量赋值为0\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    //旧阈值也是0\n    int oldThr = threshold;\n    //新阈值，新容量都为0\n    int newCap, newThr = 0;\n    //旧容量为0，不执行\n    if (oldCap > 0) {\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        //扩容两倍，阈值也扩容为两倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    //旧阈值也为0\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {               // zero initial threshold signifies using defaults\n        //默认赋值，初始容量为16，阈值为12，当旧容量和旧阈值都为0时\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    //新阈值赋值给集合的阈值\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    //创建新的节点数组，大小为新的容量\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    //将新的节点数组赋值给集合数组\n    table = newTab;\n    //直接返回\n    return newTab;\n}\n```\n\n​																			**后续扩容方法源码**\n\n~~~java\n//此时数组的原大小为16，阈值为12\nfinal Node<K,V>[] resize() {\n    //集合数组赋值给旧数组\n    Node<K,V>[] oldTab = table;\n    //此时旧容量为16\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    //旧阈值为12\n    int oldThr = threshold;\n    //新数组和新阈值都为0\n    int newCap, newThr = 0;\n    //进入此判断\n    if (oldCap > 0) {\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        //新的容量为旧容量左移一位，即x2\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            //新的阈值也是旧阈值左移1位x2\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    //新的阈值赋值给集合阈值\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    //创建一个新的数组\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    //完成数组的赋值\n    table = newTab;\n    //进行数据迁移\n    if (oldTab != null) {\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { // preserve order\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    //返回数组\n    return newTab;\n}\n~~~\n\n\n\n​																			**添加元素方法源码**\n\n~~~java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    //进行集合初始化\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    //拿键的hash值和数组长度-1进行与运算，拿到索引值\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        //若索引值处没有元素，直接添加\n        tab[i] = newNode(hash, key, value, null);\n    else {	//存在元素\n        Node<K,V> e; K k;\n        //equal相等，进行替换\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            //先锁定替换的节点位置\n            e = p;\n        else if (p instanceof TreeNode)	//equal不相等，添加到链表或树，判断节点类型\n            //节点为树节点，进行挂接，先标记挂接的点，尚未解决，要学习红黑树节点的挂接\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            //否则，属于链表节点，进行遍历到尾节点，标记节点\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    //若链表为尾节点，直接连接到末尾，此时标记节点为null\n                    p.next = newNode(hash, key, value, null);\n                    //判断当前链表长度，若大于等于8，则进行树化\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        //树化，未解决\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                //遍历链表，equals成功则标记替换节点，不成功则向下遍历\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        //当标记节点不为null的时候，则代表存在重复key，需要完成替换\n        if (e != null) { // existing mapping for key\n            //返回旧值\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                //完成新值的替换\n                e.value = value;\n            //需要继承类重写的方法，linkHashMap\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    //判断是否需要扩容，即判断是否大于阈值\n    if (++size > threshold)\n        resize();\n    //需要继承类重写的方法，linkHashMap\n    afterNodeInsertion(evict);\n    return null;\n}\n~~~\n\n​																			**添加元素方法流程源码**\n\n~~~java\n//添加元素\npublic boolean add(E e) {\n    return map.put(e, PRESENT)==null;\n}\n//调用map的put方法\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n//计算键的hash值，策略为hashcode与自身低16位进行异或运算得到hash值，目的是为了减少hash冲突\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n~~~\n\n#### 10.4.2LinkedHashSet源码\n\n~~~java\n//LinkedHashSet数组节点是一个静态内部类，继承hashmap的一个静态内部类\nstatic class Entry<K,V> extends HashMap.Node<K,V> {\n    //维护了两个节点类型，分别指向上一个节点和下一个节点，实现双向链表的结构\n    Entry<K,V> before, after;\n    //构造方法调用父类的构造方法\n    Entry(int hash, K key, V value, Node<K,V> next) {\n        super(hash, key, value, next);\n    }\n}\n\n//hashMap的静态内部类，除了常见的属性外，自带了next节点属性，指向下一个节点，维护了链表\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n\n    public final K getKey()        { return key; }\n    public final V getValue()      { return value; }\n    public final String toString() { return key + \"=\" + value; }\n\n    public final int hashCode() {\n        return Objects.hashCode(key) ^ Objects.hashCode(value);\n    }\n\n    public final V setValue(V newValue) {\n        V oldValue = value;\n        value = newValue;\n        return oldValue;\n    }\n\n    public final boolean equals(Object o) {\n        if (o == this)\n            return true;\n        if (o instanceof Map.Entry) {\n            Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n            if (Objects.equals(key, e.getKey()) &&\n                Objects.equals(value, e.getValue()))\n                return true;\n        }\n        return false;\n    }\n}\n//两个内部类结合完成了双向链表加单链表的结合，即保证了有序，又保证了查询替换效率\n~~~\n\n#### 10.4.3TreeSet源码（未完成）\n\n### 10.5Map接口\n\n#### 10.5.1内部存储结构\n\n~~~java\n//map内部节点数组\ntransient Node<K,V>[] table;\n//内部节点对象，Node节点是真正存储数据的地方，其他地方都是对该数据的引用\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;\n    \n    //重写Map.Entry<K,V>接口方法\n    public final K getKey()        { return key; }\n    //重写Map.Entry<K,V>接口方法\n    public final V getValue()      { return value; }\n    //重写Map.Entry<K,V>接口方法\n    public final V setValue(V newValue) {\n        V oldValue = value;\n        value = newValue;\n        return oldValue;\n    }\n}\n\n//内部类，方便遍历而设计的，集合类型是Map.Entry，实际类型是Node\nfinal class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n    public final int size()                 { return size; }\n    public final void clear()               { HashMap.this.clear(); }\n    public final Iterator<Map.Entry<K,V>> iterator() {\n        return new EntryIterator();\n    }\n    public final boolean contains(Object o) {\n        if (!(o instanceof Map.Entry))\n            return false;\n        Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n        Object key = e.getKey();\n        Node<K,V> candidate = getNode(hash(key), key);\n        return candidate != null && candidate.equals(e);\n    }\n    public final boolean remove(Object o) {\n        if (o instanceof Map.Entry) {\n            Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n            Object key = e.getKey();\n            Object value = e.getValue();\n            return removeNode(hash(key), key, value, true, true) != null;\n        }\n        return false;\n    }\n    public final Spliterator<Map.Entry<K,V>> spliterator() {\n        return new EntrySpliterator<>(HashMap.this, 0, -1, 0, 0);\n    }\n    public final void forEach(Consumer<? super Map.Entry<K,V>> action) {\n        Node<K,V>[] tab;\n        if (action == null)\n            throw new NullPointerException();\n        if (size > 0 && (tab = table) != null) {\n            int mc = modCount;\n            for (int i = 0; i < tab.length; ++i) {\n                for (Node<K,V> e = tab[i]; e != null; e = e.next)\n                    action.accept(e);\n            }\n            if (modCount != mc)\n                throw new ConcurrentModificationException();\n        }\n    }\n}\n\n//Map的内部集合类，可以获取set集合进行遍历\nfinal class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n    public final int size()                 { return size; }\n    public final void clear()               { HashMap.this.clear(); }\n    public final Iterator<Map.Entry<K,V>> iterator() {\n        return new EntryIterator();\n    }\n    public final boolean contains(Object o) {\n        if (!(o instanceof Map.Entry))\n            return false;\n        Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n        Object key = e.getKey();\n        Node<K,V> candidate = getNode(hash(key), key);\n        return candidate != null && candidate.equals(e);\n    }\n    public final boolean remove(Object o) {\n        if (o instanceof Map.Entry) {\n            Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n            Object key = e.getKey();\n            Object value = e.getValue();\n            return removeNode(hash(key), key, value, true, true) != null;\n        }\n        return false;\n    }\n    public final Spliterator<Map.Entry<K,V>> spliterator() {\n        return new EntrySpliterator<>(HashMap.this, 0, -1, 0, 0);\n    }\n    public final void forEach(Consumer<? super Map.Entry<K,V>> action) {\n        Node<K,V>[] tab;\n        if (action == null)\n            throw new NullPointerException();\n        if (size > 0 && (tab = table) != null) {\n            int mc = modCount;\n            for (int i = 0; i < tab.length; ++i) {\n                for (Node<K,V> e = tab[i]; e != null; e = e.next)\n                    action.accept(e);\n            }\n            if (modCount != mc)\n                throw new ConcurrentModificationException();\n        }\n    }\n}\n\n//Map的内部集合类，可以获取value集合进行遍历\nfinal class Values extends AbstractCollection<V> {\n    public final int size()                 { return size; }\n    public final void clear()               { HashMap.this.clear(); }\n    public final Iterator<V> iterator()     { return new ValueIterator(); }\n    public final boolean contains(Object o) { return containsValue(o); }\n    public final Spliterator<V> spliterator() {\n        return new ValueSpliterator<>(HashMap.this, 0, -1, 0, 0);\n    }\n    public final void forEach(Consumer<? super V> action) {\n        Node<K,V>[] tab;\n        if (action == null)\n            throw new NullPointerException();\n        if (size > 0 && (tab = table) != null) {\n            int mc = modCount;\n            for (int i = 0; i < tab.length; ++i) {\n                for (Node<K,V> e = tab[i]; e != null; e = e.next)\n                    action.accept(e.value);\n            }\n            if (modCount != mc)\n                throw new ConcurrentModificationException();\n        }\n    }\n}\n//获取key集合\npublic Set<K> keySet() {\n    Set<K> ks = keySet;\n    if (ks == null) {\n        ks = new KeySet();\n        keySet = ks;\n    }\n    return ks;\n}\n//获取value集合\npublic Collection<V> values() {\n    Collection<V> vs = values;\n    if (vs == null) {\n        vs = new Values();\n        values = vs;\n    }\n    return vs;\n}\n//获取key-value集合\npublic Set<Map.Entry<K,V>> entrySet() {\n    Set<Map.Entry<K,V>> es;\n    return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;\n}\n~~~\n\n#### 10.5.2Map接口常用方法\n\n![image-20230515214314007](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230515214314007.png)\n\n#### 10.5.3HashTable源码\n\n​																					**初始扩容**	\n\n~~~java\n//无参构造方法，默认初始容量位11\npublic Hashtable() {\n    this(11, 0.75f);\n}\n//有参构造方法\npublic Hashtable(int initialCapacity, float loadFactor) {\n    //数据校验\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal Load: \"+loadFactor);\n	//最小容量为1\n    if (initialCapacity==0)\n        initialCapacity = 1;\n    //赋值加载因子\n    this.loadFactor = loadFactor;\n    //创建集合，并赋值\n    table = new Entry<?,?>[initialCapacity];\n    //赋值阈值\n    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);\n}\n~~~\n\n​																			**后续扩容**\n\n~~~java\nprotected void rehash() {\n    //获取旧的容量\n    int oldCapacity = table.length;\n    //获取集合数组\n    Entry<?,?>[] oldMap = table;\n\n    //新的容量为旧的容量左移+1\n    int newCapacity = (oldCapacity << 1) + 1;\n    //不可超过最大值\n    if (newCapacity - MAX_ARRAY_SIZE > 0) {\n        if (oldCapacity == MAX_ARRAY_SIZE)\n            // Keep running with MAX_ARRAY_SIZE buckets\n            return;\n        newCapacity = MAX_ARRAY_SIZE;\n    }\n    //创建新的数组\n    Entry<?,?>[] newMap = new Entry<?,?>[newCapacity];\n\n    modCount++;\n    //创建新的阈值\n    threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);\n    //给集合数组赋值\n    table = newMap;\n	//完成元素迁移\n    for (int i = oldCapacity ; i-- > 0 ;) {\n        for (Entry<K,V> old = (Entry<K,V>)oldMap[i] ; old != null ; ) {\n            Entry<K,V> e = old;\n            old = old.next;\n\n            int index = (e.hash & 0x7FFFFFFF) % newCapacity;\n            e.next = (Entry<K,V>)newMap[index];\n            newMap[index] = e;\n        }\n    }\n}\n~~~\n\n\n\n​																			**添加元素**\n\n~~~java\n//添加元素方法\npublic synchronized V put(K key, V value) {\n    //值和键都不可以为null\n    if (value == null) {\n        throw new NullPointerException();\n    }\n	//获取数组\n    Entry<?,?> tab[] = table;\n    //计算出索引值\n    int hash = key.hashCode();\n    int index = (hash & 0x7FFFFFFF) % tab.length;\n    @SuppressWarnings(\"unchecked\")\n    //获取索引处的元素\n    Entry<K,V> entry = (Entry<K,V>)tab[index];\n    //遍历此处链表\n    for(; entry != null ; entry = entry.next) {\n        if ((entry.hash == hash) && entry.key.equals(key)) {\n            //进行替换，返回旧值\n            V old = entry.value;\n            entry.value = value;\n            return old;\n        }\n    }\n	//添加新值\n    addEntry(hash, key, value, index);\n    return null;\n}\n//添加新值\nprivate void addEntry(int hash, K key, V value, int index) {\n    modCount++;\n	//获取数组\n    Entry<?,?> tab[] = table;\n    //如果数量大于阈值，进行扩容\n    if (count >= threshold) {\n        // Rehash the table if the threshold is exceeded\n        rehash();\n		\n        tab = table;\n        hash = key.hashCode();\n        index = (hash & 0x7FFFFFFF) % tab.length;\n    }\n	//获取当前索引位置的元素\n    @SuppressWarnings(\"unchecked\")\n    Entry<K,V> e = (Entry<K,V>) tab[index];\n    //将旧的元素作为下一个节点参数，创建新节点，头插法（map是尾插法）\n    tab[index] = new Entry<>(hash, key, value, e);\n    count++;\n}\n~~~\n\n#### 10.5.4Properties方法\n\n~~~java\n//加载驱动，在程序启动的时候就被加载且只执行一次\nstatic{\n    try {\n        Properties properties = new Properties();//创建配置文件对象\n        //通过类获取流的对象\n        InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream(\"db.properties\");\n\n        properties.load(in);//通过字节输入流in读取里边的键值对\n\n        driver = properties.getProperty(\"driverClassName\");//获取键对应的值\n        url = properties.getProperty(\"url\");               //获取键url对应的值\n        username = properties.getProperty(\"username\");     //获取键username对应的值\n        password = properties.getProperty(\"password\");     //获取键password对应的值\n\n        Class.forName(driver);           //加载驱动\n    } catch (ClassNotFoundException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (IOException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n}\n~~~\n\n#### 10.5.5TreeMap源码（未完成）\n\n', 'java集合、io流基础总结', 1, 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/31/c0ff8a25ec264f4fab616b306f601a68.jpg', '1', '0', 8, '0', 1, '2023-05-31 08:42:06', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (22, '5-27Vue学习日记', '## 10. 5/27日总结\n\n### 10.1生命周期函数\n\nbeforeCreate:初始化生命周期和事件，但数据代理还没开始\n\ncreated: 初始化数据检测、数据代理\n\nbeforeMount:此时页面展示的是未经Vue编译的Dom结构，所有对Dom的操作都不会生效\n\nmounted:此时呈现的是经过Vue编译的Dom，对Dom的操作都有效，但不建议，一般在此阶段进行：\n\n​				开启定时器、发送网路请求、订阅信息、绑定自定义事件等初始化操作\n\nbeforeUpdate:此时数据是新的，页面是旧的，即页面尚未和数据保持同步\n\nupdated:此时数据是新的，页面也是新的，即页面和数据保持同步\n\nbeforeDestroy:vm中所有的data、methods、指令等，都处于可用状态，马上要执行销毁过程，一般在此阶段：关闭定时器、取消订阅信息和解绑自定义事件等收尾操作\n\ndestroyed:完成vm对象的销毁，清理它与其他实例的连接，解绑它的全部指令及事件监听器\n\n\n\n常用的生命周期钩子：\n\n1.mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。\n\n2.beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。\n\n关于销毁Vue实例\n\n1.销毁后借助Vue开发者工具看不到任何信息。\n\n2.销毁后自定义事件会失效，但原生DOM事件依然有效。\n\n3.一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。\n\n### 10.2 额外知识\n\n定时任务与取消定时任务\n\n~~~js\n//定时任务\nsetInterval(()=>{\n    this.opacity -= 0.01;\n    if(this.opacity <= 0){\n    	this.opacity = 1;\n    }\n},10)\n//取消定时任务\nclearInterval(this.timer);\n~~~\n\n### 10.3 代码练习\n\n~~~html\n<body>\n    <div id=\"root\">\n        <h1 :style=\"{opacity}\">CC</h1>\n        <button @click=\"canclTimer\">取消</button>\n    </div>\n\n    <script>\n        new Vue({\n            el:\"#root\",\n            data:{\n                opacity:1\n            },\n            methods: {\n                canclTimer(){\n                    clearInterval(this.timer);\n                }\n            },\n            mounted() {\n                this.timer = setInterval(()=>{\n                    this.opacity -= 0.01;\n                    if(this.opacity <= 0){\n                        this.opacity = 1;\n                    }\n                },10)\n            }\n        })\n    </script>\n</body>\n~~~\n\n', 'Vue学习日记', 4, 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/31/0e452353293f436898e891ba4908ce03.jpg', '1', '0', 4, '0', 1, '2023-05-31 08:47:14', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (23, '博客引入邮件推送功能及端口问题记录', '## 20.引入qq邮件日志记录功能\n\n### 20.1环境配置\n\n需要在邮箱中开启相应的功能，这里以qq邮箱为例，其他邮箱可以自行百度解决\n\n![image-20230526194530043](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230526194530043.png)\n\n开启POP3/SMTP服务\n\n![image-20230526194608230](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230526194608230.png)\n\n发送邮件开启功能\n\n![image-20230526194702991](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230526194702991.png)\n\n记住你的授权码，配置发送邮件的密码就是你的授权码\n\n![image-20230526194914000](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230526194914000.png)\n\n引入依赖\n\n~~~xml\n<!-- 发邮件 -->\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-mail</artifactId>\n  <version>2.3.7.RELEASE</version>\n</dependency>\n~~~\n\n配置账号密码\n\n~~~yml\n# 发送邮件配置\nmail:\n # 发件人地址\n  user: \n # 填写你的授权码，不是邮箱密码\n  password: \n\n~~~\n\n### 20.2 配置发送邮件工具类\n\n~~~java\n@Component\npublic class MailUtils {\n\n    @Value(\"${mail.user}\")\n    private String USER;\n    @Value(\"${mail.password}\")\n    private String PASSWORD;\n    @Value(\"${mail.toEmail}\")\n    private String ToEmail;\n    @Value(\"@{mail.elseEmail}\")\n    private String elseEmail;\n\n    public void sendToManagers(String text,String title){\n        this.sendMail(text,title,ToEmail);\n        //this.sendMail(text,title,elseEmail);\n    }\n\n    private boolean sendMail(String text, String title,String destination){\n        try {\n            Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());\n            final String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n            Properties props = new Properties();\n            props.put(\"mail.smtp.auth\", \"true\");\n            props.put(\"mail.smtp.host\", \"smtp.qq.com\");\n            props.setProperty(\"mail.smtp.socketFactory.class\", SSL_FACTORY);\n            props.setProperty(\"mail.smtp.socketFactory.fallback\", \"false\");\n            //邮箱发送服务器端口,这里设置为465端口\n            props.setProperty(\"mail.smtp.port\", \"465\");\n            props.setProperty(\"mail.smtp.socketFactory.port\", \"465\");\n            props.put(\"mail.smtp.auth\", \"true\");\n\n\n            // 发件人的账号\n            props.put(\"mail.user\", USER);\n            //发件人的密码\n            props.put(\"mail.password\", PASSWORD);\n\n            // 构建授权信息，用于进行SMTP进行身份验证\n            Authenticator authenticator = new Authenticator() {\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    // 用户名、密码\n                    String userName = props.getProperty(\"mail.user\");\n                    String password = props.getProperty(\"mail.password\");\n                    return new PasswordAuthentication(userName, password);\n                }\n            };\n            // 使用环境属性和授权信息，创建邮件会话\n            Session mailSession = Session.getInstance(props, authenticator);\n            // 创建邮件消息\n            MimeMessage message = new MimeMessage(mailSession);\n            // 设置发件人\n            String username = props.getProperty(\"mail.user\");\n            InternetAddress form = new InternetAddress(username);\n            message.setFrom(form);\n\n            // 设置收件人\n            InternetAddress toAddress = new InternetAddress(destination);\n            message.setRecipient(Message.RecipientType.TO, toAddress);\n\n            // 设置邮件标题\n            message.setSubject(title);\n\n            // 设置邮件的内容体\n            message.setContent(text, \"text/html;charset=UTF-8\");\n            // 发送邮件\n            Transport.send(message);\n            return true;\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n        return false;\n    }\n}\n~~~\n\n 															**设置切面，设置定时任务，发送统计数据邮件**\n\n~~~java\n@Pointcut(\"@annotation(com.zxnk.annotation.ViewLog)\")\npublic void ViewLog(){}\n\n@Before(\"ViewLog()\")\npublic void loginBeforeLog(){\n    ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();\n    HttpServletRequest request = requestAttributes.getRequest();\n    //获取请求ip\n    String host = request.getRemoteHost();\n    //添加缓存数据\n    redisTemplate.opsForList().rightPush(\"audience\",Audience.builder().ip(host).build());\n    SimpleDateFormat format = new SimpleDateFormat(\"YYYY-MM-DD HH-mm-ss\");\n    Date date = new Date();\n    //增加浏览数\n    redisTemplate.opsForValue().increment(\"count\");\n    log.info(host+\"ip,在\"+format.format(date).toString()+\"访问了网站\");\n}\n\n//定时任务，每天晚上22点，删除今天的浏览数据\n@Scheduled(cron = \"0 0 22 * * ?\")\npublic void updateAudience(){\n    List<Audience> audience = redisTemplate.opsForList().range(\"audience\", 0, -1);\n    //清楚缓存\n    redisTemplate.delete(\"audience\");\n    //完成数据库更新\n    audienceService.updateAudience(audience);\n    //获取总浏览数\n    Integer count = (Integer) redisTemplate.opsForValue().get(\"count\");\n    log.info(\"完成浏览记录的更新\");\n    //发送通知邮件\n    StringBuilder stringBuilder = new StringBuilder();\n    stringBuilder.append(\"今日的访问ip:\");\n    stringBuilder.append(\"<BR/>\");\n    audience.forEach(temp -> {\n        stringBuilder.append(temp.getIp());\n        //换行\n        stringBuilder.append(\"<BR/>\");\n    });\n    stringBuilder.append(\"今天共\"+audience.size()+\"人浏览你的博客,目前的总浏览数为\"+count);\n    //mailUtils.sendMail(stringBuilder.toString(),\"今日浏览数据\");\n    mailUtils.sendToManagers(stringBuilder.toString(),\"今日浏览数据\");\n\n}\n~~~\n\n### 20.3 端口更新\n\n由于阿里云的端口限制，邮件发送端口25号端口默认被ban，可以选择提交申请开放25号端口，但是看了别人的博客，好像都是建议换端口，我这里直接换成465端口，用于发送邮件，注意，端口的选择不是所有都可以的，只有固定几个端口才可以选择，具体可以自己百度，上述代码已经更新，功能测试通过。\n\n参考博客：https://blog.csdn.net/zahngjialiang/article/details/79184088?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-79184088-blog-119746188.235%5Ev36%5Epc_relevant_anti_vip&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-79184088-blog-119746188.235%5Ev36%5Epc_relevant_anti_vip&utm_relevant_index=3', '博客功能更新', 1, 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/31/69e314a15eb84161ab3cc64d6c460426.png', '1', '0', 36, '0', 1, '2023-05-31 14:15:43', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (24, '6-7Vue学习日记', '## 11. 6/7日总结\n\n### 11.1 非单文件组件\n\nVue中使用组件的三大步骤：\n\n1.定义组件(创建组件)\n\n2.注册组件\n\n3.使用组件(写组件标签)\n\n\n\n如何定义一个组件？\n\n使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；\n\n1.el不要写 ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。\n\n2.data必须写成函数———— 避免组件被复用时，数据存在引用关系。\n\n3.const school = Vue.extend(options) 可简写为：const school = options\n\n备注：使用template可以配置组件结构。\n\n\n\n如何注册组件？\n\n1.局部注册：靠new Vue的时候传入components选项\n\n2.全局注册：靠Vue.component(\'组件名\',组件)\n\n\n\n编写组件标签：\n\n<school></school>\n\n### 11.2 VueComponent\n\n1.组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。\n\n2.我们只需要写<school/>或<school></school>，Vue解析时会帮我们创建school组件的实例对象，\n\n   即Vue帮我们执行的：new VueComponent(options)。\n\n3.特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！\n\n4.关于this指向：\n\n(1).组件配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是			VueComponent实例对象。\n\n(2).new Vue(options)配置中：data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是Vue实例对象。\n\n5.VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象), Vue的实例对象，以后简称vm。\n\n### 11.3 原型对象复用\n\n1.一个重要的内置关系：VueComponent.prototype.__proto__ === Vue.prototype\n\n2.为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。（类似于java的继承）\n\n### 11.4 代码练习\n\n~~~html\n<body>\n    <div id=\"root\">\n        <hr>\n        <cc></cc>\n        <hr>\n        <all></all>\n    </div>\n    <div id=\"roo1\">\n        <all></all>\n    </div>\n    <script>\n\n        const child = Vue.extend({\n            template:`\n            <div>\n                <br>\n                <h1>hello</h1>\n                <br>\n            </div>\n            `\n        })\n\n        const cc = Vue.extend({\n            template:`\n                <div>\n                    <child></child>\n                    name<h1>{{name}}</h1>\n                    age<h2>{{age}}</h2>\n                    <button @click=\"add\">+1</button>    \n                </div>\n            `,\n            data() {\n                return {\n                    name:\"cc\",\n                    age:24\n                }\n            },\n            methods: {\n                add(){\n                    this.age++;\n                }\n            },\n            components:{\n                child\n            }\n        })\n\n        const all = Vue.extend({\n            template:`\n            <div>\n                <br>\n                <h1>hello</h1>\n                <br>\n            </div>\n            `\n        })\n\n        Vue.component(\'all\',all);\n\n        new Vue({\n            el:\"#root\",\n            components:{\n                cc\n            }\n        })   \n    </script>\n</body>\n~~~\n\n', 'Vue学习日记', 4, 'http://ru8h77emb.hn-bkt.clouddn.com/2023/06/07/5a075de90b004934a298c2b348312f54.png', '1', '0', 7, '0', 1, '2023-06-07 19:43:51', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (25, '6-9VUE学习日志', '## 12. 6/9日总结\n\n### 12.1 单文件组件\n\n单文件组件和非单文件组件的差别就是，是否在一个文件中编写多个组件，单文件组件保证一个文件中只包含一个组件，并把文件格式命名为vue文件，使用<v加tab键可以快捷生成模板代码\n\n**school组件**\n\n~~~vue\n<template>\n	<div class=\"demo\">\n		<h2>学校名称：{{name}}</h2>\n		<h2>学校地址：{{address}}</h2>\n		<button @click=\"showName\">点我提示学校名</button>	\n	</div>\n</template>\n\n<script>\n	 export default {\n        //不可以写el表达式\n        //定义组件名，要大写符合规范\n		name:\'School\',\n		data(){\n            //返回数据要写成函数的形式\n			return {\n				name:\'尚硅谷\',\n				address:\'北京昌平\'\n			}\n		},\n		methods: {\n			showName(){\n				alert(this.name)\n			}\n		},\n	}\n</script>\n\n<style>\n	.demo{\n		background-color: orange;\n	}\n</style>\n~~~\n\n一个标准的vue文件包含三部分，模板部分template（一定需要一个外层标签），交互部分script，样式部分style\n\n**student组件**\n\n~~~vue\n<template>\n	<div>\n		<h2>学生姓名：{{name}}</h2>\n		<h2>学生年龄：{{age}}</h2>\n	</div>\n</template>\n\n<script>\n	 export default {\n		name:\'Student\',\n		data(){\n			return {\n				name:\'张三\',\n				age:18\n			}\n		}\n	}\n</script>\n~~~\n\n**app顶层父组件**\n\n~~~vue\n<template>\n	<div>\n		<School></School>\n		<Student></Student>\n	</div>\n</template>\n\n<script>\n	//引入组件\n	import School from \'./School.vue\'\n	import Student from \'./Student.vue\'\n\n	export default {\n		name:\'App\',\n		components:{\n			School,\n			Student\n		}\n	}\n</script>\n\n~~~\n\n**编写主程序入口**（后续解释，参考vue脚手架）\n\n~~~js\nimport App from \'./App.vue\'\n\nnew Vue({\n	el:\'#root\',\n	template:`<App></App>`,\n	components:{App},\n})\n~~~\n\n### 12.2 vue-cli脚手架\n\n安装脚手架与使用\n\n~~~node\n//默认安装脚手架3\nnpm install -g @vue/cli\n \n//安装脚手架2\nnpm install -g @vue/cli-init\n \n//脚手架2创建项目\nvue init webpack my-project\n \n//脚手架3创建项目\nvue create my-project\n~~~\n\n文件目录介绍\n\n~~~\n├── node_modules \n├── public\n│   ├── favicon.ico: 页签图标\n│   └── index.html: 主页面\n├── src\n│   ├── assets: 存放静态资源\n│   │   └── logo.png\n│   │── component: 存放组件\n│   │   └── HelloWorld.vue\n│   │── App.vue: 汇总所有组件\n│   │── main.js: 入口文件\n├── .gitignore: git版本管制忽略的配置\n├── babel.config.js: babel的配置文件\n├── package.json: 应用包配置文件 \n├── README.md: 应用描述文件\n├── package-lock.json：包版本控制文件\n~~~\n\nvue脚手架很多规则都是约定俗成的，比如程序入口是main.js，当然你也可以改变他的结构，创建vue.config.js就可以自定义配置。\n\n### 12.3 render函数\n\n**vue-cli脚手架main.js**\n\n~~~js\n/* \n	该文件是整个项目的入口文件\n*/\n//引入Vue\nimport Vue from \'vue\'\n//引入App组件，它是所有组件的父组件\nimport App from \'./App.vue\'\n//关闭vue的生产提示\nVue.config.productionTip = false\n\n//创建Vue实例对象---vm，并完成组件的挂载，为id为app的标签服务\nnew Vue({\n  //render函数完成了这个功能：将App组件放入容器中\n  render: h => h(App),\n}).$mount(\'#app\')\n\n~~~\n\n### 12.4 ref属性\n\n1. 被用来给元素或子组件注册引用信息（id的替代者）\n2. 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）\n3. 使用方式：\n   1. 打标识：```<h1 ref=\"xxx\">.....</h1>``` 或 ```<School ref=\"xxx\"></School>```\n   2. 获取：```this.$refs.xxx```\n\n~~~vue\n<template>\n	<div>\n		<h1 v-text=\"msg\" ref=\"title\"></h1>\n		<button ref=\"btn\" @click=\"showDOM\">点我输出上方的DOM元素</button>\n		<School ref=\"sch\"/>\n	</div>\n</template>\n\n<script>\n	//引入School组件\n	import School from \'./components/School\'\n\n	export default {\n		name:\'App\',\n		components:{School},\n		data() {\n			return {\n				msg:\'欢迎学习Vue！\'\n			}\n		},\n		methods: {\n			showDOM(){\n				console.log(this.$refs.title) //真实DOM元素\n				console.log(this.$refs.btn) //真实DOM元素\n				console.log(this.$refs.sch) //School组件的实例对象（vc）\n			}\n		},\n	}\n</script>\n\n~~~\n\n### 12.5 props配置\n\n1. 功能：让组件接收外部传过来的数据，实现组件与数据的分离，套用组件，自定义数据\n\n2. 传递数据：```<Student name=\"李四\" sex=\"女\" :age=\"18\"/>```\n\n3. 接收数据：\n\n   1. 第一种方式（只接收）：```props:[\'name\'] ```\n\n   2. 第二种方式（限制类型）：```props:{name:String}```\n\n   3. 第三种方式（限制类型、限制必要性、指定默认值）：\n\n      ```js\n      props:{\n      	name:{\n      	type:String, //类型\n      	required:true, //必要性\n      	default:\'老王\' //默认值\n      	}\n      }\n      ```\n\n   > 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。类似于计算属性computed，在外面再套一层数据\n\n~~~vue\n<template>\n	<div>\n		<h1>{{msg}}</h1>\n		<h2>学生姓名：{{name}}</h2>\n		<h2>学生性别：{{sex}}</h2>\n		<h2>学生年龄：{{myAge+1}}</h2>\n		<button @click=\"updateAge\">尝试修改收到的年龄</button>\n	</div>\n</template>\n\n<script>\n	export default {\n		name:\'Student\',\n		data() {\n			console.log(this)\n			return {\n				msg:\'我是一个尚硅谷的学生\',\n				myAge:this.age\n			}\n		},\n		methods: {\n			updateAge(){\n				this.myAge++\n			}\n		},\n		//简单声明接收\n		// props:[\'name\',\'age\',\'sex\'] \n\n		//接收的同时对数据进行类型限制\n		/* props:{\n			name:String,\n			age:Number,\n			sex:String\n		} */\n\n		//接收的同时对数据：进行类型限制+默认值的指定+必要性的限制\n		props:{\n			name:{\n				type:String, //name的类型是字符串\n				required:true, //name是必要的\n			},\n			age:{\n				type:Number,\n				default:99 //默认值\n			},\n			sex:{\n				type:String,\n				required:true\n			}\n		}\n	}\n</script>\n~~~', 'vue日志', 4, '', '1', '0', 0, '0', 1, '2023-06-10 20:47:46', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (26, '6-10VUE学习日志', '## 13. 6/10日总结\n\n### 13.1maxin混入\n\n1. 功能：可以把多个组件共用的配置提取成一个混入对象\n\n2. 使用方式：\n\n   第一步定义混合：maxin.js\n\n   ```js\n   export const hunhe = {\n   	methods: {\n   		showName(){\n   			alert(this.name)\n   		}\n   	},\n   	mounted() {\n   		console.log(\'你好啊！\')\n   	},\n   }\n   export const hunhe2 = {\n   	data() {\n   		return {\n   			x:100,\n   			y:200\n   		}\n   	},\n   }\n   \n   ```\n\n   第二布引入混入：\n\n   ​	引入：import {hunhe,hunhe2} from \'./mixin\'\n\n   第二步使用混入：\n\n   ​	全局混入：```Vue.mixin(xxx)```\n   ​	局部混入：```mixins:[\'xxx\']	```\n\n   **局部使用，单文件组件**\n\n   ~~~vue\n   <template>\n   	<div>\n   		<h2 @click=\"showName\">学生姓名：{{name}}</h2>\n   		<h2>学生性别：{{sex}}</h2>\n   	</div>\n   </template>\n   \n   <script>\n   	// import {hunhe,hunhe2} from \'../mixin\'\n   \n   	export default {\n   		name:\'Student\',\n   		data() {\n   			return {\n   				name:\'张三\',\n   				sex:\'男\'\n   			}\n   		},\n   		// mixins:[hunhe,hunhe2]\n   	}\n   </script>\n   ~~~\n\n   **全局使用，项目入口文件**\n\n   ~~~js\n   //引入Vue\n   import Vue from \'vue\'\n   //引入App\n   import App from \'./App.vue\'\n   import {hunhe,hunhe2} from \'./mixin\'\n   //关闭Vue的生产提示\n   Vue.config.productionTip = false\n   \n   Vue.mixin(hunhe)\n   Vue.mixin(hunhe2)\n   \n   \n   //创建vm\n   new Vue({\n   	el:\'#app\',\n   	render: h => h(App)\n   })\n   ~~~\n\n   需要注意的是，当全局使用的时候，默认全局的vm和vc对象都会使用\n\n### 13.2 src插件\n\n   1. 功能：用于增强Vue\n\n   2. 本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。\n\n   3. 定义插件：plugins.js\n\n      ```js\n      export default {\n      	install(Vue,x,y,z){\n      		console.log(x,y,z)\n      		//全局过滤器\n      		Vue.filter(\'mySlice\',function(value){\n      			return value.slice(0,4)\n      		})\n      \n      		//定义全局指令\n      		Vue.directive(\'fbind\',{\n      			//指令与元素成功绑定时（一上来）\n      			bind(element,binding){\n      				element.value = binding.value\n      			},\n      			//指令所在元素被插入页面时\n      			inserted(element,binding){\n      				element.focus()\n      			},\n      			//指令所在的模板被重新解析时\n      			update(element,binding){\n      				element.value = binding.value\n      			}\n      		})\n      \n      		//定义混入\n      		Vue.mixin({\n      			data() {\n      				return {\n      					x:100,\n      					y:200\n      				}\n      			},\n      		})\n      \n      		//给Vue原型上添加一个方法（vm和vc就都能用了）\n      		Vue.prototype.hello = ()=>{alert(\'你好啊\')}\n      	}\n      }\n      ```\n\n   4. 使用插件：```Vue.use()```\n\n      **main.js**\n\n      ~~~js\n      //引入Vue\n      import Vue from \'vue\'\n      //引入App\n      import App from \'./App.vue\'\n      //引入插件\n      import plugins from \'./plugins\'\n      //关闭Vue的生产提示\n      Vue.config.productionTip = false\n      \n      //应用（使用）插件\n      Vue.use(plugins,1,2,3)\n      //创建vm\n      new Vue({\n      	el:\'#app\',\n      	render: h => h(App)\n      })\n      ~~~\n\n### 13.3 scoped样式\n\n使用场景：项目使用多个单文件组件，引入多个样式文件，可能会出现标签的类名重复的情况，导致样式被覆盖，可以使用scoped属性解决这个问题，添加这个属性之后，vue文件中的样式只为该文件的模板服务，底层是在这基础上加了一个标签，然后加了样式标签进行绑定\n\n~~~vue\n<template>\n	<div class=\"demo\">\n		<h2 class=\"title\">学校名称：{{name}}</h2>\n		<h2>学校地址：{{address}}</h2>\n	</div>\n</template>\n\n<script>\n	export default {\n		name:\'School\',\n		data() {\n			return {\n				name:\'尚硅谷atguigu\',\n				address:\'北京\',\n			}\n		}\n	}\n</script>\n\n<style scoped>\n	.demo{\n		background-color: skyblue;\n	}\n</style>\n~~~\n\n', 'vue日志', 4, '', '1', '0', 3, '0', 1, '2023-06-10 20:48:34', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (27, '6-11VUE学习日志', '## 14. 6/11日总结\n\n### 14.1 完成一个todoList案例\n\n**主要技术总结**\n\n1.使用vue脚手架进行快速开发，并使用单组件模式\n\n2.把整个大功能拆成4个小模块，交给App父模块管理\n\n3.父把数据传向子使用props配置数据\n\n4.子把数据回传给父使用props配置函数\n\n5.以下文件仅展示模板代码和交互代码，不展示样式代码，体验地址 http://8.142.134.180:8080\n\n**主要代码示例**\n\n**APP.vue**\n\n~~~vue\n<template>\n  <div id=\"app\">\n    <MyHeader :addTodo=\"addTodo\"/>\n    <MyList :todos=\"todos\" :handleStatus=\"handleStatus\" :deleteTodo=\"deleteTodo\"/>\n    <MyFooter :todos=\"todos\" :checkAll=\"checkAll\"/>\n  </div>\n</template>\n\n<script>\nimport MyHeader from \'./components/MyHeader.vue\'\nimport MyFooter from \'./components/MyFooter.vue\'\nimport MyList from \'./components/MyList.vue\'\n\nexport default {\n  name: \'App\',\n  components: {\n    MyHeader,\n    MyFooter,\n    MyList\n  },\n  data() {\n    return {\n      todos:[\n          {id:\"001\",name:\"抽烟\",done:true},\n          {id:\"002\",name:\"喝酒\",done:true},\n          {id:\"003\",name:\"纹身\",done:false},\n          {id:\"004\",name:\"染发\",done:true},\n          {id:\"005\",name:\"耳洞\",done:true}\n      ]\n    }\n  },\n  methods: {\n    addTodo(todoObj){\n      this.todos.unshift(todoObj);\n    },\n    handleStatus(id){\n      this.todos.forEach(todo => {\n        if(todo.id === id){\n          todo.done = !todo.done;\n        }\n      });\n    },\n    deleteTodo(id){\n      //console.log(id);\n      this.todos = this.todos.filter( (todo) => {\n        return todo.id !== id;\n      });\n      //console.log(this.todos);\n    },\n    checkAll(value){\n      this.todos.forEach(todo => todo.done = value);\n    }\n  },\n}\n~~~\n\n**MyHeader.vue**\n\n~~~vue\n<template>\n    <div class=\"todo-header\">\n		<input type=\"text\" placeholder=\"请输入你的任务名称，按回车键确认\" @keyup.enter=\"add\"/>\n	</div>\n</template>\n\n<script>\n    import {nanoid} from \'nanoid\'\n\n    export default {\n        name:\'MyHeader\',\n        props:[\'addTodo\'],\n        methods: {\n            add(event){\n                const addObj = {\n                    id:nanoid(),\n                    name:event.target.value,\n                    done:false\n                }\n                //console.log(addObj);\n                //alert(addObj);\n                this.addTodo(addObj);\n                event.target.value = \'\';\n            }\n        },\n      \n    }\n</script>\n~~~\n\n**Mylist.vue**\n\n~~~vue\n<template>\n  <ul class=\"todo-main\">\n		<MyItem \n			v-for=\"todoObj in todos\"\n			:key=\"todoObj.id\" \n			:todo=\"todoObj\" \n			:handleStatus=\"handleStatus\"\n			:deleteTodo=\"deleteTodo\"\n		/>\n	</ul>\n</template>\n\n<script>\n    import MyItem from \'./MyItem.vue\'\n\n    export default {\n        name:\'MyList\',\n        components:{\n            MyItem\n        },\n        props:[\'todos\',\'handleStatus\',\'deleteTodo\']\n    }\n</script>\n~~~\n\n**MyItem.vue**\n\n~~~vue\n<template>\n    <li>\n		<label>\n			<input type=\"checkbox\" :checked=\"todo.done\" @change=\"handleCheck(todo.id)\"/>\n			<!-- 如下代码也能实现功能，但是不太推荐，因为有点违反原则，因为修改了props -->\n			<!-- <input type=\"checkbox\" v-model=\"todo.done\"/> -->\n			<span>{{todo.name}}</span>\n		</label>\n		<button class=\"btn btn-danger\" @click=\"deleteOne(todo.id)\">删除</button>\n	</li>\n</template>\n\n<script>\n    export default {\n        name:\'MyItem\',  \n        props:[\'todo\',\'handleStatus\',\'deleteTodo\'],\n        methods: {\n            handleCheck(id){\n                this.handleStatus(id);\n            },\n            deleteOne(id){\n                this.deleteTodo(id);\n            }\n        },  \n    }\n</script>\n~~~\n\n**MyFooter.vue**\n\n~~~vue\n<template>\n    <div class=\"todo-footer\" v-show=\"total\">\n		<label>\n			<!-- <input type=\"checkbox\" :checked=\"isAll\" @change=\"checkAll\"/> -->\n			<input type=\"checkbox\" v-model=\"isAll\"/>\n		</label>\n		<span>\n			<span>已完成{{doneTotal}}</span> / 全部{{total}}\n		</span>\n		<button class=\"btn btn-danger\" @click=\"clearAll\">清除已完成任务</button>\n	</div>\n</template>\n\n<script>\n    export default {\n        name:\'MyFooter\',\n        props:[\'todos\',\'checkAll\'],\n        computed:{\n            doneTotal(){\n                return this.todos.reduce((pre,todo) => {\n                    return pre + (todo.done ? 1 : 0);\n                },0)\n            },\n            total(){\n                return this.todos.length;\n            },\n            isAll:{\n                get(){\n                    return this.doneTotal === this.total && this.total > 0;\n                },\n                set(value){\n                    this.checkAll(value);\n                }\n            }\n        },\n        methods: {\n            clearAll(){\n                this.checkAll(false);\n            }\n        },\n\n    }\n</script>\n~~~\n\n### 14.2 浏览器本地存储\n\n1. 存储内容大小一般支持5MB左右（不同浏览器可能还不一样）\n\n2. 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。\n\n3. 相关API：\n\n   1. `xxxxxStorage.setItem(\'key\', \'value\');` 			该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。\n\n   2. `xxxxxStorage.getItem(\'person\');`\n\n      ​		该方法接受一个键名作为参数，返回键名对应的值。\n\n   3. `xxxxxStorage.removeItem(\'key\');`\n\n      ​		该方法接受一个键名作为参数，并把该键名从存储中删除。\n\n   4. `xxxxxStorage.clear()`\n\n      ​		该方法会清空存储中的所有数据。\n\n4. 备注：\n\n   1. SessionStorage存储的内容会随着浏览器窗口关闭而消失。\n\n   2. LocalStorage存储的内容，需要手动清除才会消失。\n\n   3. `xxxxxStorage.getItem(xxx)`如果xxx对应的value获取不到，那么getItem的返回值是null。\n\n   4. `JSON.parse(null)`的结果依然是null\n\n**本地存储**\n\n~~~html\n<html>\n	<head>\n		<meta charset=\"UTF-8\" />\n		<title>localStorage</title>\n	</head>\n	<body>\n		<h2>localStorage</h2>\n		<button onclick=\"saveData()\">点我保存一个数据</button>\n		<button onclick=\"readData()\">点我读取一个数据</button>\n		<button onclick=\"deleteData()\">点我删除一个数据</button>\n		<button onclick=\"deleteAllData()\">点我清空一个数据</button>\n\n		<script type=\"text/javascript\" >\n			let p = {name:\'张三\',age:18}\n\n			function saveData(){\n				localStorage.setItem(\'msg\',\'hello!!!\')\n				localStorage.setItem(\'msg2\',666)\n				localStorage.setItem(\'person\',JSON.stringify(p))\n			}\n			function readData(){\n				console.log(localStorage.getItem(\'msg\'))\n				console.log(localStorage.getItem(\'msg2\'))\n\n				const result = localStorage.getItem(\'person\')\n				console.log(JSON.parse(result))\n\n				// console.log(localStorage.getItem(\'msg3\'))\n			}\n			function deleteData(){\n				localStorage.removeItem(\'msg2\')\n			}\n			function deleteAllData(){\n				localStorage.clear()\n			}\n		</script>\n	</body>\n</html>\n~~~\n\n**会话存储**\n\n~~~html\n<html>\n	<head>\n		<meta charset=\"UTF-8\" />\n		<title>sessionStorage</title>\n	</head>\n	<body>\n		<h2>sessionStorage</h2>\n		<button onclick=\"saveData()\">点我保存一个数据</button>\n		<button onclick=\"readData()\">点我读取一个数据</button>\n		<button onclick=\"deleteData()\">点我删除一个数据</button>\n		<button onclick=\"deleteAllData()\">点我清空一个数据</button>\n\n		<script type=\"text/javascript\" >\n			let p = {name:\'张三\',age:18}\n\n			function saveData(){\n				sessionStorage.setItem(\'msg\',\'hello!!!\')\n				sessionStorage.setItem(\'msg2\',666)\n				sessionStorage.setItem(\'person\',JSON.stringify(p))\n			}\n			function readData(){\n				console.log(sessionStorage.getItem(\'msg\'))\n				console.log(sessionStorage.getItem(\'msg2\'))\n\n				const result = sessionStorage.getItem(\'person\')\n				console.log(JSON.parse(result))\n\n				// console.log(sessionStorage.getItem(\'msg3\'))\n			}\n			function deleteData(){\n				sessionStorage.removeItem(\'msg2\')\n			}\n			function deleteAllData(){\n				sessionStorage.clear()\n			}\n		</script>\n	</body>\n</html>\n~~~\n\n### 14.3 完成todolist案例加入本地存储功能\n\n1.主要修改了App.vue文件，加入本地缓存功能和深度监听todos数据，体验地址 http://8.142.134.180:8080\n\n~~~vue\n<template>\n  <div id=\"app\">\n    <MyHeader :addTodo=\"addTodo\"/>\n    <MyList :todos=\"todos\" :handleStatus=\"handleStatus\" :deleteTodo=\"deleteTodo\"/>\n    <MyFooter :todos=\"todos\" :checkAll=\"checkAll\"/>\n  </div>\n</template>\n\n<script>\nimport MyHeader from \'./components/MyHeader.vue\'\nimport MyFooter from \'./components/MyFooter.vue\'\nimport MyList from \'./components/MyList.vue\'\n\nexport default {\n  name: \'App\',\n  components: {\n    MyHeader,\n    MyFooter,\n    MyList\n  },\n  data() {\n    return {\n      todos:JSON.parse(localStorage.getItem(\'todos\')) || []\n    }\n  },\n  methods: {\n    addTodo(todoObj){\n      this.todos.unshift(todoObj);\n    },\n    handleStatus(id){\n      this.todos.forEach(todo => {\n        if(todo.id === id){\n          todo.done = !todo.done;\n        }\n      });\n    },\n    deleteTodo(id){\n      //console.log(id);\n      this.todos = this.todos.filter( (todo) => {\n        return todo.id !== id;\n      });\n      //console.log(this.todos);\n    },\n    checkAll(value){\n      this.todos.forEach(todo => todo.done = value);\n    }\n  },\n  watch:{\n    todos:{\n      deep:true,\n      handler(value){\n        localStorage.setItem(\'todos\',JSON.stringify(value));\n      }\n    }\n  }\n}\n</script>\n~~~\n\n', '完成了一个vue小组件，使用的是vue-cli脚手架快速开发，可以在线体验', 4, '', '1', '0', 3, '0', 1, '2023-06-11 21:21:06', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (28, 'SpringCloud总结-1', '# 									SpringCloud\n\n## 1.功能介绍\n\n- **服务间通信**：包括服务治理、负载均衡、服务间调用；\n\n- **服务容错和异常排查**：包括流量整形、降级熔断、调用链追踪；\n\n- **分布式能力建设**：包括微服务网关、分布式事务、消息驱动、分布式配置中心。\n\n## 2.Eureka服务注册中心\n\nSpring Cloud Eureka 是Netflix 开发的注册发现组件，本身是一个基于 REST 的服务。提供注册与发现，同时还提供了负载均衡、故障转移等能力。\n\n![image-20230611213126232](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230611213126232.png)\n\n### 2.1配置Eureka注册中心\n\n**引入依赖**（引入依赖后，自动进行注册中心的配置，无法再写启动注解，只需要编写配置文件和引入依赖）\n\n~~~xml\n <!-- 服务注册发现Eureka-->\n<dependency>         \n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n~~~\n\n**配置文件**\n\n~~~yml\nserver:\n port: 7001\neureka:\n instance:\n    # eureka服务端的实例名字\n   hostname: localhost\n client:\n    # 表示是否将自己注册到Eureka Server\n   register-with-eureka: false\n    # 表示是否从Eureka Server获取注册的服务信息\n   fetch-registry: false\n    # 设置与 Eureka server交互的地址查询服务和注册服务都需要依赖这个地址\n   service-url:\n     defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n~~~\n\n### 2.2 配置中心介绍\n\n![image-20230611213730201](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230611213730201.png)\n\n- Current time：当前的系统时间\n\n- Uptime：已经运行了多少时间\n\n- Renews threshold： 每分钟最少续约数，Eureka Server 期望每分钟收到客户端实例续约的总数。\n\n- Renews (last min)： 最后一分钟的续约数量（不含当前，1分钟更新一次），Eureka Server\n\n  ​									最后 1 分钟收到客户端实例续约的总数\n\n![image-20230611213834115](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230611213834115.png)\n\nApplication：服务名称。配置的spring.application.name属性，即使配置了小写，也会全部转换成大写，最好直						接大写，以免后续远程调用出错\n\nAvailability Zones：实例的数量\n\nStatus：实例的状态 + eureka.instance.instance‐id的值。\n\n**实例的状态分为UP、DOWN、STARTING、OUT_OF_SERVICE、UNKNOWN.**\n\nUP： 服务正常运行，特殊情况当进入自我保护模式，所有的服务依然是UP状态，所以需要\n\n做好熔断重试等容错机制应对灾难性网络出错情况\n\nOUT_OF_SERVICE : 不再提供服务，其他的Eureka Client将调用不到该服务，一般有人为的调用接口设置的，如：									强制下线。\n\nUNKNOWN： 未知状态\n\nSTARTING ： 表示服务正在启动中\n\nDOWN： 表示服务已经宕机，无法继续提供服务\n\n![image-20230611214219401](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230611214219401.png)\n\ntotal-avail-memory : 总共可用的内存\n\nnum-of-cpus : CPU的个数\n\ncurrent-memory-usage : 当前已经使用内存的百分比\n\nserver-uptime : 服务启动时间\n\n### 2.3 客户端配置（服务生产者和服务消费者同理）\n\n**引入依赖**\n\n~~~xml\n<!-- 引入Eureka client依赖   -->\n<dependency>          \n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n~~~\n\n**配置文件**\n\n~~~yml\nserver:\n port: 8001\neureka:\n client:\n   service-url:\n      # Eureka server 地址\n     defaultZone: http://localhost:7001/eureka/\nspring:\n application:\n    # 设置应用名词\n   name: CLOUD-PAYMENT-PROVIDER\n~~~\n\n### 2.4 服务剔除和服务自保\n\n服务剔除把服务节点果断剔除，即使你的续约请求晚了一步也毫不留情，招式凌厉，重在当断则断，忍痛割爱。\n\n服务自保把当前所有节点保留，一个都不能少，绝不放弃任何队友。心法的指导思想是，即便主动删除，也许并不能解决问题，且放之任之，以不变应万变。\n\n在实际应用里，并不是所有无心跳的服务都不可用，也许因为短暂的网络抖动等原因，导致服务节点与注册中心之间续约不上，但服务节点之间的调用还是属于可用状态，这时如果强行剔除服务节点，可能会造成大范围的业务停滞。这是服务自保的总闸，以下配置将强制关闭服务自保，即便上面的自动开关被触发，也不能开启自保功能。\n\n~~~yml\n# 参数来关闭保护机制，以确保注册中心可以将不可用的实例正确剔除，默认为true。\neureka.server.enable-self-preservation=true；\n~~~\n\n### 2.5 微服务信息完善\n\n![image-20230611215147857](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230611215147857.png)\n\nSpringCloud体系里的，服务实体向eureka注册时，注册名默认是IP名:应用名:应用端口名。\n\n**引入依赖**\n\n~~~xml\n<!-- actuator监控信息完善 -->\n<dependency>  \n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n~~~\n\n配置文件\n\n~~~yml\neureka:                        \n instance:\n    #根据需要自己起名字\n   instance-id: springcloud-dept-8001\n~~~\n\n### 2.6 注册中心高可用\n\n**配置文件**\n\n~~~yml\n#修改7001主机yml文件\nserver:\n port: 7001\neureka:\n instance:\n    # eureka服务端的实例名字\n   hostname: localhost\n client:\n    #表 示是否将自己注册到Eureka Server\n   register-with-eureka: false\n    # 表示是否从Eureka Server获取注册的服务信息\n   fetch-registry: false\n    # 设置与 Eureka server交互的地址查询服务和注册服务都需要依赖这个地址,互相注册\n   service-url:\n     defaultZone: http://eureka7002.com:7002/eureka/\n~~~\n\n**其他服务注册到注册中心**\n\n~~~yml\neureka:\n client:\n   service-url:\n     defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka\n~~~\n\n## 3. 负载均衡\n\n### 3.1 服务端负载均衡\n\n在服务集群内设置一个中心化负载均衡器，比如Nginx。发起服务间调用的时候，服务请求并不直接发向目标服务器，而是发给这个全局负载均衡器，它再根据配置的负载均衡策略将请求转发到目标服务。\n\n![image-20230612084552883](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230612084552883.png)\n\n优点：服务端负载均衡应用范围非常广，它不依赖于服务发现技术，客户端并不需要拉取完整的服务列表；同时，			发起服务调用的客户端也不用操心该使用什么负载均衡策略。\n\n缺点：网络消耗，复杂度和故障率提升，在QPS超高的时候，性能损耗非常大，降低系统的吞吐量\n\n### 3.2 客户端负载均衡\n\nSpring Cloud Loadbalancer 采用了客户端负载均衡技术，每个发起服务调用的客户端都存有完整的目标服务地址列表，根据配置的负载均衡策略，由客户端自己决定向哪台服务器发起调用。需要满足⼀个前置条件，发起服务调用的客户 端需要获取所有目标服务的地址，这样它才能使用负载均衡规则选取要调用的服务。也就是说，客户端负载均衡技术往往需要依赖服务发现技术来获取服务列表。\n\n### 3.3 OpenFegin\n\n在使用openFeign时，记住一句话：接口+注解\n\n**导入依赖**\n\n~~~xml\n<!-- 引入OpenFeign依赖 -->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starteropenfeign</artifactId>\n</dependency>\n~~~\n\n**配置文件**\n\n~~~yml\neureka:\n client:\n    # 表示是否将自己注册到Eureka Server\n   register-with-eureka: true\n    # 示是否从Eureka Server获取注册的服务信息\n   fetch-registry: true\n    # Eureka Server地址\n   service-url:\n     defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka\n     instance:\n   instance-id: cloud-openfeign-order-consumer\nspring:\n application:\n    # 设置应用名词\n   	name: cloud-openfeign-order-consumer\n server:\n 	port: 80\n~~~\n\n主启动类\n\n~~~java\n/**\n* 主启动类\n*/\n@Slf4j\n@SpringBootApplication\n@EnableFeignClients\npublic class OrderFeignMain80 {\n    public static void main(String[] args) {      \n        SpringApplication.run(OrderFeignMain80.class,args);\n        log.info(\"**************OrderFeignMain80 服务启动成功 **********\");\n   }\n}\n~~~\n\n@EnableEurekaClient 可以不再添加该注解，只要导入了客户端或服务端的依赖就会自动执行相应逻辑\n\n@EnableFeginClients 告诉框架扫描所有使用注解@FeignClient的feign客户端，它又通过@Import导入类FeignClientRegistrar（feign客户端注册器）\n\n配置远程服务接口\n\n~~~java\n/**\n * 支付远程调用Feign接口\n */\n@Component\n@FeignClient(value = \"cloud-payment-provider\")\npublic interface PaymentFeignService {\n   @GetMapping(\"/payment/index\")\n   String index();\n}\n~~~\n\n进行远程服务调用\n\n~~~java\n/**\n* 订单控制层\n*/\n@RestController\n@RequestMapping(\"/order\")\npublic class OrderController {\n    @Autowired\n    private PaymentFeignService\npaymentFeignService;\n    /**\n     * 测试OpenFeign接口调用\n     * @return\n     */\n    @GetMapping(\"/index\")\n    public String get(){\n        return paymentFeignService.index();\n   }\n}\n~~~\n\n### 3.4 日志增强\n\nOpenFeign虽然提供了日志增强功能，但是默认是不显示任何日志的，不过开发者在调试阶段可以自己配置日志的级别。\n\nOpenFeign的日志级别如下：\n\n**NONE**：默认的，不显示任何日志;\n\n**BASIC**：仅记录请求方法、URL、响应状态码及执行时间;\n\n**HEADERS**：除了BASIC中定义的信息之外，还有请求和响应的头信息;\n\n**FULL**：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据。\n\n**配置日志级别**\n\n~~~java\n@Configuration\npublic class OpenFeignConfig{\n    \n    /**\n    * 日志级别定义，这里的logger是feign包里的。\n    */\n    @Bean\n    Logger.Level feignLoggerLevel(){\n        return Logger.Level.FULL;\n   }\n}\n~~~\n\n~~~yml\nlogging:\n   level:\n     com.itbaizhan.service: debug\n~~~\n\n![image-20230612090826486](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230612090826486.png)\n\n### 3.5 超时机制\n\n问题场景\n\n- 服务消费者在调用服务提供者的时候发生了阻塞、等待的情形，这个时候，服务消费者会一直等待下去。\n\n- 在某个峰值时刻，大呈的请求都在同时请求服务消费者，会造成线程的大呈堆积，势必会造成雪崩。\n\n- 利用超时机制来解决这个问题，设置一个超时时间，在这个时间段内，无法完成服务访问，则自动断开连接。\n\n**配置文件**\n\n~~~yml\n# 默认超时时间\nfeign: \n client:   \n  config:     \n   default:       \n    # 连接超时时间       \n    connectTimeout: 2000       \n    # 读取超时时间    \n    readTimeout: 2000\n~~~\n\n### 3.6 服务雪崩\n\n#### 3.6.1 雪崩描述\n\n服务与服务之间的依赖性，故障会传播，造成连锁反应，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。\n\n**雪崩原因**\n\n1.服务提供者不可用（硬件故障、程序bug、缓存击穿、用户大量请求）\n\n2.重试加大流量（用户重试，代码逻辑重试）\n\n3.服务调用者不可用（同步等待造成的资源耗尽）\n\n#### 3.6.2 方案一：服务熔断\n\n熔断就跟保险丝一样，当一个服务请求并发特别大，服务器已经招架不住了，调用错误率飙升，当错误率达到一定阈值后，就将这个服务熔断了。熔断之后，后续的请求就不会再请求服务器了，以减缓服务器的压力。\n\n#### 3.6.3 方案二：服务降级\n\n**两种场景**:\n\n当下游的服务因为某种原因**响应过慢**，下游服务主动停掉一些不太重要的业务释放出服务器资源，增加响应速度！\n\n当下游的服务因为某种原因**不可用**，上游主动调用本地的一些降级逻辑，避免卡顿，迅速返回给用户！\n\n**服务降级 fallback**\n\n概念：服务器繁忙，请稍后重试，不让客户端等待并立即返回一个友好的提示。\n\n**出现服务降级的情况：**\n\n- 程序运行异常超时\n\n- 服务熔断触发服务降级\n\n- 线程池/信号量打满也会导致服务降级\n\n#### 3.6.4 方案三：服务隔离\n\n**什么是线程池隔离**\n\n将用户请求线程和服务执行线程分割开来，同时约定了每个服务最多可用线程数。\n\n**什么是信号量隔离**\n\n小时候我们就知道“红灯停，绿灯行”，跟着交通信号的指示过马路。信号量也是这么一种放行、禁行的开关作用。它和线程池技术一样，控制了服务可以被同时访问的并发数量。\n\n**二者区别**\n\n|  隔离方式  |                        是否支持超时                         |                         是否支持熔断                         |       隔离原理       |             是否是异步调用             |                   资源消耗                   |\n| :--------: | :---------------------------------------------------------: | :----------------------------------------------------------: | :------------------: | :------------------------------------: | :------------------------------------------: |\n| 线程池隔离 |                      支持，可直接返回                       | 支持，当线程池到达maxSize后，再请求会触发fallback接口进行熔断 | 每个服务单独用线程池 | 可以是异步，也可以是同步。看调用的方法 | 大，大量线程的上下文切换，容易造成机器负载高 |\n| 信号量隔离 | 不支持，如果阻塞，只能通过调用协议（如:socket超时才能返回） | 支持，当信号量达到maxConcurrentRequests后。再请求会触发fallback |  通过信号量的计数器  |          同步调用，不支持异步          |               小，只是个计数器               |\n\n#### 3.6.5 方案三：服务限流\n\n限流模式主要是提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。\n\n**注意：**\n\n限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理。\n\n**流量控制**\n\n网关限流：防止大量请求进入系统，Mq实现流量消峰\n\n用户交流限流：提交按钮限制点击频率限制等', 'Eureka+OpenFeign总结', 1, '', '1', '0', 1, '0', 1, '2023-06-12 09:55:13', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (29, 'JAVASE基础总结', '# 									 JavaSE\n\n## 1.流程标签\n\n如果想让break跳出外层循环，可使用java提供的标签功能，使程序跳到指定的位置\n\n```java\nflag:for(int i = 0;i++;i<5){\n        for(int j = 0;j++;j<5){\n            if(i = 1){\n                break flag;\n            }\n        }\n    }\n```\n\n与break语法一样，continue也支持标签，语法一样。不过break是跳出循环，而continue是继续下一次循环。\n\n## 2.字符串函数\n\n如果lastIndexOf()方法中，参数是空字符串，则返回的结果与调用该字符串的length()方法的返回结果相同。\n\n如果想定义多个分隔符，可以使用\"|\"，例如，\",|=\"，表示分割符为\",\"和\"=\"。\n\n常见的字符串函数\n\nchar charAt(int index):\n\nint compareTo(String string):\n\nboolean contains(String string):\n\nboolean startsWith(String string):\n\nboolean endsWith(String string):\n\nString toLowerCase():\n\nString toUpperCase():\n\nboolean equalsIngoreCase(String string):\n\nbyte[] getBytes():\n\nboolean isEmpty():\n\nchar[] toCharArray():\n\nint indexOf(String string):\n\nint lastIndexOf(String string):\n\nString replace(String s1,String s2):\n\nString[] split(String regax):\n\nString subString(int beginIndex):\n\nString trim():\n\nvoid deleteCharAt(int index):\n\n## 3.StirngBuilder\n\nString、StringBuilder、StringBuffer底层都是采用char[]数组，不同的是，String是final修饰的，意为不可变；StringBuffer中所有的方法都有对象锁，意为线程安全的；而StringBuilder则没有上述限制\n\nStringBuilder和StringBuffer默认分配16个单位长度，当拼接字符串的时候，如果数组长度不够，会进行自动扩容，新的长度为原长度x2+2，构建出新的数组，然后再进行值的复制\n\n## 4.IO流\n\n### 4.1try-with-resource语法糖\n\n在java.lang.AutoCloseable接口中包含了一个close方法，该方法用于关闭资源。\n\n只要是实现了java.lang.AutoCloseable接口的对象，都可以使用try-with-resource关闭资源。具体如下述代码\n\n### 4.2流的分类\n\n**按流的方向分类：**\n\n输入流：数据流向是数据源到程序（以InputStream、Reader结尾的流）\n\n输出流：数据流向是程序到目的地（以OutPutStream、Writer结尾的流）\n\n**按处理的数据单元分类：**\n\n字节流：以字节为单位获取数据，命名上以Stream结尾的流一般是字节流，如FileInputStream、\n\nFileOutputStream\n\n字符流：以字符为单位获取数据，命名上以Reader/Writer结尾的流一般是字符流，如\n\nFileReader、FileWriter\n\n**按处理对象不同分类：**\n\n节点流：可以直接从数据源或目的地读写数据，如FileInputStream、FileReader、\n\nDataInputStream等。\n\n处理流：不直接连接到数据源或目的地，是”处理流的流”。通过对其他流的处理提高程序的性能，\n\n如BufferedInputStream、BufferedReader等。处理流也叫包装流。\n\n### 4.3各种流介绍\n\nInputStream/OutputStream：字节流的抽象类。\n\nReader/Writer：字符流的抽象类。\n\nFileInputStream/FileOutputStream：节点流以字节为单位直接操作“文件”。\n\nByteArrayInputStream/ByteArrayOutputStream：节点流以字节为单位直接操作“字节数组对象”。\n\nObjectInputStream/ObjectOutputStream：处理流以字节为单位直接操作“对象”。\n\nDataInputStream/DataOutputStream：处理流以字节为单位直接操作“基本数据类型与字符串类型”。\n\nFileReader/FileWriter：节点流以字符为单位直接操作“文本文件”（注意：只能读写文本文件）。\n\nBufferedReader/BufferedWriter：处理流将Reader/Writer对象进行包装，增加缓存功能，提高读写效率。\n\nBufferedInputStream/BufferedOutputStream：处理流将InputStream/OutputStream对象进行包装，增加缓存																								功能，提高读写效率\n\nInputStreamReader/OutputStreamWriter：处理流将字节流对象转化成字符流对象。\n\nPrintStream：处理流将OutputStream进行包装，可以方便地输出字符，更加灵活。\n\n### 4.4各种流示例\n\n​																				**普通字节流**\n\n~~~java\ntry(FileInputStream fis = new FileInputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档.txt\");\n    FileOutputStream fos = new FileOutputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档														1.txt\")) {\n    //读取到的数据\n    int data;\n    //当读不到数据的时候，返回-1\n    while ((data = fis.read()) != -1){\n        //边读边写\n        fos.write((char)data);\n    }\n    fos.flush();\n} catch (FileNotFoundException e) {\n    throw new RuntimeException(e);\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n~~~\n\n​																		**带缓冲数组的字节流**\n\n~~~java\ntry(FileInputStream fis = new FileInputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档.txt\");\n    FileOutputStream fos = new FileOutputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档														2.txt\")) {\n    //用于接收数据的字节数组\n    byte[] data = new byte[1024];\n    //记录读取的数据数\n    int count;\n    while ((count = fis.read(data)) != -1){\n        //边读边写\n        System.out.println(data);\n        fos.write(data,0,count);\n    }\n    fos.flush();\n} catch (FileNotFoundException e) {\n    throw new RuntimeException(e);\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n~~~\n\n​																		**使用缓冲流的字节流**\n\n~~~java\ntry(FileInputStream fis = new FileInputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档.txt\");\n    FileOutputStream fos = new FileOutputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档														3.txt\");\n    BufferedInputStream bis = new BufferedInputStream(fis);\n    BufferedOutputStream bos = new BufferedOutputStream(fos)) {\n\n    int count = -1;\n    byte[] datas = new byte[1024];\n    while ((count = bis.read(datas)) != -1){\n        System.out.println(datas);\n        bos.write(datas);\n    }\n} catch (FileNotFoundException e) {\n    throw new RuntimeException(e);\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n~~~\n\n​																		**使用转换流的字符流**\n\n~~~java\ntry(FileInputStream fis = new FileInputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档.txt\");\n    FileOutputStream fos = new FileOutputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本文档														4.txt\");\n    InputStreamReader isr = new InputStreamReader(fis);\n    OutputStreamWriter osr = new OutputStreamWriter(fos)) {\n\n    int data = -1;\n    while ((data = isr.read()) != -1){\n        System.out.println(data);\n        osr.write(data);\n    }\n    osr.flush();\n} catch (FileNotFoundException e) {\n    throw new RuntimeException(e);\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n~~~\n\n​															**使用转换流实现键盘输入，屏幕输出**\n\n~~~java\ntry(InputStreamReader inputStreamReader = new InputStreamReader(System.in);\n    OutputStreamWriter outputStreamWriter = new OutputStreamWriter(System.out);\n    BufferedReader reader = new BufferedReader(inputStreamReader);\n    BufferedWriter writer = new BufferedWriter(outputStreamWriter)) {\n\n    String input = reader.readLine();\n    while (!input.equals(\"exit\")){\n        writer.write(input);\n        writer.newLine();\n        writer.flush();\n        input = reader.readLine();\n    }\n} catch (FileNotFoundException e) {\n    throw new RuntimeException(e);\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n~~~\n\n​															**使用转换流实现屏幕输入到文件**\n\n~~~java\ntry(PrintWriter pw = new PrintWriter(new FileOutputStream(\"C:\\\\Users\\\\PC\\\\Desktop\\\\新建文本		文档1.txt\"));\n    InputStreamReader inputStreamReader = new InputStreamReader(System.in);\n    BufferedReader reader = new BufferedReader(inputStreamReader)) {\n\n    String input = reader.readLine();\n    while (!input.equals(\"exit\")){\n        pw.println(input);\n        pw.flush();\n        input = reader.readLine();\n    }\n} catch (FileNotFoundException e) {\n    throw new RuntimeException(e);\n} catch (IOException e) {\n    throw new RuntimeException(e);\n}\n~~~\n\n​																			**数据流使用**\n\n~~~java\n//创建数据输出流对象与文件字节输出流对象\ntry(DataOutputStream dos = new DataOutputStream(new FileOutputStream(\"d:/data\"));\n    //创建数据输入流对象与文件字节输入流对象\n    DataInputStream dis = new DataInputStream(new FileInputStream(\"d:/data\"))){\n    //将如下数据写入到文件中\n    dos.writeChar(\'a\');\n    dos.writeInt(10);\n    dos.writeDouble(Math.random());\n    dos.writeBoolean(true);\n    dos.writeUTF(\"北京尚学堂\");\n    //手动刷新缓冲区：将流中数据写入到文件\n\n    dos.flush();\n    //直接读取数据：读取的顺序要与写入的顺序一致，否则不能正确读取数据。\n    System.out.println(\"char: \" + dis.readChar());\n    System.out.println(\"int: \" + dis.readInt());\n    System.out.println(\"double: \" + dis.readDouble());\n    System.out.println(\"boolean: \" + dis.readBoolean());\n    System.out.println(\"String: \" + dis.readUTF());\n}catch(IOException e){\n    e.printStackTrace();\n}\n~~~\n\n​																			**对象流使用**\n\n~~~java\ntry(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"d:/data2\"));\n    //创建对象输入流对象与文件字节输入流对象\n    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"d:/data2\"))){\n\n    //将如下数据写入到文件中\n    oos.writeInt(10);\n    oos.writeDouble(Math.random());\n    oos.writeChar(\'a\');\n    oos.writeBoolean(true);\n    oos.writeUTF(\"你好Oldlu\");\n    oos.flush();\n\n    //必须要按照写入的顺序读取数据\n    System.out.println(\"int: \"+ois.readInt());\n    System.out.println(\"double: \"+ois.readDouble());\n    System.out.println(\"char: \"+ois.readChar());\n    System.out.println(\"boolean: \"+ois.readBoolean());\n    System.out.println(\"String: \"+ois.readUTF());\n}catch(IOException e){\n    e.printStackTrace();\n}\n~~~\n\n### 4.5缓冲流优势详解\n\n![image-20230522102635541](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230522102635541.png)\n\n### 4.6文件复制\n\n~~~java\n//完成源目录到目标目录的复制\npublic void copy(String src,String desc){\n    File srcFile = new File(src);\n    if(srcFile == null){\n        throw new RuntimeException(\"目标文件为空\"+src);\n    }\n    File descFile = new File(desc);\n    //目标文件是目录，进行递归\n    if(srcFile.isDirectory()){\n        //创建目录\n        descFile.mkdir();\n        //获取目录中的文件列表\n        File[] files = srcFile.listFiles();\n        //遍历文件列表\n        for (File file : files) {\n            copy(file.getAbsolutePath(), file.getAbsolutePath().replace(src,desc));\n        }\n    }else {\n        //目标是文件，直接复制\n        try(BufferedInputStream bis = new BufferedInputStream(new 																	FileInputStream(srcFile));\n            BufferedOutputStream bos = new BufferedOutputStream(new 																FileOutputStream(descFile))) {\n            //完成复制\n            int count = -1;\n            byte[] data = new byte[8192];\n            while ((count = bis.read(data)) != -1){\n                bos.write(data,0,count);\n                bos.flush();\n            }\n        } catch (FileNotFoundException e) {\n            throw new RuntimeException(e);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n~~~\n\n\n\n## 5.Object方法与常用api\n\nint hashCode():\n\nboolean equals():\n\nString toString():\n\nClass getClass():\n\nvoid wait():\n\nvoid notify():\n\nvoid notifyAll():\n\nSystem.gc():	调用垃圾回收线程\n\nSystem.currentTimeMills():	获取系统当前时间\n\nSystem.arrayCopy(int[] arr1,int start1,int[] arr2,int start2,int length):	完成数组的拷贝\n\nArrays.sort(int[] arr):	数组排序\n\nArrays.binarySearch(int[] arr ,int target):	二分法查找\n\nArrays.copy(int[] arr ,int lenth):	数组拷贝\n\nArrays.copyOfRange(int[] arr ,int begin ,int end):	数组拷贝\n\nprivate void finalize():	对象销毁时机\n\n## 6.定时器\n\n作用：间隔特定的时间，执行特定的程序\n\n1.使用sleep()方法\n\n2.使用java.util.Timer\n\n```java\nTimer timer = new Timer();//任务启动\n//task任务类，date启动事件，long间隔事件\n//添加任务\ntimer.schedule(new TimerTask(){	\n	@Override\n	public void run(){\n		sout();\n	}\n},Date date,long long);\n\n```\n\n3.Spring的SpringTask框架（详情看SpringBoot篇）\n\n## 7.反射\n\n### 7.1获取反射的三种方法\n\n```java\nClass class  = Class.forName(\"java.lang.String\");\n\n//通过对象获取\nString cc = \"cc\";\nClass class = cc.getClass;\n\n//通过类属性获取\nClass class = String.class;\n```\n\n### 7.2反射属性\n\n```java\nClass aclass = Class.forName(\"xxxx\");\nObject obj = aclass.newInstance();\n//获取类的属性对象\nField field = aclass.getDeclaredField(\"属性名\");\nField[] fields = aclass.getDeclareFields();\n//修改类的属性，field已经指定属性\nfield.set(obj,Object object);\n//获取类的指定属性\nfield.get(obj);\n//打破封装可以获取私有属性\nfield.setAccessiable(true);\n```\n\n### 7.3反射方法\n\n```java\n//获取所有的类方法\nMethod[] methods = aclass.getDeclareMethods();\n//获取方法的修饰符\nint i = method.getModifiers;\nModifiers.toString(i);\n//获取方法的返回值类型\nClass aclass = Method.getReturnType();\n//获取方法的名字\nString name = method.getName();\n//获取方法的参数列表\nClass[] types = method.getParameterTypes();\n//调用方法\nMethod method = aclass.getDeclaredMethod(\"login\",String.class,String.class);\nObject value = method.invoke(Object object,String username,String password);\n```\n\n### 7.4反射构造方法\n\n```java\n//获取全部构造方法\nConstruct[] constructors = aclass.getDeclaredConstructors();\n//获取修饰符\nint i = constructor.getModifiers();\nString name = Modifiers.toString(i);\n//获取构造方法名\nString name = constructor.getSimpleName();\n//获取参数列表\nClass[] types = constructor.getParameterTypes();\n//获取指定的构造方法\nConstructor constructor = aclass.getDeclaredConstructor(String.class,int.class);\n//根据构造方法创建对象\nObject obj = constructor.newInstance(\"string\",int);\n```\n\n### 7.5反射父类和接口\n\n```java\n//获取父类\nClass superClass = aclass.getSuperClass();\n//获取父类接口\nClass[] interfaces = superClass.getInterfaces();\n```\n\nfield、method、constructor都有setAccessiable方法,因为他们都继承了Accessiable接口\n\n**getMethod方法会返回继承的父类方法，而getDeclaredMethod则不会返回父类方法**\n\n### 7.6反射基本数据类型\n\n~~~java\nClass<Integer> integerClass = int.class;\nClass<Integer> type = Integer.TYPE;\n\n//二者是同一个class对象，其他基本类型和包装类型都基本这样\nSystem.out.println(integerClass);\nSystem.out.println(type);\n~~~\n\n### 7.7类加载知识\n\n反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载。\n\n1.静态加载：编译时加载相关的类，如果没有则报错，依赖性太强（使用到就加载相应的类）\n\n2.动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，也不会报错，降低了依赖性\n\n**类加载时机**\n\n1.当创建对象时（new）//静态加载\n\n2.当子类被加载时，父类也加载 //静态加载\n\n3.调用类中的静态成员时 //静态加载\n\n4.通过反射 //动态加载\n\n![image-20230519154436373](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230519154436373.png)\n\n### 7.8类加载过程详解\n\n![image-20230519155007018](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230519155007018.png)\n\n#### 7.8.1加载\n\nJVM在这阶段的主要目的是将字节码从不同的数据源（class文件，jar包，网络）转化为二进制字节流加载到内存中，并生成一个代表类的java.lang.Class对象\n\n#### 7.8.2连接\n\n##### 7.8.2.1验证\n\n1.目的是为了确保CLass文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全，在此过	程中会获取一个SecurityManager对象来进行安全校验\n\n~~~java\n//ClassLoader的loadClass方法，把class文件加载到方法区中（此时字节码文件是以二进制的形式存在的）\npublic Class<?> loadClass(String name) throws ClassNotFoundException {\n    return loadClass(name, false);\n}\n//具体的loadClass方法\npublic Class<?> loadClass(String var1, boolean var2) throws ClassNotFoundException {\n    int var3 = var1.lastIndexOf(46);\n    if (var3 != -1) {\n        //此时会拿到一个SecurityManager对象，进行安全校验\n        SecurityManager var4 = System.getSecurityManager();\n        if (var4 != null) {\n            var4.checkPackageAccess(var1.substring(0, var3));\n        }\n    }\n}\n~~~\n\n\n\n2.包括：文件格式验证（是否以魔数oxcafe babe开头）、元数据验证、字节码验证和符号引用验证\n\n3.可以考虑使用-Xverify:none 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间。\n\n##### 7.8.2.2准备\n\nJVM会在该阶段对静态变量分配内存并默认初始化（对应数据类型的默认初始值，如0、0L、null、false等）。\n\n首先会对静态变量分配内存地址，并进行值的初始化，这里不会真正的赋值，而是设成默认值。例如int类型会默认设成0，而long则是0L。如果变量被final static修饰，则会在此阶段直接赋值，因为被final static修饰的是常量\n\n##### 7.8.2.3解析\n\n虚拟机将常量池内的符号引用替换为直接引用（jvm内存地址）的过程\n\n#### 7.8.3初始化\n\n1.到初始化阶段，jvm会调用clinit方法。clinit方法是由编译器按语句在源文件中出现的顺序，一次收集类中的所有静态变量的赋值动作和静态代码块中的语句，进行合并（jvm代码优化）执行。\n\n2.虚拟机会保证一个类的clinit方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的clinit方法，其他线程都需要阻塞等待，直到活动线程方法执行完毕\n\n~~~java\n//装载字节码\npublic Class<?> loadClass(String name) throws ClassNotFoundException {\n    return loadClass(name, false);\n}\n//方法重载，真正执行的也是这个方法的loadClass\nprotected Class<?> loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n{\n    //加锁，多线程阻塞等待\n    synchronized (getClassLoadingLock(name)) {\n        // First, check if the class has already been loaded\n        Class<?> c = findLoadedClass(name);\n        if (c == null) {\n            long t0 = System.nanoTime();\n            try {\n                if (parent != null) {\n                    c = parent.loadClass(name, false);\n                } else {\n                    c = findBootstrapClassOrNull(name);\n                }\n            } catch (ClassNotFoundException e) {\n                // ClassNotFoundException thrown if class not found\n                // from the non-null parent class loader\n            }\n\n            if (c == null) {\n                // If still not found, then invoke findClass in order\n                // to find the class.\n                long t1 = System.nanoTime();\n                c = findClass(name);\n\n                // this is the defining class loader; record the stats\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            }\n        }\n        if (resolve) {\n            resolveClass(c);\n        }\n        return c;\n    }\n}\n~~~\n\n\n\n## 8.stream工作流\n\n### 8.1创建流\n\n1.单例集合 list/set.stream()\n\n2.数组 Arrays.stream(Object[] arr) / Stream.of(Object[] arr)\n\n3.双例集合 map.entryset().stream()\n\n### 8.2中间操作\n\n1.filter 可以对流中的数据进行条件过滤，符合条件的数据继续留在流中\n\nstream.filter(book -> book.price > 100.0);\n\n2.map 可以把流中的元素进行计算或者转换（数据类型转换）\n\nstream.map(book -> book.price+10)\n\n3.distinct可以去除流中的重复元素,通过对象的equals方法进行判断\n\nstream.distinct()\n\n4.sorted可以对流中的元素进行排序，如果调用空参的sorted()方法，需要实现comparable接口\n\nstream.sort((b1,b2) -> b1.price-b2.price)\n\n5.limit可以设置流的最大长度，超出的部分被抛弃\n\nstream.limit(2)\n\n6.skip跳过流中的前几个元素，返回剩下的元素\n\nstream.skip(2)\n\n7.flatmap map只能把一个对象转换成另一个对象来作为流中的元素，而flatmap可以把一个对象转换成多个对象	作为流中的元素\n\nstream.flatmap(book -> book.categories)\n\n### 8.3终结操作\n\n1.foreach 对流中的数据进行遍历操作\n\nstream.forEach(book -> sout(book.author))\n\n2.count 可以用来获取当前流中的元素个数\n\nstream.count()\n\n3.max&min 可以用来获取流中的最值，实现comparable接口或者自定义比较规则\n\nstream.min((b1,b2) -> b1.price- b2.price)\n\n4.collect把当前流转换成一个集合\n\nstream.collect(Collectors.toList())\n\nstream.collect(Collectors.toSet)\n\nstream.collect(Collectors.toMap(book -> book.author,book -> book.name))\n\n5.anyMatch 可以用来判断是否有任意符合匹配规条件的元素，结果为Boolean类型\n\nstream.anyMatch(book -> book.price > 100.0)\n\n6.allMath 可以用来判断是否都符合匹配条件，结果为Boolean类型\n\nstream.allMatch(book -> book.price > 100.0)\n\n7.noneMatch可以用来判断流中的元素是否都不符合匹配条件。如果都不符合结果为true，否则为false\n\nstream.noneMatch(book -> book.price > 100.0)\n\n8.findAny 随机获取流中的元素，不保证顺序\n\nstream.findAny()\n\n9.findFirst 获取流中的第一个元素\n\nstream.findFirst()\n\n## 9.集合\n\ncollection接口下有list接口和set接口，map是单独一个接口\n\nlist接口下常用的集合有arraylist、vector和linkedlist\n\nset接口下常用的集合有hashset和treeset\n\nmap接口下常用的集合有hashmap、treemap和hashtable\n\n### 9.1ArrayList知识点\n\njdk1.7创建集合的时候，立刻将数组初始化，初始长度为10\n\njdk1.8创建集合的时候不会对数组进行初始化，而是在使用的时候再赋值为10，这样可以减少内存开销\n\n当数组长度不足时，扩容为原来长度的1.5倍\n\n调用add方法的时候，会先判断数组容量，是否需要扩容，再进行元素添加\n\n### 9.2Vector知识点\n\nvector是线程安全的（实例对象锁），而且在创建集合的时候就会立马对数组进行初始化，初始容量为10\n\n当容量不足的时候，会对数组进行扩容，长度为原本的长度的两倍\n\n### 9.3LinkedList知识点\n\nlinkedlist底层采用双向链表，维护了两个属性first和last，分别指向首节点和尾节点。每个节点（Node对象）里面又维护了pre、next和item三个属性，其中，通过pre指向前一个，next指向后一个，最终实现双向链表。所有LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高。\n\n### 9.4HashSet知识点\n\nhashset就是value值为null的hashmap集合，所以也是无序（取出和存入顺序不一致），不可重复的集合（可存入一个null值），存放的位置取决于hash后确定的索引结果\n\n扩容机制和hashmap一样，其他基本相同\n\n### 9.5TreeSet知识点\n\ntreeset也是无序不可重复的集合，但是可以排序，这就以为着集合中的元素需要实现comparable接口，重写compareTo方法，或者，创建集合的时候就传入比较器对象（实现comparator接口，重写compareTo方法）\n\n### 9.6HashTable知识点\n\nHashTable的键和值都不能为null，否则会抛出NUllPointerException。HashTable的使用方法和hashMap一样，hashtable是线程安全的，hashmap是线程不安全的。\n\n### 9.7HashMap知识点\n\n默认容量是16，最大容量为2的30次方，扩容时机是0.75，红黑树阈值是8，链表阈值是6，树形化处理阈值是64，即当数组长度大于64，且链表长度大于8，才会转换成红黑树。当数组需要扩容的时候，容量变为原容量的两倍\n\n在jdk1.8中对数组的初始化采用了延迟初始化，即调用add()方法时才会初始化\n\n进行hash值计算的时候，先用hashcode的高16位和低6位进行异或运算，得到的结果再和数组的长度-1进行&运算，最后返回索引在数组中的位置\n\nMap中的key和value可以是任何引用类型的数据，会封装到HashMap的Node静态内部类中\n\nMap中的key不允许重复，value允许重复，key重复的时候，底层会进行value的赋值更新\n\nMap的key可以为null，value也可以为null，但是key只能有一个，value可以有多个\n\n### 9.8LinkedHashSet\n\nLinkedHashSet继承了HashSet，实现了Set接口，linkedHashSet底层是一个LinkedHashMap，维护了一个数组加双向链表，根据元素的hashcode值来决定元素的存储位置，同时使用链表维护元素的顺序，不允许添加重复元素，但是元素是有序的，存入和取出元素次序相同\n\n![image-20230508203254158](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230508203254158.png)\n\n## 10.集合详解\n\n### 10.1集合关系图\n\n![image-20230508133147847](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230508133147847.png)\n\n![image-20230508133229431](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230508133229431.png)\n\n​																		**Collection接口常用方法**\n\n![image-20230508133348196](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230508133348196.png)\n\n### 10.2Iterable迭代器接口（itit快捷键）\n\n```java\nIterator<Integer> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n	Integer next =  iterator.next();\n	iterator.remove();\n}\n```\n\n需要注意的是\n\n~~~java\nInteger[] ints = {1, 2, 3, 4, 5, 6, 7, 8, 9};\nList<Integer> list = Arrays.asList(ints);\n//使用Arrays.asList方法构建的list集合无法使用remove方法，直接创建的list集合才可以使用，否则会报错\n//UnsupportedOperationException，因为这样构建出来的list没有重写remove方法\n//也可以使用增强for循环进行迭代，但是底层仍是使用iterator迭代器\n//迭代删除元素可以使用removeif方法\n\n~~~\n\n### 10.3list接口（有序，可重复）\n\n#### 10.3.1ArrayList源码\n\n1.ArrayList中维护了一个Object数组elementData transient Object[] elementData;\n\n~~~java\n//无参构造器\npublic ArrayList() {\n	this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n}\n//赋值为空数组\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};\n~~~\n\n2.当创建ArrayList对象时，如果使用的无参构造器，则初始elementData容量为0，第一次添加的时候，则扩容elementData为10，如需再次扩容，则扩容elementData为1.5倍\n\n~~~java\n//添加元素时，进行扩容判定\npublic boolean add(E e) {\n    //扩容判定\n    ensureCapacityInternal(size + 1);  // Increments modCount!!\n    //添加元素\n    elementData[size++] = e;\n    return true;\n}\n//扩容判定\nprivate void ensureCapacityInternal(int minCapacity) {\n	ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n}\n//初始判定\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) {\n    //判定当前数组容量是否为0\n    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {\n        //为0，则返回10，即初始化为10\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    }\n    return minCapacity;\n}\n//精确判定\nprivate void ensureExplicitCapacity(int minCapacity) {\n    //记录更改次数，多线程冲突\n    modCount++;\n\n    //若当前容量大于数组长度，则进行扩容\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\n//扩容机制\nprivate void grow(int minCapacity) {\n    // overflow-conscious code\n    int oldCapacity = elementData.length;\n    //长度右移+长度，即扩容为1.5倍\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\n    //解释了为什么初始容量为10\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    //数组拷贝\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n~~~\n\n3.如果使用的是指定大小的构造器，则初始elementData容量为指定大小，如需再次扩容，则直接扩容为elementData的1.5倍\n\n~~~java\npublic ArrayList(int initialCapacity) {\n    if (initialCapacity > 0) {\n        //数组容量赋值为指定大小\n        this.elementData = new Object[initialCapacity];\n    } else if (initialCapacity == 0) {\n        this.elementData = EMPTY_ELEMENTDATA;\n    } else {\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    }\n}\n~~~\n\n4.remove()方法源码\n\n~~~java\n//删除元素\npublic E remove(int index) {\n    //越界检查\n    rangeCheck(index);\n\n    modCount++;\n    E oldValue = elementData(index);\n\n    //判断后续需要移动的元素数量\n    int numMoved = size - index - 1;\n    if (numMoved > 0)\n        //完成数组元素迁移\n        System.arraycopy(elementData, index+1, elementData, index,\n                         numMoved);\n    //末尾置空，触发GC\n    elementData[--size] = null; // clear to let GC do its work\n\n    return oldValue;\n}\n//判断删除元素的索引位置，是否越界\nprivate void rangeCheck(int index) {\n    if (index >= size)\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n~~~\n\n​																		**元素迁移图解**\n\n![image-20230508160605638](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230508160605638.png)\n\n#### 10.3.2Vector源码\n\n~~~java\n//无参构造器\npublic Vector() {\n    //默认赋值为10，即刻赋值\n    this(10);\n}\n//有参构造器，默认增量为0\npublic Vector(int initialCapacity) {\n    this(initialCapacity, 0);\n}\n//有参构造器，指定初始大小和增量\npublic Vector(int initialCapacity, int capacityIncrement) {\n    super();\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    this.elementData = new Object[initialCapacity];\n    this.capacityIncrement = capacityIncrement;\n}\n//添加元素\npublic synchronized boolean add(E e) {\n    modCount++;\n    //进行容量大小判断\n    ensureCapacityHelper(elementCount + 1);\n    elementData[elementCount++] = e;\n    return true;\n}\n//判定大小\nprivate void ensureCapacityHelper(int minCapacity) {\n    //当元素数量大于数组容量，进行扩容\n    if (minCapacity - elementData.length > 0)\n        grow(minCapacity);\n}\nprivate void grow(int minCapacity) {\n    int oldCapacity = elementData.length;\n    //判断增量，增量为0，则两倍扩容，否则增量扩容\n    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?\n                                     capacityIncrement : oldCapacity);\n    if (newCapacity - minCapacity < 0)\n        newCapacity = minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\n        newCapacity = hugeCapacity(minCapacity);\n    //元素拷贝\n    elementData = Arrays.copyOf(elementData, newCapacity);\n}\n~~~\n\n#### 10.3.3LinkedList源码\n\n**添加元素到指定位置**\n\n~~~java\n//添加元素\npublic void add(int index, E element) {\n    //检查元素越界异常\n    checkPositionIndex(index);\n	//若索引为长度大小，则直接添加到末尾\n    if (index == size)\n        linkLast(element);\n    else\n        //否则添加到指定位置的节点前面\n        linkBefore(element, node(index));\n}\n//检查元素越界异常\nprivate void checkPositionIndex(int index) {\n    if (!isPositionIndex(index))\n        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n}\n//当索引小于0或者大于链表长度，则判定为越界\nprivate boolean isPositionIndex(int index) {\n    return index >= 0 && index <= size;\n}\n//添加到末尾\nvoid linkLast(E e) {\n    //获取尾节点\n    final Node<E> l = last;\n    final Node<E> newNode = new Node<>(l, e, null);\n    //尾节点指向新节点\n    last = newNode;\n    if (l == null)\n        first = newNode;\n    else\n        //旧尾节点next指向新尾节点\n        l.next = newNode;\n    size++;\n    modCount++;\n}\n//找到指定位置的节点\nNode<E> node(int index) {\n    //折半查找，前则正序，后则倒叙\n    if (index < (size >> 1)) {\n        //正序\n        Node<E> x = first;\n        for (int i = 0; i < index; i++)\n            x = x.next;\n        return x;\n    } else {\n        //倒叙\n        Node<E> x = last;\n        for (int i = size - 1; i > index; i--)\n            x = x.prev;\n        return x;\n    }\n}\n//添加到指定节点前面\nvoid linkBefore(E e, Node<E> succ) {\n    // assert succ != null;\n    final Node<E> pred = succ.prev;\n    final Node<E> newNode = new Node<>(pred, e, succ);\n    succ.prev = newNode;\n    if (pred == null)\n        first = newNode;\n    else\n        pred.next = newNode;\n    size++;\n    modCount++;\n}\n~~~\n\n**删除指定位置的元素**\n\n~~~java\n//与上述流程相似，不再赘述，详细看图解\npublic E remove(int index) {\n    checkElementIndex(index);\n    return unlink(node(index));\n}\nE unlink(Node<E> x) {\n    // assert x != null;\n    final E element = x.item;\n    final Node<E> next = x.next;\n    final Node<E> prev = x.prev;\n\n    if (prev == null) {\n        first = next;\n    } else {\n        prev.next = next;\n        x.prev = null;\n    }\n\n    if (next == null) {\n        last = prev;\n    } else {\n        next.prev = prev;\n        x.next = null;\n    }\n\n    x.item = null;\n    size--;\n    modCount++;\n    return element;\n}\n~~~\n\n​																						**图解删除节点**\n\n![image-20230508163408618](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230508163408618.png)\n\n### 10.4Set接口（无序，不可重复，可排序）\n\n#### 10.4.1HashSet源码\n\n​																			**初始扩容方法源码**\n\n```java\nfinal Node<K,V>[] resize() {\n    //获取集合数组属性\n    Node<K,V>[] oldTab = table;\n    //判断旧数组对象，刚开始为null，旧容量赋值为0\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    //旧阈值也是0\n    int oldThr = threshold;\n    //新阈值，新容量都为0\n    int newCap, newThr = 0;\n    //旧容量为0，不执行\n    if (oldCap > 0) {\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        //扩容两倍，阈值也扩容为两倍\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            newThr = oldThr << 1; // double threshold\n    }\n    //旧阈值也为0\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {               // zero initial threshold signifies using defaults\n        //默认赋值，初始容量为16，阈值为12，当旧容量和旧阈值都为0时\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    //新阈值赋值给集合的阈值\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    //创建新的节点数组，大小为新的容量\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    //将新的节点数组赋值给集合数组\n    table = newTab;\n    //直接返回\n    return newTab;\n}\n```\n\n​																			**后续扩容方法源码**\n\n~~~java\n//此时数组的原大小为16，阈值为12\nfinal Node<K,V>[] resize() {\n    //集合数组赋值给旧数组\n    Node<K,V>[] oldTab = table;\n    //此时旧容量为16\n    int oldCap = (oldTab == null) ? 0 : oldTab.length;\n    //旧阈值为12\n    int oldThr = threshold;\n    //新数组和新阈值都为0\n    int newCap, newThr = 0;\n    //进入此判断\n    if (oldCap > 0) {\n        if (oldCap >= MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return oldTab;\n        }\n        //新的容量为旧容量左移一位，即x2\n        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&\n                 oldCap >= DEFAULT_INITIAL_CAPACITY)\n            //新的阈值也是旧阈值左移1位x2\n            newThr = oldThr << 1; // double threshold\n    }\n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {               // zero initial threshold signifies using defaults\n        newCap = DEFAULT_INITIAL_CAPACITY;\n        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    }\n    //新的阈值赋值给集合阈值\n    threshold = newThr;\n    @SuppressWarnings({\"rawtypes\",\"unchecked\"})\n    //创建一个新的数组\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];\n    //完成数组的赋值\n    table = newTab;\n    //进行数据迁移\n    if (oldTab != null) {\n        for (int j = 0; j < oldCap; ++j) {\n            Node<K,V> e;\n            if ((e = oldTab[j]) != null) {\n                oldTab[j] = null;\n                if (e.next == null)\n                    newTab[e.hash & (newCap - 1)] = e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);\n                else { // preserve order\n                    Node<K,V> loHead = null, loTail = null;\n                    Node<K,V> hiHead = null, hiTail = null;\n                    Node<K,V> next;\n                    do {\n                        next = e.next;\n                        if ((e.hash & oldCap) == 0) {\n                            if (loTail == null)\n                                loHead = e;\n                            else\n                                loTail.next = e;\n                            loTail = e;\n                        }\n                        else {\n                            if (hiTail == null)\n                                hiHead = e;\n                            else\n                                hiTail.next = e;\n                            hiTail = e;\n                        }\n                    } while ((e = next) != null);\n                    if (loTail != null) {\n                        loTail.next = null;\n                        newTab[j] = loHead;\n                    }\n                    if (hiTail != null) {\n                        hiTail.next = null;\n                        newTab[j + oldCap] = hiHead;\n                    }\n                }\n            }\n        }\n    }\n    //返回数组\n    return newTab;\n}\n~~~\n\n​																			**添加元素方法源码**\n\n~~~java\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) {\n    Node<K,V>[] tab; Node<K,V> p; int n, i;\n    //进行集合初始化\n    if ((tab = table) == null || (n = tab.length) == 0)\n        n = (tab = resize()).length;\n    //拿键的hash值和数组长度-1进行与运算，拿到索引值\n    if ((p = tab[i = (n - 1) & hash]) == null)\n        //若索引值处没有元素，直接添加\n        tab[i] = newNode(hash, key, value, null);\n    else {	//存在元素\n        Node<K,V> e; K k;\n        //equal相等，进行替换\n        if (p.hash == hash &&\n            ((k = p.key) == key || (key != null && key.equals(k))))\n            //先锁定替换的节点位置\n            e = p;\n        else if (p instanceof TreeNode)	//equal不相等，添加到链表或树，判断节点类型\n            //节点为树节点，进行挂接，先标记挂接的点，尚未解决，要学习红黑树节点的挂接\n            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n        else {\n            //否则，属于链表节点，进行遍历到尾节点，标记节点\n            for (int binCount = 0; ; ++binCount) {\n                if ((e = p.next) == null) {\n                    //若链表为尾节点，直接连接到末尾，此时标记节点为null\n                    p.next = newNode(hash, key, value, null);\n                    //判断当前链表长度，若大于等于8，则进行树化\n                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                        //树化，未解决\n                        treeifyBin(tab, hash);\n                    break;\n                }\n                //遍历链表，equals成功则标记替换节点，不成功则向下遍历\n                if (e.hash == hash &&\n                    ((k = e.key) == key || (key != null && key.equals(k))))\n                    break;\n                p = e;\n            }\n        }\n        //当标记节点不为null的时候，则代表存在重复key，需要完成替换\n        if (e != null) { // existing mapping for key\n            //返回旧值\n            V oldValue = e.value;\n            if (!onlyIfAbsent || oldValue == null)\n                //完成新值的替换\n                e.value = value;\n            //需要继承类重写的方法，linkHashMap\n            afterNodeAccess(e);\n            return oldValue;\n        }\n    }\n    ++modCount;\n    //判断是否需要扩容，即判断是否大于阈值\n    if (++size > threshold)\n        resize();\n    //需要继承类重写的方法，linkHashMap\n    afterNodeInsertion(evict);\n    return null;\n}\n~~~\n\n​																			**添加元素方法流程源码**\n\n~~~java\n//添加元素\npublic boolean add(E e) {\n    return map.put(e, PRESENT)==null;\n}\n//调用map的put方法\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n//计算键的hash值，策略为hashcode与自身低16位进行异或运算得到hash值，目的是为了减少hash冲突\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n~~~\n\n#### 10.4.2LinkedHashSet源码\n\n~~~java\n//LinkedHashSet数组节点是一个静态内部类，继承hashmap的一个静态内部类\nstatic class Entry<K,V> extends HashMap.Node<K,V> {\n    //维护了两个节点类型，分别指向上一个节点和下一个节点，实现双向链表的结构\n    Entry<K,V> before, after;\n    //构造方法调用父类的构造方法\n    Entry(int hash, K key, V value, Node<K,V> next) {\n        super(hash, key, value, next);\n    }\n}\n\n//hashMap的静态内部类，除了常见的属性外，自带了next节点属性，指向下一个节点，维护了链表\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;\n\n    Node(int hash, K key, V value, Node<K,V> next) {\n        this.hash = hash;\n        this.key = key;\n        this.value = value;\n        this.next = next;\n    }\n\n    public final K getKey()        { return key; }\n    public final V getValue()      { return value; }\n    public final String toString() { return key + \"=\" + value; }\n\n    public final int hashCode() {\n        return Objects.hashCode(key) ^ Objects.hashCode(value);\n    }\n\n    public final V setValue(V newValue) {\n        V oldValue = value;\n        value = newValue;\n        return oldValue;\n    }\n\n    public final boolean equals(Object o) {\n        if (o == this)\n            return true;\n        if (o instanceof Map.Entry) {\n            Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n            if (Objects.equals(key, e.getKey()) &&\n                Objects.equals(value, e.getValue()))\n                return true;\n        }\n        return false;\n    }\n}\n//两个内部类结合完成了双向链表加单链表的结合，即保证了有序，又保证了查询替换效率\n~~~\n\n#### 10.4.3TreeSet源码（未完成）\n\n### 10.5Map接口\n\n#### 10.5.1内部存储结构\n\n~~~java\n//map内部节点数组\ntransient Node<K,V>[] table;\n//内部节点对象，Node节点是真正存储数据的地方，其他地方都是对该数据的引用\nstatic class Node<K,V> implements Map.Entry<K,V> {\n    final int hash;\n    final K key;\n    V value;\n    Node<K,V> next;\n    \n    //重写Map.Entry<K,V>接口方法\n    public final K getKey()        { return key; }\n    //重写Map.Entry<K,V>接口方法\n    public final V getValue()      { return value; }\n    //重写Map.Entry<K,V>接口方法\n    public final V setValue(V newValue) {\n        V oldValue = value;\n        value = newValue;\n        return oldValue;\n    }\n}\n\n//内部类，方便遍历而设计的，集合类型是Map.Entry，实际类型是Node+。\n//Map的内部集合类，可以获取set集合进行遍历\nfinal class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n    public final int size()                 { return size; }\n    public final void clear()               { HashMap.this.clear(); }\n    public final Iterator<Map.Entry<K,V>> iterator() {\n        return new EntryIterator();\n    }\n    public final boolean contains(Object o) {\n        if (!(o instanceof Map.Entry))\n            return false;\n        Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n        Object key = e.getKey();\n        Node<K,V> candidate = getNode(hash(key), key);\n        return candidate != null && candidate.equals(e);\n    }\n    public final boolean remove(Object o) {\n        if (o instanceof Map.Entry) {\n            Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n            Object key = e.getKey();\n            Object value = e.getValue();\n            return removeNode(hash(key), key, value, true, true) != null;\n        }\n        return false;\n    }\n    public final Spliterator<Map.Entry<K,V>> spliterator() {\n        return new EntrySpliterator<>(HashMap.this, 0, -1, 0, 0);\n    }\n    public final void forEach(Consumer<? super Map.Entry<K,V>> action) {\n        Node<K,V>[] tab;\n        if (action == null)\n            throw new NullPointerException();\n        if (size > 0 && (tab = table) != null) {\n            int mc = modCount;\n            for (int i = 0; i < tab.length; ++i) {\n                for (Node<K,V> e = tab[i]; e != null; e = e.next)\n                    action.accept(e);\n            }\n            if (modCount != mc)\n                throw new ConcurrentModificationException();\n        }\n    }\n}\n\n//Map的内部集合类，可以获取value集合进行遍历\nfinal class Values extends AbstractCollection<V> {\n    public final int size()                 { return size; }\n    public final void clear()               { HashMap.this.clear(); }\n    public final Iterator<V> iterator()     { return new ValueIterator(); }\n    public final boolean contains(Object o) { return containsValue(o); }\n    public final Spliterator<V> spliterator() {\n        return new ValueSpliterator<>(HashMap.this, 0, -1, 0, 0);\n    }\n    public final void forEach(Consumer<? super V> action) {\n        Node<K,V>[] tab;\n        if (action == null)\n            throw new NullPointerException();\n        if (size > 0 && (tab = table) != null) {\n            int mc = modCount;\n            for (int i = 0; i < tab.length; ++i) {\n                for (Node<K,V> e = tab[i]; e != null; e = e.next)\n                    action.accept(e.value);\n            }\n            if (modCount != mc)\n                throw new ConcurrentModificationException();\n        }\n    }\n}\n//获取key集合\npublic Set<K> keySet() {\n    Set<K> ks = keySet;\n    if (ks == null) {\n        ks = new KeySet();\n        keySet = ks;\n    }\n    return ks;\n}\n//获取value集合\npublic Collection<V> values() {\n    Collection<V> vs = values;\n    if (vs == null) {\n        vs = new Values();\n        values = vs;\n    }\n    return vs;\n}\n//获取key-value集合\npublic Set<Map.Entry<K,V>> entrySet() {\n    Set<Map.Entry<K,V>> es;\n    return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;\n}\n~~~\n\n#### 10.5.2Map接口常用方法\n\n![image-20230515214314007](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230515214314007.png)\n\n#### 10.5.3HashTable源码\n\n​																					**初始扩容**	\n\n~~~java\n//无参构造方法，默认初始容量位11\npublic Hashtable() {\n    this(11, 0.75f);\n}\n//有参构造方法\npublic Hashtable(int initialCapacity, float loadFactor) {\n    //数据校验\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                           initialCapacity);\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal Load: \"+loadFactor);\n	//最小容量为1\n    if (initialCapacity==0)\n        initialCapacity = 1;\n    //赋值加载因子\n    this.loadFactor = loadFactor;\n    //创建集合，并赋值\n    table = new Entry<?,?>[initialCapacity];\n    //赋值阈值\n    threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);\n}\n~~~\n\n​																			**后续扩容**\n\n~~~java\nprotected void rehash() {\n    //获取旧的容量\n    int oldCapacity = table.length;\n    //获取集合数组\n    Entry<?,?>[] oldMap = table;\n\n    //新的容量为旧的容量左移+1\n    int newCapacity = (oldCapacity << 1) + 1;\n    //不可超过最大值\n    if (newCapacity - MAX_ARRAY_SIZE > 0) {\n        if (oldCapacity == MAX_ARRAY_SIZE)\n            // Keep running with MAX_ARRAY_SIZE buckets\n            return;\n        newCapacity = MAX_ARRAY_SIZE;\n    }\n    //创建新的数组\n    Entry<?,?>[] newMap = new Entry<?,?>[newCapacity];\n\n    modCount++;\n    //创建新的阈值\n    threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1);\n    //给集合数组赋值\n    table = newMap;\n	//完成元素迁移\n    for (int i = oldCapacity ; i-- > 0 ;) {\n        for (Entry<K,V> old = (Entry<K,V>)oldMap[i] ; old != null ; ) {\n            Entry<K,V> e = old;\n            old = old.next;\n\n            int index = (e.hash & 0x7FFFFFFF) % newCapacity;\n            e.next = (Entry<K,V>)newMap[index];\n            newMap[index] = e;\n        }\n    }\n}\n~~~\n\n\n\n​																			**添加元素**\n\n~~~java\n//添加元素方法\npublic synchronized V put(K key, V value) {\n    //值和键都不可以为null\n    if (value == null) {\n        throw new NullPointerException();\n    }\n	//获取数组\n    Entry<?,?> tab[] = table;\n    //计算出索引值\n    int hash = key.hashCode();\n    int index = (hash & 0x7FFFFFFF) % tab.length;\n    @SuppressWarnings(\"unchecked\")\n    //获取索引处的元素\n    Entry<K,V> entry = (Entry<K,V>)tab[index];\n    //遍历此处链表\n    for(; entry != null ; entry = entry.next) {\n        if ((entry.hash == hash) && entry.key.equals(key)) {\n            //进行替换，返回旧值\n            V old = entry.value;\n            entry.value = value;\n            return old;\n        }\n    }\n	//添加新值\n    addEntry(hash, key, value, index);\n    return null;\n}\n//添加新值\nprivate void addEntry(int hash, K key, V value, int index) {\n    modCount++;\n	//获取数组\n    Entry<?,?> tab[] = table;\n    //如果数量大于阈值，进行扩容\n    if (count >= threshold) {\n        // Rehash the table if the threshold is exceeded\n        rehash();\n		\n        tab = table;\n        hash = key.hashCode();\n        index = (hash & 0x7FFFFFFF) % tab.length;\n    }\n	//获取当前索引位置的元素\n    @SuppressWarnings(\"unchecked\")\n    Entry<K,V> e = (Entry<K,V>) tab[index];\n    //将旧的元素作为下一个节点参数，创建新节点，头插法（map是尾插法）\n    tab[index] = new Entry<>(hash, key, value, e);\n    count++;\n}\n~~~\n\n#### 10.5.4Properties方法\n\n~~~java\n//加载驱动，在程序启动的时候就被加载且只执行一次\nstatic{\n    try {\n        Properties properties = new Properties();//创建配置文件对象\n        //通过类获取流的对象\n        InputStream in = JDBCUtils.class.getClassLoader().getResourceAsStream(\"db.properties\");\n\n        properties.load(in);//通过字节输入流in读取里边的键值对\n\n        driver = properties.getProperty(\"driverClassName\");//获取键对应的值\n        url = properties.getProperty(\"url\");               //获取键url对应的值\n        username = properties.getProperty(\"username\");     //获取键username对应的值\n        password = properties.getProperty(\"password\");     //获取键password对应的值\n\n        Class.forName(driver);           //加载驱动\n    } catch (ClassNotFoundException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } catch (IOException e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    }\n}\n~~~\n\n#### 10.5.5TreeMap源码（未完成）\n\n', 'java基础总结（未完成）v1.0', 1, '', '1', '0', 2, '0', 1, '2023-06-12 16:52:55', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (30, 'JUC总结', '# 										JUC\n\n## 1.实现多线程的方式\n\n### 1.1继承thread类，重写run方法\n\n### 1.2实现runnable接口，实现run方法\n\n### 1.3实现callable接口，实现call方法，并异步获取结果，避免阻塞\n\n```java\n	/*\n	创建线程的方式三: 实现callable接口 ---JDK 5.0 新增\n	1.创建一个实现Callable接口的实现类\n	2.实现call方法,将此线程需要执行的操作声明在call()中\n	3.创建callable接口实现类的对象\n	4.将此callable的对象作为参数传入到FutureTask构造器中,创建FutureTask的对象\n	5.将FutureTask对象作为参数传递到Thread类的构造器中,创建Thread对象,并调用start\n	6.获取callable接口中call方法的返回值\n	* */\n	public class ThreadNew {\n	    public static void main(String[] args) {\n	        //3.创建callable接口实现类的对象\n	        NumThead m=new NumThead();\n	        //4.将此callable的对象作为参数传入到FutureTask构造器中,创建FutureTask的对象\n	        \n	        FutureTask futureTask = new FutureTask(m);\n	        //5.将FutureTask对象作为参数传递到Thread类的构造器中,创建Thread对象,并调用start()方法\n	        //FutureTask类继承了Runnable接口\n	        //new Runnable = futrueTask;\n	        new Thread(futureTask).start();\n	\n	        //6.获取callable接口中call方法的返回值\n	        //3.使用轮询，如果想要异步获取结果,通常都会以轮询的方式去获取结果,尽量不要阻塞\n        	while(true){\n                if(futureTask.isDone()){\n                    System.out.println(\"使用轮询来解决,值为:\"+futureTask.get());\n                    break;\n                }else{\n                    System.out.println(\"阻塞中**********\");\n                }\n	    	}\n	\n	}\n	//1.创建一个实现Callable接口的实现类\n	class  NumThead implements Callable{\n	   // class  NumThead implements Callable<Integer>{\n	    //2.实现call方法,将此线程需要执行的操作声明在call()中\n	    @Override\n	    public Object call() throws Exception {\n	    //public Integer call() throws Exception {\n	        int sum=0;\n	        for(int i=1;i<=100;i++){\n	            System.out.println(i);\n	            sum+=i;\n	        }\n	        return sum;\n	    }\n	}\n\n```\n\n## 2.线程基础\n\n①. 线程有两种调度模型 [ 了解 ]\n分时调度模式:所有线程轮流使用CPU的使用权,平均分配每个线程占有CPU的时间片\n抢占式调度模型:优先让优先级高的线程使用CPU,如果线程的优先级相同,那么会随机选择一个,优先级高的线程获取的CPU时0间片相对多一些 [ Java使用的是抢占式调度模型 ]\n②. Thread类中设置和获取线程优先级的方法\npublic final void setPriority(int newPriority):更改此线程的优先级\npublic final int getPriority():返回此线程的优先级\na. 线程默认优先级是5；线程优先级范围是:1-10； b. 线程优先级高仅仅表示线程获取的CPU时间的几率高,但是要在次数比较多,或者多次运行的时候才能看到你想要的效果，而且线程的最大优先级小于所属线程组的最大优先级\n![image-20230329134749461](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230329134749461.png)\n\n![image-20230329135044334](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230329135044334.png)\n\n## 3.阻塞队列\n\n![image-20230329140954474](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230329140954474.png)\n\n阻塞队列种类\n\n①. ArrayBlockingQueue: 由数组结构组成的有界阻塞队列\n\n②. LinkedBlockingQueue: 由链表结构组成的有界(但大小默认值 Integer>MAX_VAL UE)阻塞队列.\n\n③. SynchronousQueue:不存储元素的阻塞队列,也即是单个元素的队列.\n\nSynchronousQueue没有容量，与其他BlcokingQueue不同,SynchronousQueue是一个不存储元素的BlcokingQueue每个put操作必须要等待一个take操作,否则不能继续添加元素,反之亦然\n④. PriorityBlockingQueue:支持优先级排序的无界阻塞队列.\n\n⑤. LinkedTransferQueue:由链表结构组成的无界阻塞队列.\n\n⑥. LinkedBlockingDeque:由链表结构组成的双向阻塞队列.\n\n## 4.线程池\n\n### 4.1为什么使用线程池\n\n1. 线程池做的工作主要是控制运行的线程的数量,处理过程中将任务加入队列,然后在线程创建后启动这些任务,如果显示超过了最大数量,超出的数量的线程排队等候,等其他线程执行完毕,再从队列中取出任务来执行\n2. 它的主要特点为:**线程复用 | 控制最大并发数 | 管理线程**.\n\n### 4.2Executors创建线程池\n\n![image-20230329143246855](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230329143246855.png)\n\n![image-20230329143301200](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230329143301200.png)\n\n![image-20230329143315866](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230329143315866.png)\n\n### 4.3自定义线程池七大参数\n\n①. corePoolSize:线程池中的常驻核心线程数\n在创建了线程池后,当有请求任务来之后,就会安排池中的线程去执行请求任务,近似理解为今日当值线程\n当线程池中的线程数目达到corePoolSize后,就会把到达的任务放入到缓存队列当中.\n②. maximumPoolSize:线程池能够容纳同时执行的最大线程数,此值大于等于1\n\n③. keepAliveTime:多余的空闲线程存活时间,当空间时间达到keepAliveTime值时,多余的线程会被销毁直到只剩下corePoolSize个线程为止(非核心线程)\n\n④. unit:keepAliveTime的单位\n\n⑤. workQueue:任务队列,被提交但尚未被执行的任务(候客区)\n\n⑥. threadFactory:表示生成线程池中工作线程的线程工厂,用户创建新线程,一般用默认即可(银行网站的logo | 工作人员的制服 | 胸卡等)\n\n⑦. handler:拒绝策略,表示当线程队列满了并且工作线程大于等于线程池的最大显示 数(maxnumPoolSize)时如何来拒绝\n\n### 4.4线程池执行流程\n\n![image-20230329143513731](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230329143513731.png)\n\n### 4.5线程池拒绝策略\n\n①. 等待队列也已经排满了,再也塞不下新的任务了。同时,线程池的maximumPoolSize也到达了,无法接续为新任务服务,这时我们需要拒绝策略机制合理的处理这个问题\n\n②. JDK内置的拒绝策略\n\nAbortPolicy(默认):直接抛出RejectedException异常阻止系统正常运行\nCallerRunsPolicy:\"调用者运行\"一种调节机制,该策略既不会抛弃任务,也不会抛出异常,而是返回给调用者进行处理\nDiscardOldestPolicy:将最早进入队列的任务删除,之后再尝试加入队列\nDiscardPolicy:直接丢弃任务,不予任何处理也不抛出异常.如果允许任务丢失,这是最好的拒绝策略\n③. 以上内置策略均实现了RejectExecutionHandler接口\n\n### 4.6为什么不使用jdk自带的线程池\n\n参考阿里巴巴java开发手册\n【强制】线程资源必须通过线程池提供,不允许在应用中自行显式创建线程。 说明:使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销,解决资源不足的问题。如果不使用线程池,有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。\n【强制】线程池不允许使用Executors去创建,而是通过 new ThreadPoolExecutor的方式,这样的处理方式让写的同学更加明确线程池的运行规则,规避资源耗尽的风险。说明:Executors返回的线程池对象的弊端如下:\n(1). FixedThreadPool和SingleThreadPool:允许的请求队列长度为Integer.MAX_VALUE,可能会堆积大量的请求,从而导致OOM。\n(2). CachedThreadPool和ScheduledThreadPool:允许的创建线程数量为Integer.MAX_VALUE,可能会创建大量的线程,从而导致OOM。\n\n### 4.7如何分配线程池的线程数量\n\n关键在于当前系统是cpu密集型还是io密集型，如果是cpu密集型则分配少一点线程数，如果是io密集型就可以分配多一点线程数，具体还是根据实际情况分析，慢慢调试。\n\n## 5.Volatile\n\n被volatile修改的变量有2大特点\n 特点:**保证变量的内存可见性 - 禁止指令重排序**\n\nvolatile的内存语义\n\n当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中。\n当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，直接从主内存中读取共享变量\n所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取\n\n## 6.原子类\n\n![image-20230329201714417](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230329201714417.png)\n\nAtomicLong的底层是CAS+自旋锁的思想,适用于低并发的全局计算,高并发后性能急剧下降,原因如下:N个线程CAS操作修改线程的值,每次只有一个成功过,其他N-1失败,失败的不停的自旋直到成功,这样大量失败自旋的情况,一下子cpu就打高了(AtomicLong的自旋会成为瓶颈)在高并发的情况下,我们使用LongAdder\n\n## 7.ThreadLocal局部变量\n\n### 7.1ThreadLocal局部变量简述\n\n ThreadLocal本地线程变量,线程自带的变量副本(实现了每一个线程副本都有一个专属的本地变量,主要解决的就是让每一个线程绑定自己的值,自己用自己的,不跟别人争抢。通过使用get()和set()方法,获取默认值或将其值更改为当前线程所存的副本的值从而避免了线程安全的问题)\n\n### 7.2api介绍\n\n②. static <T> ThreadLocal<T> withInitial(Supplier<? extends T> supplier):创建线程局部变量\n\n③. T get():返回当前线程的此线程局部变量的副本中的值\n\n④. void set(T value):将当前线程的此线程局部变量的副本设置为指定的值\n\n⑤. void remove():删除此线程局部变量的当前线程的值\n\n### 7.3Thread|ThreadLocal|ThreadLocalMap关系\n\n1.Thread类中有一个ThreadLocal.ThreadLocalMap threadLocals = null的变量,这个ThreadLocal相当于是Thread类和ThreadLocalMap的桥梁,在ThreadLocal中有静态内部类ThreadLocalMap,ThreadLocalMap中有Entry数组\n2.当我们为threadLocal变量赋值,实际上就是以当前threadLocal实例为key,值为value的Entry往threadLocalMap中存放\n3.t.threadLocals = new ThreadLocalMap(this, firstValue) 如下这行代码,可以知道每个线程都会创建一个ThreadLocalMap对象,每个线程都有自己的变量副本\n\n### 7.4set方法\n\n①. 首先获取当前线程,并根据当前线程获取一个Map\n\n②. 如果获取的Map不为空,则将参数设置到Map中(当前ThreadLocal的引用作为key)\n\n③. 如果Map为空,则给该线程创建 Map,并设置初始值\n\n```java\npublic void set(T value) {\n        // 获取当前线程对象\n        Thread t = Thread.currentThread();\n        // 获取此线程对象中维护的ThreadLocalMap对象\n        ThreadLocalMap map = getMap(t);\n        // 判断map是否存在\n        if (map != null)\n            // 存在则调用map.set设置此实体entry\n            map.set(this, value);\n        else\n            // 1)当前线程Thread 不存在ThreadLocalMap对象\n            // 2)则调用createMap进行ThreadLocalMap对象的初始化\n            // 3)并将 t(当前线程)和value(t对应的值)作为第一个entry存放至ThreadLocalMap中\n            createMap(t, value);\n}\n```\n\n### 7.5get方法\n\n先获取当前线程的ThreadLocalMap变量,如果存在则返回值,不存在则创建并返回初始值\n\n```java\npublic T get() {\n        // 获取当前线程对象\n        Thread t = Thread.currentThread();\n        // 获取此线程对象中维护的ThreadLocalMap对象\n        ThreadLocalMap map = getMap(t);\n        // 如果此map存在\n        if (map != null) {\n            // 以当前的ThreadLocal 为 key,调用getEntry获取对应的存储实体e\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            // 对e进行判空 \n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                // 获取存储实体 e 对应的 value值\n                // 即为我们想要的当前线程对应此ThreadLocal的值\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        /*\n        	初始化 : 有两种情况有执行当前代码\n        	第一种情况: map不存在,表示此线程没有维护的ThreadLocalMap对象\n        	第二种情况: map存在, 但是没有与当前ThreadLocal关联的entry\n         */\n        return setInitialValue();\n    }\n```\n\n### 7.6remove方法\n\n①. 首先获取当前线程,并根据当前线程获取一个Map\n\n②. 如果获取的Map不为空,则移除当前ThreadLocal对象对应的entry\n\n```java\n 	/**\n     * 删除当前线程中保存的ThreadLocal对应的实体entry\n     */\n     public void remove() {\n        // 获取当前线程对象中维护的ThreadLocalMap对象\n         ThreadLocalMap m = getMap(Thread.currentThread());\n        // 如果此map存在\n         if (m != null)\n            // 存在则调用map.remove\n            // 以当前ThreadLocal为key删除对应的实体entry\n             m.remove(this);\n     }\n\n```\n\n### 7.7ThreadLocal对象弱引用\n\n①. 当方法执行完毕后,栈帧销毁强引用 threadlocal 也就没有了。但此时线程的ThreadLocalMap里某个entry的key引用还指向这个对象\n\n②. 若这个key引用是强引用,就会导致key指向的ThreadLocal对象不能被gc回收,造成内存泄漏\n\n③. 若这个key引用是弱引用就大概率会减少内存泄漏的问题。使用弱引用,就可以使ThreadLocal对象在方法执行完毕后顺利被回收Entry的key为null的键值对。（执行set方法和get方法会清除）\n④. 虽然弱引用,保证了key指向的ThreadLocal对象能被及时回收,但是v指向的value对象是需要ThreadLocalMap调用get、set和remove时发现key为null时才会去回收整个entry、value\n\n### 7.8造成内存泄漏的原因\n\n由于ThreadLocal对象是弱引用，如果外部没有强引用指向它，它就会被GC回收，导致Entry的Key为null\n\n如果当前的情况下在栈中将threadlocal的引用设置为null，强引用将会失效，那堆中的threadlocal对象因为ThreadLocalMap的key对它的引用是弱引用，将会在下一次gc被回收，那就会出现key变成null，如果这时value外部也没有强引用指向它，那么value就永远也访问不到了，按理也应该被GC回收，但是由于ThreadLocalMap.Entry对象还在强引用value，导致value无法被回收，这时「内存泄漏」就发生了，value成了一个永远也无法被访问，但是又无法被回收的对象。\n\n### 7.9hash冲突\n\n与 HashMap 不同，ThreadLocalMap 结构非常简单，没有 next 引用，也就是说 ThreadLocalMap 中解决 Hash 冲突的方式并非链表的方式，而是采用线性探测的方式。所谓线性探测，就是根据初始 key 的 hashcode 值确定元素在 table 数组中的位置，如果发现这个位置上已经被其他的 key 值占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。\n\n### 7.10小结\n\n①. ThreadLocal本地线程变量,以空间换时间,线程自带的变量副本,人手一份,避免了线程安全问题\n\n②. 每个线程持有一个只属于自己的专属Map并维护了Thread Local对象与具体实例的映射,该Map由于只被持有它的线程访问,故不存在线程安全以及锁的问题\n\n③. ThreadLocalMap的Entry对ThreadLocal的引用为弱引用,避免了ThreadLocal对象无法被回收的问题\n\n⑤. 用完之后一定要remove操作\n\n## 8.juc工具类\n\n### 8.1countdownlatch（减法）\n\n①. CountDownLatch主要有两个方法,当一个或多个线程调用await方法时,这些线程会阻塞\n\n②. 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)\n\n③. 计数器的值变为0时,因await方法阻塞的线程会被唤醒,继续执行\n\n```java\npublic class AtomicIntegerDemo {\n    AtomicInteger atomicInteger=new AtomicInteger(0);\n    public void addPlusPlus(){\n        atomicInteger.incrementAndGet();\n    }\n    public static void main(String[] args) throws InterruptedException {\n        CountDownLatch countDownLatch=new CountDownLatch(10);\n        AtomicIntegerDemo atomic=new AtomicIntegerDemo();\n        // 10个线程进行循环100次调用addPlusPlus的操作,最终结果是10*100=1000\n        for (int i = 1; i <= 10; i++) {\n            new Thread(()->{\n               try{\n                   for (int j = 1; j <= 100; j++) {\n                       atomic.addPlusPlus();\n                   }\n               }finally {\n                   countDownLatch.countDown();\n               }\n            },String.valueOf(i)).start();\n        }\n        //(1). 如果不加上下面的停顿3秒的时间,会导致还没有进行i++ 1000次main线程就已经结束了\n        //try { TimeUnit.SECONDS.sleep(3);  } catch (InterruptedException e) {e.printStackTrace();}\n        //(2). 使用CountDownLatch去解决等待时间的问题\n        countDownLatch.await();\n        System.out.println(Thread.currentThread().getName()+\"\\t\"+\"获取到的result:\"+atomic.atomicInteger.get());\n    }\n}\n\n```\n\n### 8.2CyclicBarrier做加法\n\nCyclicBarrier的字面意思是可循环(Cyclic) 使用的屏障(barrier)。它要做的事情是,让一组线程到达一个屏障(也可以叫做同步点)时被阻塞,知道最后一个线程到达屏障时,屏障才会开门,所有被屏障拦截的线程才会继续干活,线程进入屏障通过CyclicBarrier的await()方法\n\n```java\n   //集齐7颗龙珠就能召唤神龙\npublic class CyclicBarrierDemo {\n    public static void main(String[] args) {\n        // public CyclicBarrier(int parties, Runnable barrierAction) {}\n        CyclicBarrier cyclicBarrier=new CyclicBarrier(7,()->{\n            System.out.println(\"召唤龙珠\");\n        });\n        for (int i = 1; i <=7; i++) {\n            final int temp=i;\n            new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+\"\\t收集到了第\"+temp+\"颗龙珠\");\n                try {\n                    cyclicBarrier.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n\n    }\n}\n```\n\n### 8.3Semaphore信号量\n\n①. acquire(获取)当一个线程调用acquire操作时,它要么通过成功获取信号量(信号量减1),要么一直等下去,直到有线程释放信号量,或超时。\n\n②. release(释放)实际上会将信号量的值加1,然后唤醒等待的线程。\n\n③. 信号量主要用于两个目的,一个是用于多个共享资源的互斥使用,另一个用于并发线程数的控制。\n\n```java\npublic class SemaphoreDemo {\n    public static void main(String[] args) {\n        Semaphore semaphore=new Semaphore(3);\n        for (int i = 1; i <=6; i++) {\n            new Thread(()->{\n                try {\n                    System.out.println(Thread.currentThread().getName()+\"\\t抢占了车位\");\n                    semaphore.acquire();\n                    System.out.println(Thread.currentThread().getName()+\"\\t离开了车位\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }finally {\n                    semaphore.release();\n                }\n            },String.valueOf(i)).start();\n        }\n    }\n}\n```\n\n## 9.线程中断\n\n③. 中断只是一种协作机制,Java没有给中断增加任何语法,中断的过程完全需要程序员自己实现\n\n④. 若要中断一个线程,你需要手动调用该线程的interrupt方法,该方法也仅仅是将线程对象的中断标识设为true\n\n⑤. 每个线程对象中都有一个标识,用于标识线程是否被中断;该标识位为true表示中断,为false表示未中断;通过调用线程对象的interrupt方法将线程的标识位设为true;可以在别的线程中调用,也可以在自己的线程中调用\n\n### 9.1中断的三个api\n\nvoid interrupt( )实例方法，该方法仅仅是设置线程的中断状态为true，不会停止线程\n\nboolean isInterrupted( )实例方法，判断当前线程是否被中断(通过检查中断标识位) 实例方法\n\nstatic boolean interrupted( )静态方法，判断线程是否被中断,并清除当前中断状态,这个方法做了两件事\n(返回当前线程的中断状态 | 将当前线程的中断状态设为false)\n原理:假设有两个线程A、B,线程B调用了interrupt方法,这个时候我们连接调用两次isInterrupted方法,第一次会返回true,然后这个方法会将中断标识位设置位false,所以第二次调用将返回false\n\n### 9.2实现线程中断\n\n1. 通过一个volatile变量实现,flag\n2. 通过AtomicBoolean,atomicBoolean.get()\n3. 通过Thread类自带的中断API方法实现，Thread.currentThread().isInterrupted();', 'JUC总结笔记V1.0（暂未完结）', 1, '', '1', '0', 5, '0', 1, '2023-06-12 21:12:24', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (31, 'JVM锁总结', '# 																JVM本地锁\n\n## 1.synchronize\n\n### 1.1monitorenter\n\n 每一个对象都会和一个监视器monitor关联。监视器被占用时会被锁住，其他线程无法来获取该monitor。 当JVM执行某个线程的某个方法内部的monitorenter时，它会尝试去获取当前对象对应的monitor的所有权。其过程如下：\n\n若monior的进入数为0，线程可以进入monitor，并将monitor的进入数置为1。当前线程成为monitor的owner（所有者）\n\n若线程已拥有monitor的所有权，允许它重入monitor，则进入monitor的进入数加1\n\n若其他线程已经占有monitor的所有权，那么当前尝试获取monitor的所有权的线程会被阻塞，直到monitor的进入数变为0，才能重新尝试获取monitor的所有权。\n\nmonitorenter小结:\n\nsynchronized的锁对象会关联一个monitor,这个monitor不是我们主动创建的,是JVM的线程执行到这个\n\n同步代码块,发现锁对象没有monitor就会创建monitor,monitor内部有两个重要的成员变量owner:拥有\n\n这把锁的线程,recursions会记录线程拥有锁的次数,当一个线程拥有monitor后其他线程只能等待\n\n### 1.2monitorexit\n\n1. 能执行monitorexit指令的线程一定是拥有当前对象的monitor的所有权的线程。\n\n2. 执行monitorexit时会将monitor的进入数减1。当monitor的进入数减为0时，当前线程退出\n\n   monitor，不再拥有monitor的所有权，此时其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。monitorexit释放锁。monitorexit插入在方法结束处和异常处，JVM保证每个monitorenter必须有对应的monitorexit。\n\n### 1.3lock和synchronize的区别\n\n1. synchronized是关键字，而Lock是一个接口。\n\n2. synchronized会自动释放锁，而Lock必须手动释放锁。\n\n3. synchronized是不可中断的，Lock可以中断也可以不中断。\n\n4. 通过Lock可以知道线程有没有拿到锁，而synchronized不能。\n\n5. synchronized能锁住方法和代码块，而Lock只能锁住代码块。\n\n6. synchronized是非公平锁，ReentrantLock可以控制是否是公平锁。\n\n### 1.4重量级锁\n\n可以看到ObjectMonitor的函数调用中会涉及到Atomic::cmpxchg_ptr，Atomic::inc_ptr等内核函数，\n\n执行同步代码块，没有竞争到锁的对象会park()被挂起，竞争到锁的线程会unpark()唤醒。这个时候就\n\n会存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。所以synchronized是Java语\n\n言中是一个重量级(Heavyweight)的操作。\n\n## 2.monitor的JVM理解\n\n```c++\nObjectMonitor() {\n    _header = NULL;\n    _count = 0;\n    _waiters = 0，\n    _recursions = 0; // 线程的重入次数\n    _object = NULL; // 存储该monitor的对象\n    _owner = NULL; // 标识拥有该monitor的线程\n    _WaitSet = NULL; // 处于wait状态的线程，会被加入到_WaitSet\n    _WaitSetLock = 0 ;\n    _Responsible = NULL;\n    _succ = NULL;\n    _cxq = NULL; // 多线程竞争锁时的单向列表\n    FreeNext = NULL;\n    _EntryList = NULL; // 处于等待锁block状态的线程，会被加入到该列表\n    _SpinFreq = 0;\n    _SpinClock = 0;\n    OwnerIsThread = 0;\n}\n```\n\n1. _owner：初始时为NULL。当有线程占有该monitor时，owner标记为该线程的唯一标识。当线程\n\n释放monitor时，owner又恢复为NULL。owner是一个临界资源，JVM是通过CAS操作来保证其线\n\n程安全的。\n\n2. _cxq：竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。_cxq是一个临界资\n\n源，JVM通过CAS原子指令来修改_cxq队列。修改前_cxq的旧值填入了node的next字段，_cxq指\n\n向新值（新线程）。因此_cxq是一个后进先出的stack（栈）。\n\n3. _EntryList：_cxq队列中有资格成为候选资源的线程会被移动到该队列中。\n\n4. _WaitSet：因为调用wait方法而被阻塞的线程会被放在该队列中。\n\n![image-20230329221400243](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230329221400243.png)\n\n### 2.1monitor竞争\n\n1. 通过CAS尝试把monitor的owner字段设置为当前线程。\n\n2. 如果设置之前的owner指向当前线程，说明当前线程再次进入monitor，即重入锁，执行\n\nrecursions ++ ，记录重入的次数。\n\n3. 如果当前线程是第一次进入该monitor，设置recursions为1，_owner为当前线程，该线程成功获\n\n得锁并返回。\n\n4. 如果获取锁失败，则等待锁的释放。\n\n### 2.2monitor等待\n\n1. 当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TS_CXQ。\n\n2. 在for循环中，通过CAS把node节点push到_cxq列表中，同一时刻可能有多个线程把自己的node\n\n节点push到_cxq列表中。\n\n3. node节点push到_cxq列表之后，通过自旋尝试获取锁，如果还是没有获取到锁，则通过park将当\n\n前线程挂起，等待被唤醒。\n\n4. 当该线程被唤醒时，会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁。\n\n### 2.3monitor释放\n\n1. 退出同步代码块时会让_recursions减1，当_recursions的值减为0时，说明线程释放了锁。\n\n2. 根据不同的策略（由QMode指定），从cxq或EntryList中获取头节点，通过ObjectMonitor::ExitEpilog 方法唤醒该节点封装的线程，唤醒操作最终由unpark完成。\n\n## 3.synchronized锁升级\n\n### 3.1概述\n\njava5以前,只有Synchronized,这个是操作系统级别的重量级操作,重量级锁,假如锁的竞争比较激烈的话,性能下降。在Java早期版本中,synchronized属于重量级锁,效率低下,因为监视器锁(monitor)是依赖于底层的操作系统。Mutex Lock来实现的,挂起线程和恢复线程都需要转入内核态去完成,阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成,这种状态切换需要耗费处理器时间,如果同步代码块中内容过于简单,这种切换的时间可能比用户代码执行的时间还长”,时间成本相对较高,这也是为什么早期的synchronized效率低的原因。Java 6之后,为了减少获得锁和释放锁所带来的性能消耗,引入了轻量级锁和偏向锁。\n\n### 3.2 无锁状态\n\n![image-20230613200440421](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230613200440421.png)\n\n偏向锁位为：0，锁标记位为：01\n\n### 3.3 偏向锁\n\n1.当一段同步代码一直被同一个线程多次访问,由于只有一个线程那么该线程在后续访问时便会自动获得锁(偏向锁)。一个synchronized方法被一个线程抢到了锁时,那这个方法所在的对象就会在其所在的Mark Word中将偏向锁修改状态位,同时还会有占用前54位来存储线程指针作为标识。若该线程再次访问同一个synchronized方法时,该线程只需去对象头的Mark Word 中去判断一下是否有偏向锁指向本身的ID,无需再进入Monitor去竞争对象了。\n\n![image-20230613200656457](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230613200656457.png)\n2.偏向所锁，轻量级锁都是乐观锁，重量级锁是悲观锁。一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（**偏向锁就是这个时候升级为轻量级锁的**）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。\n\n3.JVM参数设置\n\n* 实际上偏向锁在JDK1.6之后是默认开启的,但是启动时间有延迟,\n\n* 所以需要添加参数-XX:BiasedLockingStartupDelay=0,让其在程序启动时立刻启动。\n\n* 开启偏向锁:\n\n* -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0\n\n* 关闭偏向锁:关闭之后程序默认会直接进入轻量级锁状态。\n\n* -XX:-UseBiasedLocking\n\n4.竞争过程\n\n第一个线程正在执行synchronized方法(处于同步块),它还没有执行完,其它线程来抢夺,该偏向锁会被取消掉并出现锁升级。此时轻量级锁由原持有偏向锁的线程持有,继续执行其同步代码,而正在竞争的线程会进入自旋等待获得该轻量级锁，第一个线程执行完成synchronized方法(退出同步块),则将对象头设置成无锁状态并撤销偏向锁 ,重新偏向(他人的理解是,其实如果线程A执行完毕,如果不再去竞争,那么就会重新线程B为偏向锁;如果线程A继续竞争,那么就会CAS自旋 也就升级到了轻量级锁)。\n\n5.图解\n\n![image-20230613202944638](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230613202944638.png)\n\n### 3.4 轻量级锁\n\n1.主要作用(本质就是自旋锁)有线程来参与锁的竞争,但是获取锁的冲突时间极短，于是通过自旋去CAS修改对象头信息。\n\n2.过程详解\n(1). 轻量级锁是为了在线程近乎交替执行同步块时提高性能\n(2). 主要目的: 在没有多线程竞争的前提下,通过CAS减少重量级锁使用操作系统互斥量产生的性能消耗,说白了先自旋再阻塞\n(3). 升级时机:当关闭偏向锁功能或多线程竞争偏向锁会导致偏向锁升级为轻量级锁\n(4). 假如线程A已经拿到锁,这时线程B又来抢该对象的锁,由于该对象的锁已经被线程A拿到,当前该锁已是偏向锁了。而线程B在争抢时发现对象头Mark Word中的线程ID不是线程B自己的线程ID(而是线程A),那线程B就会进行CAS操作希望能获得锁。此时线程B操作中有两种情况：①如果锁获取成功,直接替换Mark Word中的线程ID为B自己的ID(A → B),重新偏向于其他线程(即将偏向锁交给其他线程,相当于当前线程\"被\"释放了锁),该锁会保持偏向锁状态,A线程Over,B线程上位。②如果锁获取失败,则偏向锁升级为轻量级锁,此时轻量级锁由原持有偏向锁的线程持有,继续执行其同步代码,而正在竞争的线程B会进入自旋等待获得该轻量级锁。\n\n(5). 自旋达到一定次数和程度\njava6之前(了解):默认启用,默认情况下自旋的次数是10次,-XX:PreBlockSpin=10来修改或者自旋线程数超过cpu核数一半\nJava6之后:自适应(自适应意味着自旋的次数不是固定不变的),而是根据:同一个锁上一次自旋的时间和拥有锁线程的状态来决定。\n(6). 轻量锁与偏向锁的区别和不同\n争夺轻量级锁失败时,自旋尝试抢占锁\n轻量级锁每次退出同步块都需要释放锁,而偏向锁是在竞争发生时才释放锁\n\n![image-20230613203249924](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230613203249924.png)\n\n### 3.5 重量级锁（涉及用户态和内核态的切换）\n\n1.有大量的线程参与锁的竞争,冲突性很高，此时，锁会升级为重量级锁\n\n2.图解\n\n![image-20230613204122070](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230613204122070.png)\n\n3.锁升级过程\n\n①. synchronized锁升级过程总结:一句话,就是先自旋,不行再阻塞。\n实际上是把之前的悲观锁(重量级锁)变成在一定条件下使用偏向锁以及使用轻量级(自旋锁CAS)的形式\n\n②. synchronized在修饰方法和代码块在字节码上实现方式有很大差异,但是内部实现还是基于对象头的MarkWord来实现的\n\n③. JDK1.6之前synchronized使用的是重量级锁,JDK1.6之后进行了优化,拥有了无锁->偏向锁->轻量级锁->重量级锁的升级过程,而不是无论什么情况都使用重量级锁。\n\n### 3.6 锁粗化和锁消除\n\n1.锁消除：从JIT编译器的角度来看，相当于无视他，不进行机器指令的编译，这个锁对象并没有被共用到其他线程使用，也就是说根本就不会发生锁竞争，所以直接消除了锁的使用\n\n~~~java\n**\n * 锁消除\n * 从JIT角度看相当于无视它,synchronized (o)不存在了,这个锁对象并没有被共用扩散到其它线程使用,\n * 极端的说就是根本没有加这个锁对象的底层机器码,消除了锁的使用\n */\npublic class LockClearUPDemo{\n    static Object objectLock = new Object();//正常的\n\n    public void m1(){\n        //锁消除,JIT会无视它,synchronized(对象锁)不存在了。不正常的\n        Object o = new Object();\n\n        synchronized (o){\n            System.out.println(\"-----hello LockClearUPDemo\"+\"\\t\"+o.hashCode()+\"\\t\"+objectLock.hashCode());\n        }\n    }\n\n    public static void main(String[] args){\n        LockClearUPDemo demo = new LockClearUPDemo();\n\n        for (int i = 1; i <=10; i++) {\n            new Thread(() -> {\n                demo.m1();\n            },String.valueOf(i)).start();\n        }\n    }\n}\n~~~\n\n2.锁粗化：假如方法中首尾相接，前后相邻的都是一个锁对象，那JIT编译器就会把这几个synchronized块合并，加粗锁的范围，只进行一次锁获取，遍历多次获取和释放锁（轻量级，偏向锁不会获取、释放锁），提升性能\n\n~~~java\n/**\n * 锁粗化\n * 假如方法中首尾相接,前后相邻的都是同一个锁对象,那JIT编译器就会把这几个synchronized块合并成一个大块,\n * 加粗加大范围,一次申请锁使用即可,避免次次的申请和释放锁,提升了性能\n */\npublic class LockBigDemo\n{\n    static Object objectLock = new Object();\n\n\n    public static void main(String[] args)\n    {\n        new Thread(() -> {\n            synchronized (objectLock) {\n                System.out.println(\"11111\");\n            }\n            synchronized (objectLock) {\n                System.out.println(\"22222\");\n            }\n            synchronized (objectLock) {\n                System.out.println(\"33333\");\n            }\n        },\"a\").start();\n\n        new Thread(() -> {\n            synchronized (objectLock) {\n                System.out.println(\"44444\");\n            }\n            synchronized (objectLock) {\n                System.out.println(\"55555\");\n            }\n            synchronized (objectLock) {\n                System.out.println(\"66666\");\n            }\n        },\"b\").start();\n\n    }\n}\n~~~\n\n### 3.7 锁降级\n\n1、初始无锁状态下和首次偏向锁状态下，后三位都是101，那么倒数第三位根本就不是偏向锁的标记位了\n\n2、所有的重量级锁释放后，会回归无锁状态，但此时后三位变成了001。此时再有一个线程获取锁，就直接获取轻量级，相当于偏向锁被禁用了\n\n3、锁不是不能降级，而是正在使用中的锁不能降级。但只要发生过锁升级，偏向锁就会被禁用（说明当前运行环境是多线程的）\n\n倒数第三位的含义应该是当前锁是否可以偏向：（001）不可以偏向，（101）可以偏向。那么如何判断当前锁101是无锁还是偏向锁呢？其实就看thread_id就行了。\n\n### 3.8 参考博客\n\n1.https://www.cnblogs.com/kundeg/archive/2018/02/06/8422557.html\n\n2.https://www.cnblogs.com/tiancai/p/16081535.html\n\n3.https://blog.csdn.net/salerzhang/article/details/115551054\n\n4.https://blog.csdn.net/TZ845195485/article/details/118269471', 'JVM锁总结（未完结）V1.0，未更新reentrantlock', 1, '', '1', '0', 1, '0', 1, '2023-06-13 20:54:34', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (32, 'Snowy框架日志功能分析', '# 							Snowy源码学习\n\n## 1.日志功能\n\n### 1.1框架总结\n\n**Snowy框架**的日志框架采用自定义注解的方式，给使用了该注解的方法配置切面，共同两种通知类型，分别为后置通知和异常通知。并根据请求获取具体的请求信息，对这些请求进行数据的加工，加入IP地址，浏览器类型，操作系统等附加信息。\n\n### 1.2 源码分析（这里以操作成功日志为例，其他同理）\n\n**日志切面类**\n\n~~~java\n//日志注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface CommonLog {\n\n    /**\n     * 日志的名称，例如:\"修改菜单\"\n     */\n    String value() default \"未命名\";\n}\n\n//日志通知切面\n@Aspect\n@Order\n@Component\npublic class DevLogAop {\n\n    //日志切点，使用了CommonLog注解的方法都会被代理\n    @Pointcut(\"@annotation(vip.xiaonuo.common.annotation.CommonLog)\")\n    private void getLogPointCut() {\n    }\n\n    //pointcut代理的切面，returning被代理方法的返回结果\n    @AfterReturning(pointcut = \"getLogPointCut()\", returning = \"result\")\n    public void doAfterReturning(JoinPoint joinPoint, Object result) {\n        //获取被代理方法\n        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();\n        Method method = methodSignature.getMethod();\n        //获取方法上的注解\n        CommonLog commonLog = method.getAnnotation(CommonLog.class);\n        //获取用户名\n        String userName = \"未知\";\n        try {\n            //使用sa-token进行登录用户名获取\n            SaBaseLoginUser loginUser = StpLoginUserUtil.getLoginUser();\n            if(ObjectUtil.isNotNull(loginUser)) {\n                userName = loginUser.getName();\n            }\n        } catch (Exception ignored) {\n        }\n        // 异步记录日志\n        DevLogUtil.executeOperationLog(commonLog, userName, joinPoint, 				\n                                       JSONUtil.toJsonStr(result));\n    }\n} \n~~~\n\n**日志工具类**\n\n~~~java\npublic class DevLogUtil {\n\n    private static final DevLogService devLogService = SpringUtil.getBean(DevLogService.class);\n	\n    //记录成功操作日志\n    public static void executeOperationLog(CommonLog commonLog, String userName, 		\n                                           JoinPoint joinPoint, String resultJson) {\n        //commonLog注解类、userName用户登录名、joinPoint切点对象、resultJson返回结果json对象\n        //从请求上下文中获取当前请求对象\n        HttpServletRequest request = CommonServletUtil.getRequest();\n        //构建基础操作日志\n        DevLog devLog = genBasOpLog();\n        //开启异步线程执行日志构建，插入数据库\n        ThreadUtil.execute(() -> {\n            //设置日志类型--操作日志\n            devLog.setCategory(DevLogCategoryEnum.OPERATE.getValue());\n            //设置日志的名称--通过注解的value属性获取\n            devLog.setName(commonLog.value());\n            //设置请求结果类型--success\n            devLog.setExeStatus(DevLogExeStatusEnum.SUCCESS.getValue());\n            //设置请求的控制层类类名\n            devLog.setClassName(joinPoint.getTarget().getClass().getName());\n            //设置请求方法名\n            devLog.setMethodName(joinPoint.getSignature().getName());\n            //设置请求路径\n            devLog.setReqUrl(request.getRequestURI());\n            //设置请求参数信息\n            devLog.setParamJson(CommonJoinPointUtil.getArgsJsonString(joinPoint));\n            //设置请求结果\n            devLog.setResultJson(resultJson);\n            //设置请求时间\n            devLog.setOpTime(DateTime.now());\n            //设置请求用户名\n            devLog.setOpUser(userName);\n            //构建日志完整性保护签名数据\n            creatLogSignValue(devLog);\n            //调用持久层进行数据保存\n            devLogService.save(devLog);\n        });\n    }\n    \n    //构建基础操作日志\n    private static DevLog genBasOpLog() {\n        //获取请求对象\n        HttpServletRequest request = CommonServletUtil.getRequest();\n        //获取请求的ip地址\n        String ip = CommonIpAddressUtil.getIp(request);\n        //创建日志对象\n        DevLog devLog = new DevLog();\n        //设置请求ip\n        devLog.setOpIp(CommonIpAddressUtil.getIp(request));\n        //设置请求地址\n        devLog.setOpAddress(CommonIpAddressUtil.getCityInfo(ip));\n        //设置请求浏览器\n        devLog.setOpBrowser(CommonUaUtil.getBrowser(request));\n        //设置请求操作系统\n        devLog.setOpOs(CommonUaUtil.getOs(request));\n        return devLog;\n    }\n    \n    //构建日志完整性保护签名数据\n    private static void creatLogSignValue (DevLog devLog) {\n        String logStr = devLog.toString().replaceAll(\" +\",\"\");\n        //对日志数据进行加密\n        devLog.setSignData(CommonCryptogramUtil.doSignature(logStr));\n    }\n}\n~~~\n\n**IP地址查询类--基于ip2region框架**\n\n~~~java\n/**\n * 根据ip地址定位工具类，离线方式\n * 参考地址：https://gitee.com/lionsoul/ip2region/tree/master/binding/java\n *\n * @author xuyuxiang\n * @date 2020/3/16 11:25\n */\n@Slf4j\npublic class CommonIpAddressUtil {\n\n    private static final String LOCAL_REMOTE_HOST = \"0:0:0:0:0:0:0:1\";\n	\n    //内部ip框架封装的查询对象\n    private static final Searcher searcher;\n\n    static {\n        //ip地址数据库\n        String fileName = \"/ip2region.xdb\";\n        //获取文件路径\n        File existFile = FileUtil.file(FileUtil.getTmpDir() + FileUtil.FILE_SEPARATOR + fileName);\n        //当文件不存在的时候，直接创建\n        if(!FileUtil.exist(existFile)) {\n            InputStream resourceAsStream = CommonIpAddressUtil.class.getResourceAsStream(fileName);\n            if(ObjectUtil.isEmpty(resourceAsStream)) {\n                throw new CommonException(\"CommonIpAddressUtil初始化失败，原因：IP地址库数据不存在\");\n            }\n            FileUtil.writeFromStream(resourceAsStream, existFile);\n        }\n\n        String dbPath = existFile.getPath();\n\n        // 1、从 dbPath 加载整个 xdb 到内存。\n        byte[] cBuff;\n        try {\n            cBuff = Searcher.loadContentFromFile(dbPath);\n        } catch (Exception e) {\n            log.error(\">>> CommonIpAddressUtil初始化异常：\", e);\n            throw new CommonException(\"CommonIpAddressUtil初始化异常\");\n        }\n\n        // 2、使用上述的 cBuff 创建一个完全基于内存的查询对象。\n        try {\n            searcher = Searcher.newWithBuffer(cBuff);\n        } catch (Exception e) {\n            log.error(\">>> CommonIpAddressUtil初始化异常：\", e);\n            throw new CommonException(\"CommonIpAddressUtil初始化异常\");\n        }\n    }\n\n    /**\n     * 获取客户端ip\n     *\n     * @author xuyuxiang\n     * @date 2020/3/19 9:32\n     */\n    public static String getIp(HttpServletRequest request) {\n        if (ObjectUtil.isEmpty(request)) {\n            return Ipv4Util.LOCAL_IP;\n        } else {\n            try {\n                String remoteHost = ServletUtil.getClientIP(request);\n                return LOCAL_REMOTE_HOST.equals(remoteHost) ? Ipv4Util.LOCAL_IP : remoteHost;\n            } catch (Exception e) {\n                log.error(\">>> 获取客户端ip异常：\", e);\n                return Ipv4Util.LOCAL_IP;\n            }\n        }\n    }\n\n    /**\n     * 根据IP地址离线获取城市\n     *\n     * @author xuyuxiang\n     * @date 2022/4/27 23:14\n     */\n    public static String getCityInfo(String ip) {\n        try {\n            ip = ip.trim();\n            // 3、执行查询\n            String region = searcher.searchByStr(ip);\n            return region.replace(\"0|\", \"\").replace(\"|0\", \"\");\n        } catch (Exception e) {\n            return \"未知\";\n        }\n    }\n}\n~~~\n\n**客户端信息查询工具**\n\n~~~java\npublic class CommonUaUtil {\n\n    /**\n     * 获取客户端浏览器\n     *\n     * @author xuyuxiang\n     * @date 2020/3/19 14:53\n     */\n    public static String getBrowser(HttpServletRequest request) {\n        //获取代理请求头\n        UserAgent userAgent = getUserAgent(request);\n        if (ObjectUtil.isEmpty(userAgent)) {\n            return StrUtil.DASHED;\n        } else {\n            //获取浏览器类型\n            String browser = userAgent.getBrowser().toString();\n            return \"Unknown\".equals(browser) ? StrUtil.DASHED : browser;\n        }\n    }\n\n    /**\n     * 获取客户端操作系统\n     *\n     * @author xuyuxiang\n     * @date 2022/9/2 15:36\n     */\n    public static String getOs(HttpServletRequest request) {\n        UserAgent userAgent = getUserAgent(request);\n        if (ObjectUtil.isEmpty(userAgent)) {\n            return StrUtil.DASHED;\n        } else {\n            //获取操作系统\n            String os = userAgent.getOs().toString();\n            return \"Unknown\".equals(os) ? StrUtil.DASHED : os;\n        }\n    }\n\n    /**\n     * 获取请求代理头\n     *\n     * @author xuyuxiang\n     * @date 2022/9/2 15:36\n     */\n    private static UserAgent getUserAgent(HttpServletRequest request) {\n        String userAgentStr = ServletUtil.getHeaderIgnoreCase(request, \"User-Agent\");\n        UserAgent userAgent = UserAgentUtil.parse(userAgentStr);\n        if (ObjectUtil.isNotEmpty(userAgentStr)) {\n            if (\"Unknown\".equals(userAgent.getBrowser().getName())) {\n                userAgent.setBrowser(new Browser(userAgentStr, null, \"\"));\n            }\n        }\n        return userAgent;\n    }\n}\n\n~~~\n\n', 'Snowy框架的日志框架采用自定义注解的方式，给使用了该注解的方法配置切面，共同两种通知类型，分别为后置通知和异常通知。并根据请求获取具体的请求信息，对这些请求进行数据的加工，加入IP地址，浏览器类型，操作系统等附加信息。', 1, '', '1', '0', 36, '0', 1, '2023-06-16 22:50:11', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (33, 'Snowy框架权限功能分析', '## 2.权限功能\n\n### 2.1 框架总结\n\n**Snowy框架**的权限功能使用的是sa-token框架，基于sa-token框架实现了登录认证、退出登录、会话管理、踢人下线、注解鉴权、路由拦截鉴权。由于博主只看了部分的sa-token官方文档，只对部分功能进行解析，感兴趣的同学可以自行阅读[官方文档](https://sa-token.cc/index.html)和源码\n\n### 2.2 源码分析\n\n**snowy配置类**\n\n~~~java\n@Configuration\n@MapperScan(basePackages = {\"vip.xiaonuo.**.mapper\"})\npublic class GlobalConfigure implements WebMvcConfigurer {\n\n    private static final String COMMON_REPEAT_SUBMIT_CACHE_KEY = \"common-repeatSubmit:\";\n\n    @Resource\n    private CommonCacheOperator commonCacheOperator;\n\n    /**\n     * 无需登录的接口地址集合\n     */\n    private static final String[] NO_LOGIN_PATH_ARR = {\n            /* 主入口 */\n            \"/\",\n\n            /* 静态资源 */\n            \"/favicon.ico\",\n            \"***\"\n    };\n\n    /**\n     * 仅超管使用的接口地址集合\n     */\n    private static final String[] SUPER_PERMISSION_PATH_ARR = {\n            \"/auth/session/**\",\n            \"***\"\n    };\n\n    /**\n     * B端要排除的，相当于C端要认证的\n     */\n    private static final String[] CLIENT_USER_PERMISSION_PATH_ARR = {\n            \"/auth/c/**\",\n            \"/client/c/**\"\n    };\n\n    //配置路由规则\n    @Bean\n    public SaServletFilter getSaServletFilter() {\n        return new SaServletFilter()\n                // 指定拦截路由\n                .addInclude(\"/**\")\n                // 设置鉴权的接口\n                .setAuth(r -> {\n                    // B端的接口校验B端登录，匹配路径就会执行下去\n                    SaRouter.match(\"/**\")\n                            // 排除无需登录接口\n                          .notMatch(CollectionUtil.newArrayList(NO_LOGIN_PATH_ARR))\n                            // 排除C端认证接口\n                          .notMatch(CollectionUtil.newArrayList(CLIENT_USER_PERMISSION_PATH_ARR))\n                            // 校验B端登录，到这里开始检验是否登录，调用sa-token的checkLogin\n                            .check(r1 -> StpUtil.checkLogin());                    \n                            // B端的超管接口校验B端超管角色，匹配路径就会执行下去\n                    SaRouter.match(\"/**\")\n                            // 排除无需登录接口\n                            .notMatch(CollectionUtil.newArrayList(NO_LOGIN_PATH_ARR))\n                            // 匹配超管接口，满足这些路径就会执行下去 			 \n                          .match(CollectionUtil.newArrayList(SUPER_PERMISSION_PATH_ARR))\n                            // 校验B端超管角色，到这里进行角色校验，调用sa-token的checkRole\n                            .check(r1 -> 	 		  	 	StpUtil.checkRole(SysBuildInEnum.BUILD_IN_ROLE_CODE.getValue()));\n                });\n    }\n}    \n~~~\n\n**认证接口实现类**\n\n~~~java\n/**\n     * 权限认证接口实现类，集成权限认证功能\n     * 这个类非常重要，类似于SpringSecurity的UserDetailsServiceImpl,即具体的认证逻辑在这里实现\n     * 在后面的源码分析也会出现这个类\n     * @author xuyuxiang\n     * @date 2022/7/7 16:16\n     **/\n@Component\npublic static class StpInterfaceImpl implements StpInterface {\n\n    /**\n         * 返回一个账号所拥有的权限码集合\n         */\n    @Override\n    public List<String> getPermissionList(Object loginId, String loginType) {\n        //判断登录的类型，B端还是C端，不同端口做不同的逻辑处理\n        if (SaClientTypeEnum.B.getValue().equals(loginType)) {\n            //通过B端用户工具返回B端用户的权限列表\n            return StpLoginUserUtil.getLoginUser().getPermissionCodeList();\n        } else {\n            //返回C端，不再赘述\n            return StpClientLoginUserUtil.getClientLoginUser().getPermissionCodeList();\n        }\n    }\n\n    /**\n         * 返回一个账号所拥有的角色标识集合\n         */\n    @Override\n    public List<String> getRoleList(Object loginId, String loginType) {\n        //判断登录的类型，B端还是C端，不同端口做不同的逻辑处理\n        if (SaClientTypeEnum.B.getValue().equals(loginType)) {\n            ////通过B端用户工具返回B端用户的角色列表\n            return StpLoginUserUtil.getLoginUser().getRoleCodeList();\n        } else {\n            //返回C端，不再赘述\n            return StpClientLoginUserUtil.getClientLoginUser().getRoleCodeList();\n        }\n    }\n}\n~~~\n\n~~~java\n// B端登录用户工具类\npublic class StpLoginUserUtil {\n\n    // 获取当前B端登录用户\n    public static SaBaseLoginUser getLoginUser() {\n        //使用sa-token框架自带的stpUtil工具类获取tokensession，并根据key值取出存入的用户登录对象\n        return (SaBaseLoginUser) StpUtil.getTokenSession().get(\"loginUser\");\n    }\n\n    /**\n     * 获取当前B端登录用户的当前请求接口的数据范围\n     *\n     * @author xuyuxiang\n     * @date 2022/7/8 10:41\n     **/\n    public static List<String> getLoginUserDataScope() {\n        List<String> resultList = CollectionUtil.newArrayList();\n        getLoginUser().getDataScopeList().forEach(dataScope -> {\n            if(dataScope.getApiUrl().equals(CommonServletUtil.getRequest().getServletPath())) {\n                resultList.addAll(dataScope.getDataScope());\n            }\n        });\n        return resultList;\n    }\n}\n\n~~~\n\n#### 2.2.1 登录逻辑\n\n~~~java\n@Override\n    public String doLogin(\n        AuthAccountPasswordLoginParam authAccountPasswordLoginParam,String type) {\n        // 获取账号\n        String account = authAccountPasswordLoginParam.getAccount();\n        // 获取密码\n        String password = authAccountPasswordLoginParam.getPassword();\n        // 获取设备\n        String device = authAccountPasswordLoginParam.getDevice();\n        // 默认指定为PC，如在小程序跟移动端的情况下，自行指定即可\n        if(ObjectUtil.isEmpty(device)) {\n            //指定为默认值\n            device = AuthDeviceTypeEnum.PC.getValue();\n        } else {\n            AuthDeviceTypeEnum.validate(device);\n        }\n        // 校验验证码\n        String defaultCaptchaOpen = 	 	devConfigApi.getValueByKey(SNOWY_SYS_DEFAULT_CAPTCHA_OPEN_KEY);\n        if(ObjectUtil.isNotEmpty(defaultCaptchaOpen)) {\n            //进行数据类型转换，false的string转为boolean\n            if(Convert.toBool(defaultCaptchaOpen)) {\n                // 获取验证码\n                String validCode = authAccountPasswordLoginParam.getValidCode();\n                // 获取验证码请求号\n                String validCodeReqNo = authAccountPasswordLoginParam.getValidCodeReqNo();\n                // 开启验证码则必须传入验证码\n                if(ObjectUtil.isEmpty(validCode)) {\n                    throw new CommonException(AuthExceptionEnum.VALID_CODE_EMPTY.getValue());\n                }\n                // 开启验证码则必须传入验证码请求号\n                if(ObjectUtil.isEmpty(validCodeReqNo)) {\n                    throw new CommonException(AuthExceptionEnum.VALID_CODE_REQ_NO_EMPTY.getValue());\n                }\n                // 执行校验验证码\n                validValidCode(null, validCode, validCodeReqNo);\n            }\n        }\n        // SM2解密并获得前端传来的密码哈希值\n        String passwordHash;\n        try {\n            // 加密，并做哈希值\n            passwordHash = CommonCryptogramUtil.doHashValue(CommonCryptogramUtil.doSm2Decrypt(password));\n        } catch (Exception e) {\n            throw new CommonException(AuthExceptionEnum.PWD_DECRYPT_ERROR.getValue());\n        }\n        // 根据账号获取用户信息，根据B端或C端判断\n        if(SaClientTypeEnum.B.getValue().equals(type)) {\n            //根据用户账号获取登录用户对象，进行密码校验\n            SaBaseLoginUser saBaseLoginUser = loginUserApi.getUserByAccount(account);\n            if(ObjectUtil.isEmpty(saBaseLoginUser)) {\n                //查找不到对象\n                throw new CommonException(AuthExceptionEnum.ACCOUNT_ERROR.getValue());\n            }\n            //密码不匹配\n            if (!saBaseLoginUser.getPassword().equals(passwordHash)) {\n                throw new CommonException(AuthExceptionEnum.PWD_ERROR.getValue());\n            }\n            // 执行B端登录\n            return execLoginB(saBaseLoginUser, device);\n        } else {	//执行C端登录，不再赘述\n            SaBaseClientLoginUser saBaseClientLoginUser = clientLoginUserApi.getClientUserByAccount(account);\n            if(ObjectUtil.isEmpty(saBaseClientLoginUser)) {\n                throw new CommonException(AuthExceptionEnum.ACCOUNT_ERROR.getValue());\n            }\n            if (!saBaseClientLoginUser.getPassword().equals(passwordHash)) {\n                throw new CommonException(AuthExceptionEnum.PWD_ERROR.getValue());\n            }\n            // 执行C端登录\n            return execLoginC(saBaseClientLoginUser, device);\n        }\n    }\n\n//执行B端登录\nprivate String execLoginB(SaBaseLoginUser saBaseLoginUser, String device) {\n        // 校验状态，即当前账号是否可用\n        if(!saBaseLoginUser.getEnabled()) {\n            //用户已被禁用\n            throw new CommonException(AuthExceptionEnum.ACCOUNT_DISABLED.getValue());\n        }\n        // 执行登录，调用sa-token的登录逻辑\n        StpUtil.login(saBaseLoginUser.getId(), new SaLoginModel().setDevice(device).setExtra(\"name\", saBaseLoginUser.getName()));\n        // 角色集合\n        List<JSONObject> roleList = loginUserApi.getRoleListByUserId(saBaseLoginUser.getId());\n        // 角色id集合\n        List<String> roleIdList = roleList.stream().map(jsonObject -> jsonObject.getStr(\"id\")).collect(Collectors.toList());\n        // 角色码集合\n        List<String> roleCodeList = roleList.stream().map(jsonObject -> jsonObject.getStr(\"code\")).collect(Collectors.toList());\n        // 角色id和用户id集合\n        List<String> userAndRoleIdList = CollectionUtil.unionAll(roleIdList, CollectionUtil.newArrayList(saBaseLoginUser.getId()));\n        // 设置按钮码\n        saBaseLoginUser.setButtonCodeList(loginUserApi.getButtonCodeListListByUserAndRoleIdList(userAndRoleIdList));\n        // 设置移动端按钮码\n        saBaseLoginUser.setMobileButtonCodeList(loginUserApi.getMobileButtonCodeListListByUserIdAndRoleIdList(userAndRoleIdList));\n        // 设置数据范围\n        saBaseLoginUser.setDataScopeList(Convert.toList(SaBaseLoginUser.DataScope.class,\n                loginUserApi.getPermissionListByUserIdAndRoleIdList(userAndRoleIdList, saBaseLoginUser.getOrgId())));\n        // 设置权限码\n        saBaseLoginUser.setPermissionCodeList(saBaseLoginUser.getDataScopeList().stream()\n                .map(SaBaseLoginUser.DataScope::getApiUrl).collect(Collectors.toList()));\n        // 设置角色码\n        saBaseLoginUser.setRoleCodeList(roleCodeList);\n        // 缓存用户信息，此处使用TokenSession为了指定时间内无操作则自动下线，这里与前面设置的权限校验\n    	// 呼应，通过tokenSession，使用loginUser的key获取登录对象\n        StpUtil.getTokenSession().set(\"loginUser\", saBaseLoginUser);\n        // 返回token\n        return StpUtil.getTokenInfo().tokenValue;\n    }\n~~~\n\n#### 2.2.2 校验逻辑\n\n**登录认证**\n\n~~~java\n// 设置鉴权的接口\n                .setAuth(r -> {\n                    // B端的接口校验B端登录\n                    SaRouter.match(\"/**\")\n                            // 排除无需登录接口\n                            .notMatch(CollectionUtil.newArrayList(NO_LOGIN_PATH_ARR))\n                            // 排除C端认证接口\n                            	.notMatch(CollectionUtil.newArrayList(CLIENT_USER_PERMISSION_PATH_ARR))\n                            // 校验B端登录，在这里进行登录逻辑认证\n                            .check(r1 -> StpUtil.checkLogin());\n~~~\n\n~~~java\n//  stpUtil工具类方法\npublic static void checkLogin() {\n    //验证登录状态\n    stpLogic.checkLogin();\n}\n//----------------------------------------------------\n// stpLogic具体业务逻辑类\npublic void checkLogin() {\n    //通过获取登录id，从而验证是否登录\n    this.getLoginId();\n}\n//获取用户id（通过tokenValue进行获取）\npublic Object getLoginId() {\n    //不了解该业务场景\n    if (this.isSwitch()) {\n        return this.getSwitchLoginId();\n    } else {\n        //获取tokenValue\n        String tokenValue = this.getTokenValue();\n        //未登录异常\n        if (tokenValue == null) {\n            throw NotLoginException.newInstance(this.loginType, \"-1\");\n        } else {\n            //获取用户id\n            String loginId = this.getLoginIdNotHandle(tokenValue);\n            //具体业务逻辑不清楚\n            if (loginId == null) {\n                throw NotLoginException.newInstance(this.loginType, \"-2\", tokenValue);\n            } else if (loginId.equals(\"-3\")) {\n                throw NotLoginException.newInstance(this.loginType, \"-3\", tokenValue);\n            } else if (loginId.equals(\"-4\")) {\n                throw NotLoginException.newInstance(this.loginType, \"-4\", tokenValue);\n            } else if (loginId.equals(\"-5\")) {\n                throw NotLoginException.newInstance(this.loginType, \"-5\", tokenValue);\n            } else {\n                //判断该用户的token是否过期\n                this.checkActivityTimeout(tokenValue);\n                //判断是否设置了token自动重置事件\n                if (this.getConfig().getAutoRenew()) {\n                    //重置时间\n                    this.updateLastActivityToNow(tokenValue);\n                }\n				//返回LoginId\n                return loginId;\n            }\n        }\n    }\n}\n~~~\n\n**权限认证**\n\n~~~java\n // B端的超管接口校验B端超管角色\n                    SaRouter.match(\"/**\")\n                            // 排除无需登录接口\n                            .notMatch(CollectionUtil.newArrayList(NO_LOGIN_PATH_ARR))\n                            // 匹配超管接口\n                            .match(CollectionUtil.newArrayList(SUPER_PERMISSION_PATH_ARR))\n                            // 校验B端超管角色，进行角色校验，判断是否有该角色\n                            .check(r1 -> StpUtil.checkRole(SysBuildInEnum.BUILD_IN_ROLE_CODE.getValue()));\n~~~\n\n~~~java\n// stpUtil工具类\npublic static void checkRole(String role) {\n    //检验角色\n    stpLogic.checkRole(role);\n}\n//检验角色，判断是否拥有该角色，没有则抛出异常\npublic void checkRole(String role) {\n    //具体的判断逻辑\n    if (!this.hasRole(role)) {\n        throw new NotRoleException(role, this.loginType);\n    }\n}\n// ---------------------------------------------------------------------------\n// stpLogic业务逻辑类\npublic boolean hasRole(String role) {\n    //判断用户的角色列表是否含有该角色\n    return this.hasElement(this.getRoleList(), role);\n}\n//判断逻辑\npublic boolean hasElement(List<String> list, String element) {\n    return (Boolean)SaStrategy.me.hasElement.apply(list, element);\n}\n//获取当前登录用户的角色列表\npublic List<String> getRoleList() {\n    try {\n        return this.getRoleList(this.getLoginId());\n    } catch (NotLoginException var2) {\n        return SaFoxUtil.emptyList();\n    }\n}\n//具体的获取当前登录用户的角色列表方法\npublic List<String> getRoleList(Object loginId) {\n    //获取认证接口实现类，通过该接口方法获取角色列表\n    return SaManager.getStpInterface().getRoleList(loginId, this.loginType);\n}\n~~~\n\n', '**Snowy框架**的权限功能使用的是sa-token框架，基于sa-token框架实现了登录认证、退出登录、会话管理、踢人下线、注解鉴权、路由拦截鉴权。由于博主只看了部分的sa-token官方文档，只对部分功能进行解析，感兴趣的同学可以自行阅读[官方文档](https://sa-token.cc/index.html)和源码', 1, '', '1', '0', 4, '0', 1, '2023-06-17 16:19:05', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (34, 'Canal数据库监听技术', '# 					Canal数据库监听工具\n\n## 1.理论基础\n\n### 1.1 MySQL主从复制原理\n\n![aa](E:/BaiduNetdiskDownload/canal/课件/images/aa.jpg)\n\n- MySQL master 将数据变更写入二进制日志binary log，简称Binlog。\n\n- MySQL slave 将 master 的 binary log 拷贝到它的中继日志(relay log)\n\n- MySQL slave 重放 relay log 操作，将变更数据同步到最新。\n\n### 1.2 MySQL Binlog日志\n\n#### 1.2.1 介绍\n\nMySQL 的Binlog可以说 MySQL 最重要的日志，它记录了所有的 DDL 和 DML语句，以事件形式记录。\n\nMySQL默认情况下是不开启Binlog，因为记录Binlog日志需要消耗时间，官方给出的数据是有1%的性能损耗。\n\n具体开不开启，开发中需要根据实际情况做取舍。\n\n一般来说，在下面两场景下会开启Binlog日志: \n\n- MySQL 主从集群部署时，需要将在 Master 端开启 Binlog，方便将数据同步到Slaves中。\n\n- 数据恢复了，通过使用 MySQL Binlog 工具来使恢复数据。\n\n\n#### 1.2.2 Binlog的分类\n\nMySQL Binlog 的格式有三种，分别是 STATEMENT,MIXED,ROW。在配置文件中可以选择配\n\n置 binlog_format= **statement**|**mixed**|**row**。\n\n|   分类    | 介绍                                                         |                             优点                             |                             缺点                             |\n| :-------: | :----------------------------------------------------------- | :----------------------------------------------------------: | :----------------------------------------------------------: |\n| STATEMENT | 语句级别，记录每一次执行写操作的语句，相对于ROW模式节省了空间，但是可能产生数据不一致如update tt set create_date=now()，由于执行时间不同产生饿得数据就不同 |                           节省空间                           |                      可能造成数据不一致                      |\n|    ROW    | 行级，记录每次操作后每行记录的变化。假如一个update的sql执行结果是1万行statement只存一条，如果是row的话会把这个1万行的结果存这。 | 持数据的绝对一致性。因为不管sql是什么，引用了什么函数，他只记录执行后的效果 |                         占用较大空间                         |\n|   MIXED   | 是对statement的升级，如当函数中包含 UUID() 时，包含 AUTO_INCREMENT 字段的表被更新时，执行 INSERT DELAYED 语句时，用 UDF 时，会按照 ROW的方式进行处理 |               节省空间，同时兼顾了一定的一致性               | 还有些极个别情况依旧会造成不一致，另外statement和mixed对于需要对binlog的监控的情况都不方便 |\n\n**综合上面对比，Canal 想做监控分析，选择 row 格式比较合适。**\n\n### 1.3 Canal 工作原理\n\n- Canal 将自己伪装为 MySQL slave(从库) ，向 MySQL master (主库)发送dump 协议\n- MySQL master(主库) 收到 dump 请求，开始推送 binary log 给 slave (即 canal )\n- Canal 接收并解析 Binlog 日志，得到变更的数据，执行后续逻辑\n\n## 2.环境准备\n\n### 2.1修改mysql配置文件，开启binlog支持\n\n#### 2.1.1 如何找到my.ini文件\n\n打开服务，找到mysql的服务，右键属性，查看可执行文件路径\n\n\"C:\\Program Files\\MySQL\\MySQL Server 5.7\\bin\\mysqld.exe\" --defaults-file=\"C:\\ProgramData\\MySQL\\MySQL Server 5.7\\my.ini\" MySQL57\n\n可以看到博主的mysql在c盘的ProgramData\n\n#### 2.1.2 修改my.ini文件\n\n```properties\nserver-id=1\nlog-bin=C:/ProgramData/MySQL/MySQL Server 8.0/binlogs/mysql-bin.log\nbinlog_format=row\nbinlog-do-db=canal\n```\n\nserver-id：mysql 实例id，集群时用于区分实例\n\nlob-bin：binlog日志文件名称（注意，这个文件夹一定要自己创建，即binlogs，不然无法正常工作）\n\nbinlog_format：binlog日志数据保存格式\n\nbinlog-do-db：指定开启binlog日志数据库。\n\n注意：一般根据情况进行指定需要同步的数据库，如果不配置则表示所有数据库均开启 Binlog。\n\n修改完之后重启数据库服务，配置文件生效，输入show  VARIABLES like \'log_bin\'，查询到数据为on即binlog生效\n\n### 2.2 安装和配置canal\n\n地址：https://github.com/alibaba/canal/releases，下载最新的deployer版本，解压即可使用\n\n#### 2.2.1修改配置文件\n\ncanal一共有两个配置文件，一个是canal本身的配置文件，一个是具体的数据库配置文件（canal是可以监听多数据库的）\n\n**conf文件夹下的canal.properties是自身的配置文件**\n\n```properties\ncanal.port = 11111\n# tcp, kafka, rocketMQ, rabbitMQ, pulsarMQ，java客户端使用tcp连接\ncanal.serverMode = tcp\n\ncanal.destinations = example\n```\n\ncanal.port：默认端口 11111\n\ncanal.serverMode：服务模式，tcp 表示输入客户端，xxMQ输出到各类消息中间件\n\ncanal.destinations：canal能可以收集多个MySQL数据库数据，每个MySQL数据库都有独立的配置文件控制。具体配置规则： conf/目录下，使用文件夹放置，文件夹名代表一个MySQL实例。canal.destinations用于配置需要监控数据的数据库。如果是多个，使用,隔开\n\n**example文件夹下的instance.properties是具体的数据库配置文件**\n\n```properties\ncanal.instance.mysql.slaveId=20\n\n# position info\ncanal.instance.master.address=127.0.0.1:3306\n\n# username/password\ncanal.instance.dbUsername=root\ncanal.instance.dbPassword=root\n```\n\ncanal.instance.mysql.slaveId：使用canal伪装成从库的id\n\ncanal.instance.master.address：数据库ip端口\n\ncanal.instance.dbUsername：连接mysql账号\n\ncanal.instance.dbPassword：连接mysql密码\n\n**在bin文件夹下，点击startup.bat启动canal程序**\n\n![image-20230618174439883](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230618174439883.png)\n\n默认配置信息为这样，如果你想控制占用的jvm大小，可以修改该启动脚本的命令，找到脚本，右键编辑\n\n~~~bat\n@echo off\n@if not \"%ECHO%\" == \"\"  echo %ECHO%\n@if \"%OS%\" == \"Windows_NT\"  setlocal\n\nset ENV_PATH=.\\\nif \"%OS%\" == \"Windows_NT\" set ENV_PATH=%~dp0%\n\nset conf_dir=%ENV_PATH%\\..\\conf\nset canal_conf=%conf_dir%\\canal.properties\n@rem set canal_conf=%conf_dir%\\canal_local.properties\nif \"%1\" == \"local\" set canal_conf=%conf_dir%\\canal_local.properties\nset logback_configurationFile=%conf_dir%\\logback.xml\n\nset CLASSPATH=%conf_dir%\nset CLASSPATH=%conf_dir%\\..\\lib\\*;%CLASSPATH%\n\nset JAVA_MEM_OPTS= -Xms128m -Xmx512m -XX:PermSize=128m\nset JAVA_OPTS_EXT= -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true -Dapplication.codeset=UTF-8 -Dfile.encoding=UTF-8\nset JAVA_DEBUG_OPT= -server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=9099,server=y,suspend=n\nset CANAL_OPTS= -DappName=otter-canal -Dlogback.configurationFile=\"%logback_configurationFile%\" -Dcanal.conf=\"%canal_conf%\"\n\nset JAVA_OPTS= %JAVA_MEM_OPTS% %JAVA_OPTS_EXT% %JAVA_DEBUG_OPT% %CANAL_OPTS%\n\nset CMD_STR= java %JAVA_OPTS% -classpath \"%CLASSPATH%\" java %JAVA_OPTS% -classpath \"%CLASSPATH%\" com.alibaba.otter.canal.deployer.CanalLauncher\necho start cmd : %CMD_STR%\n\njava %JAVA_OPTS% -classpath \"%CLASSPATH%\" com.alibaba.otter.canal.deployer.CanalLauncher\n~~~\n\n## 3.SpringBoot集成Canal\n\n### 3.1引入依赖\n\n~~~xml\n<dependency>\n    <groupId>top.javatool</groupId>\n    <artifactId>canal-spring-boot-starter</artifactId>\n    <version>1.2.1-RELEASE</version>\n</dependency>\n~~~\n\n### 3.2 添加配置\n\n~~~yml\ncanal:\n  destination: example # canal监听的数据库名字，要与安装canal时设置的名称一致，多数据库用，隔开\n  server: 127.0.0.1:11111 # canal服务地址\n~~~\n\n### 3.3 编写实体类\n\n~~~java\n/**\n * @ClassName User\n * @Description user实体类\n * @Author cc\n * @Date 2023/6/18 16:09\n * @Version 1.0\n */\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Builder\npublic class User {\n\n    private Integer id;\n\n    private String name;\n\n    private Integer age;\n\n}\n~~~\n\n注意：实体类的每个属性不可以为基本数据类型，否则会报错，底层的逻辑是先创建出该对象，然后完成值的初始化，再进行复制。但是在初始化的时候是赋值为null，这里就会出错，所以不可以使用基本数据类型\n\n### 3.4 编写监听类\n\n~~~java\n//交给spring容器管理\n@Component\n//需要监听的表\n@CanalTable(\"user\")\n@Slf4j\n//需要实现EntryHandler<User>接口，泛型为监听的数据库表实体类\npublic class UserHandler implements EntryHandler<User> {\n\n    /**\n     * @param user 插入用户数据对象\n     * @return: void\n     * @decription 监听对象插入\n     * @date 2023/6/18 16:19\n    */\n    @Override\n    public void insert(User user) {\n        //EntryHandler.super.insert(user);\n        log.info(\"新增用户数据---->\"+user);\n    }\n\n    /**\n     * @param before 修改前的用户数据\n     * @param after 修改后的用户数据\n     * @return: void\n     * @decription 监听修改用户对象\n     * @date 2023/6/18 16:20\n    */\n    @Override\n    public void update(User before, User after) {\n        //EntryHandler.super.update(before, after);\n        log.info(\"用户数据被修改\");\n        log.info(\"修改前----->\"+before);\n        log.info(\"修改后----->\"+after);\n    }\n\n    /**\n     * @param user 被删除的用户对象\n     * @return: void\n     * @decription 监听被删除的用户对象\n     * @date 2023/6/18 16:20\n    */\n    @Override\n    public void delete(User user) {\n        //EntryHandler.super.delete(user);\n        log.info(\"删除用户数据------>\"+user);\n    }\n}\n~~~\n\n### 3.5 打印数据问题\n\n启动项目之后，canal客户端程序会启动一个线程，一直监听是否有数据变化，控制台会一直打印，想要取消问题，只能通过反编译进行源码修改\n\n~~~java\npublic abstract class AbstractCanalClient implements CanalClient {\n    protected volatile boolean flag;\n    private Logger log = LoggerFactory.getLogger(AbstractCanalClient.class);\n    private Thread workThread;\n    private CanalConnector connector;\n    protected String filter = \"\";\n    protected Integer batchSize = 1;\n    protected Long timeout = 1L;\n    protected TimeUnit unit;\n    private MessageHandler messageHandler;\n\n    public AbstractCanalClient() {\n        this.unit = TimeUnit.SECONDS;\n    }\n\n    public void start() {\n        this.log.info(\"start canal client\");\n        this.workThread = new Thread(this::process);\n        this.workThread.setName(\"canal-client-thread\");\n        this.flag = true;\n        this.workThread.start();\n    }\n\n    public void stop() {\n        this.log.info(\"stop canal client\");\n        this.flag = false;\n        if (null != this.workThread) {\n            this.workThread.interrupt();\n        }\n\n    }\n\n    public void process() {\n        while(this.flag) {\n            try {\n                this.connector.connect();\n                this.connector.subscribe(this.filter);\n\n                long batchId;\n                for(; this.flag; this.connector.ack(batchId)) {\n                    Message message = this.connector.getWithoutAck(this.batchSize, this.timeout, this.unit);\n                    this.log.info(\"获取消息 {}\", message);\n                    batchId = message.getId();\n                    if (message.getId() != -1L && message.getEntries().size() != 0) {\n                        this.messageHandler.handleMessage(message);\n                    }\n                }\n            } catch (Exception var7) {\n                this.log.error(\"canal client 异常\", var7);\n            } finally {\n                this.connector.disconnect();\n            }\n        }\n\n    }\n\n    public void setConnector(CanalConnector connector) {\n        this.connector = connector;\n    }\n\n    public void setMessageHandler(MessageHandler messageHandler) {\n        this.messageHandler = messageHandler;\n    }\n\n    public CanalConnector getConnector() {\n        return this.connector;\n    }\n\n    public MessageHandler getMessageHandler() {\n        return this.messageHandler;\n    }\n}\n~~~\n\n### 3.6 数据监听成功演示\n\n~~~text\n2023-06-18 16:44:05.063  INFO 4164 --- [l-client-thread] t.j.c.client.client.AbstractCanalClient  : 获取消息 Message[id=5,entries=[header {\n  version: 1\n  logfileName: \"mysql-bin.000001\"\n  logfileOffset: 1322\n  serverId: 1\n  serverenCode: \"UTF-8\"\n  executeTime: 1687077844000\n  sourceType: MYSQL\n  schemaName: \"\"\n  tableName: \"\"\n  eventLength: 73\n}\nentryType: TRANSACTIONBEGIN\nstoreValue: \" \\t\"\n, header {\n  version: 1\n  logfileName: \"mysql-bin.000001\"\n  logfileOffset: 1447\n  serverId: 1\n  serverenCode: \"UTF-8\"\n  executeTime: 1687077844000\n  sourceType: MYSQL\n  schemaName: \"canal\"\n  tableName: \"user\"\n  eventLength: 53\n  eventType: INSERT\n  props {\n    key: \"rowsCount\"\n    value: \"1\"\n  }\n}\nentryType: ROWDATA\nstoreValue: \"\\bl\\020\\001P\\000bj\\022&\\b\\000\\020\\373\\377\\377\\377\\377\\377\\377\\377\\377\\001\\032\\002id \\001(\\0010\\000B\\0015R\\nbigint(20)\\022#\\b\\001\\020\\f\\032\\004name \\000(\\0010\\000B\\003petR\\fvarchar(255)\\022\\033\\b\\002\\020\\004\\032\\003age \\000(\\0010\\000B\\0017R\\aint(11)\"\n, header {\n  version: 1\n  logfileName: \"mysql-bin.000001\"\n  logfileOffset: 1500\n  serverId: 1\n  serverenCode: \"UTF-8\"\n  executeTime: 1687077844000\n  sourceType: MYSQL\n  schemaName: \"\"\n  tableName: \"\"\n  eventLength: 31\n}\nentryType: TRANSACTIONEND\nstoreValue: \"\\022\\003488\"\n],raw=false,rawEntries=[]]\n2023-06-18 16:44:05.113  INFO 4164 --- [xecute-thread-1] com.cc.canal.handler.UserHandler         : 新增用户数据---->User(id=5, name=pet, age=7)\n~~~\n\n## 4.监听流程解析\n\n### 4.1mysql\n\nmysql开启binlog日志，指定需要监听的数据库\n\n### 4.2 canal\n\n在canal.properties配置文件中，配置需要监听的数据库，默认为example。在example的配置文件instance.properties配置具体的数据库信息和登录信息。通过address可以找到具体的mysql，根据该mysql的my.ini配置文件找到具体的数据库\n\n### 4.3 java客户端\n\n配置相应的canal连接地址与需要监听的数据库，即example，编写具体的实体类监听器，监听具体的表\n\n\n\n', 'Alibaba开源框架Canal--数据库监听框架技术总结', 1, '', '1', '0', 21, '0', 1, '2023-06-18 18:08:35', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (35, 'SpringBoot多数据源切换技术', '# 						SpringBoot多数据源切换\n\n## 1.使用场景\n\n### 1.1 业务复杂（多数据源，数据量大）\n\n业务数据庞大，数据拆分成不同的数据库，但是应用没拆，即没有实现系统的分布式或者系统微服务化。此时一个服务需要使用多个数据库，就涉及到了多数据源切换\n\n### 1.2 读写分离（主从复制）\n\n为了解决**数据库的读性能瓶颈（读比写性能更高， 写锁会影响读阻塞，从而影响读的性能）**。\n\n很多数据库拥主从架构。也就是，一台**主**数据库服务器，是对外提供增删改业务的生产服务器；另一（多）台**从**数据库服务器，主要进行读的操作。不同的是，在读写分离中，主库和从库的数据库是一致的(不考虑主从延迟)。数据更新操作(insert、update、delete)都是在主库上进行，主库将数据变更信息同步给从库。在查询时，可以在从库上进行，从而分担主库的压力。\n\n主从复制的具体操作，可以参考Canal数据库监听框架\n\n## 2.项目准备（基础版本）\n\n### 2.1 依赖文件\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>com.mysql</groupId>\n        <artifactId>mysql-connector-j</artifactId>\n        <scope>runtime</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n    </dependency>\n    <!--Druid连接池-->\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid-spring-boot-starter</artifactId>\n        <version>1.2.3</version>\n    </dependency>\n    <!--mybatis-plus-->\n    <dependency>\n        <groupId>com.baomidou</groupId>\n        <artifactId>mybatis-plus-boot-starter</artifactId>\n        <version>3.5.1</version>\n    </dependency>\n</dependencies>\n~~~\n\n### 2.2 基础文件（基础的pojo、mapper就不写了）\n\n**数据源配置，配置多个数据源，用的是Druid连接池**\n\n~~~java\n@Configuration\n@Slf4j\npublic class DataSourceConfig {\n\n    @Bean\n    @ConfigurationProperties(prefix = \"spring.datasource.datasource1\")\n    public DataSource dataSource1() {\n        // 底层会自动拿到spring.datasource中的配置， 创建一个DruidDataSource\n        DruidDataSource dataSource = DruidDataSourceBuilder.create().build();\n        log.info(\"datasource-1:\"+dataSource);\n        return dataSource;\n    }\n\n    @Bean\n    @ConfigurationProperties(prefix = \"spring.datasource.datasource2\")\n    public DataSource dataSource2() {\n        // 底层会自动拿到spring.datasource中的配置， 创建一个DruidDataSource\n        DruidDataSource dataSource = DruidDataSourceBuilder.create().build();\n        log.info(\"datasource-2:\"+dataSource);\n        return dataSource;\n    }\n\n}\n~~~\n\n**动态数据源切换工具类**\n\n~~~java\n@Component\n@Primary   \n// 将该Bean设置为主要注入Bean，项目有多个datasource的bean对象，可以使用该注解，指定注入\n// 具体的数据源逻辑可观看最后的流程图解\npublic class DynamicDataSource implements DataSource, InitializingBean {\n\n\n    // 当前使用的数据源标识\n    public static ThreadLocal<String> name=new ThreadLocal<>();\n\n    // guigu数据库\n    @Autowired\n    DataSource dataSource1;\n    // canal数据库\n    @Autowired\n    DataSource dataSource2;\n\n    @Override\n    public void afterPropertiesSet() {\n        //初始化默认数据源\n        name.set(DataType.GUIGU.getType());\n    }\n\n    @Override\n    public Connection getConnection() throws SQLException {\n        //判断当前线程的数据库标识，当是guigu的时候就切换为数据库1，否则切换到2\n        if(name.get().equals(DataType.GUIGU.getType())){\n            return dataSource1.getConnection();\n        }else {\n            return dataSource2.getConnection();\n        }\n    }\n\n}\n~~~\n\n**服务实现类**\n\n~~~java\n@Service\n@Slf4j\npublic class ArticleServiceImpl {\n\n    @Autowired\n    private ArticleMapper articleMapper;\n\n    public void selectAll(){\n        //切换数据源\n        DynamicDataSource.name.set(DataType.GUIGU.getType());\n        log.info(\"数据源切换成功->\"+DataType.GUIGU.getType());\n        List<Article> articles = articleMapper.selectList(null);\n        articles.forEach(article -> System.out.println(article));\n    }\n}\n\n\n@Service\n@Slf4j\npublic class UserServiceImpl {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    public void selectAll(){\n        //切换数据源\n        DynamicDataSource.name.set(DataType.CANAL.getType());\n        log.info(\"数据源切换成功->\"+DataType.CANAL.getType());\n        List<User> users = userMapper.selectList(null);\n        users.forEach(user -> System.out.println(user));\n    }\n}\n~~~\n\n### 2.3 测试\n\n ~~~java\n@SpringBootTest\nclass DynamicDataSourceApplicationTests {\n\n    @Autowired\n    private ArticleServiceImpl articleService;\n\n    @Autowired\n    private UserServiceImpl userService;\n\n    @Test\n    void contextLoads() {\n    }\n\n    @Test\n    public void testDataSource(){\n        articleService.selectAll();\n        System.out.println(\"---------------------------------------------------\");\n        userService.selectAll();\n    }\n}\n ~~~\n\n**结果**\n\n~~~\n2023-06-19 15:47:22.816  INFO 14940 --- [           main] c.d.service.ArticleServiceImpl           : 数据源切换成功->guigu\n2023-06-19 15:47:23.498  INFO 14940 --- [           main] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} inited\nArticle(id=1, author_id=null, category_id=null, views=11, title=1, content=1)\nArticle(id=2, author_id=null, category_id=null, views=22, title=2, content=2)\nArticle(id=3, author_id=null, category_id=null, views=3, title=3, content=3)\nArticle(id=5, author_id=null, category_id=null, views=5, title=5, content=5)\n---------------------------------------------------\n2023-06-19 15:47:23.575  INFO 14940 --- [           main] c.d.service.UserServiceImpl              : 数据源切换成功->canal\n2023-06-19 15:47:23.594  INFO 14940 --- [           main] com.alibaba.druid.pool.DruidDataSource   : {dataSource-2} inited\nUser(id=1, name=cc, age=24)\nUser(id=2, name=dan, age=24)\nUser(id=3, name=min, age=30)\nUser(id=4, name=grandmother, age=74)\nUser(id=5, name=pet, age=7)\n~~~\n\n## 3. 基于AbstractRoutingDataSource的数据源切换\n\n### 3.1源码分析\n\n```java\npublic abstract class AbstractRoutingDataSource extends AbstractDataSource implements InitializingBean {\n    @Nullable\n    //全部数据源\n    private Map<Object, Object> targetDataSources;\n    @Nullable\n    //默认数据源\n    private Object defaultTargetDataSource;\n    @Nullable\n    //最终数据源\n    private Map<Object, DataSource> resolvedDataSources;\n    @Nullable\n    //最终数据源\n    private DataSource resolvedDefaultDataSource;\n	\n    public AbstractRoutingDataSource() {\n    }\n\n    public void setTargetDataSources(Map<Object, Object> targetDataSources) {\n        this.targetDataSources = targetDataSources;\n    }\n\n    public void setDefaultTargetDataSource(Object defaultTargetDataSource) {\n        this.defaultTargetDataSource = defaultTargetDataSource;\n    }\n\n    public void setLenientFallback(boolean lenientFallback) {\n        this.lenientFallback = lenientFallback;\n    }\n\n    public void setDataSourceLookup(@Nullable DataSourceLookup dataSourceLookup) {\n        this.dataSourceLookup = (DataSourceLookup)(dataSourceLookup != null ? dataSourceLookup : new JndiDataSourceLookup());\n    }\n    \n    \n    //生命周期方法\n    public void afterPropertiesSet() {\n        if (this.targetDataSources == null) {\n            //全部数据库为空则抛异常\n            throw new IllegalArgumentException(\"Property \'targetDataSources\' is required\");\n        } else {\n            //完成数据库对象的复制\n            this.resolvedDataSources = CollectionUtils.newHashMap(this.targetDataSources.size());\n            //主要是对传入的map进行安全校验，不适合的map则会抛出异常\n            this.targetDataSources.forEach((key, value) -> {\n                Object lookupKey = this.resolveSpecifiedLookupKey(key);\n                DataSource dataSource = this.resolveSpecifiedDataSource(value);\n                this.resolvedDataSources.put(lookupKey, dataSource);\n            });\n            if (this.defaultTargetDataSource != null) {\n                //完成默认数据库的复制\n                this.resolvedDefaultDataSource = this.resolveSpecifiedDataSource(this.defaultTargetDataSource);\n            }\n\n        }\n    }	\n    \n    protected Object resolveSpecifiedLookupKey(Object lookupKey) {\n        return lookupKey;\n    }\n\n    protected DataSource resolveSpecifiedDataSource(Object dataSource) throws IllegalArgumentException {\n        if (dataSource instanceof DataSource) {\n            return (DataSource)dataSource;\n        } else if (dataSource instanceof String) {\n            return this.dataSourceLookup.getDataSource((String)dataSource);\n        } else {\n            throw new IllegalArgumentException(\"Illegal data source value - only [javax.sql.DataSource] and String supported: \" + dataSource);\n        }\n    }\n\n    public Map<Object, DataSource> getResolvedDataSources() {\n        Assert.state(this.resolvedDataSources != null, \"DataSources not resolved yet - call afterPropertiesSet\");\n        return Collections.unmodifiableMap(this.resolvedDataSources);\n    }\n\n    @Nullable\n    public DataSource getResolvedDefaultDataSource() {\n        return this.resolvedDefaultDataSource;\n    }\n	\n    //获取数据源链接\n    public Connection getConnection() throws SQLException {\n        return this.determineTargetDataSource().getConnection();\n    }\n\n    //获取具体的链接\n    public Connection getConnection(String username, String password) throws SQLException {				\n        return this.determineTargetDataSource().getConnection(username, password);\n    }\n\n    public <T> T unwrap(Class<T> iface) throws SQLException {\n        return iface.isInstance(this) ? this : this.determineTargetDataSource().unwrap(iface);\n    }\n\n    public boolean isWrapperFor(Class<?> iface) throws SQLException {\n        return iface.isInstance(this) || this.determineTargetDataSource().isWrapperFor(iface);\n    }\n\n    //获取目标数据源\n    protected DataSource determineTargetDataSource() {\n        //非空判断\n        Assert.notNull(this.resolvedDataSources, \"DataSource router not initialized\");\n        //获取数据库标识，即需要重写模板方法\n        Object lookupKey = this.determineCurrentLookupKey();\n        //根据数据库标识，获取具体的数据库对象，从最终数据源获取\n        DataSource dataSource = (DataSource)this.resolvedDataSources.get(lookupKey);\n        //如果最终数据源为空\n        if (dataSource == null && (this.lenientFallback || lookupKey == null)) {\n            //自动获取最终默认数据源\n            dataSource = this.resolvedDefaultDataSource;\n        }\n		//也为空\n        if (dataSource == null) {\n            //抛出异常\n            throw new IllegalStateException(\"Cannot determine target DataSource for lookup key [\" + lookupKey + \"]\");\n        } else {\n            //返回数据源\n            return dataSource;\n        }\n    }\n    \n    //模板方法，返回当前数据库的标识，即数据库map的key，必须重写\n    @Nullable\n    protected abstract Object determineCurrentLookupKey();\n}\n```\n\n### 3.2 重写数据源切换工具类\n\n~~~java\n@Component\n@Primary   // 将该Bean设置为主要注入Bean\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n\n    // 当前使用的数据源标识\n    public static ThreadLocal<String> name=new ThreadLocal<>();\n\n    // 写\n    @Autowired\n    DataSource dataSource1;\n    // 读\n    @Autowired\n    DataSource dataSource2;\n\n    @Override\n    public void afterPropertiesSet() {\n        HashMap<Object, Object> map = CollectionUtils.newHashMap(2);\n        map.put(DataType.GUIGU.getType(),dataSource1);\n        map.put(DataType.CANAL.getType(),dataSource2);\n        //进行全部数据源和默认数据源的配置\n        this.setTargetDataSources(map);\n        this.setDefaultTargetDataSource(dataSource1);\n        //调用父类的生命周期方法\n        super.afterPropertiesSet();\n    }\n\n    //返回当前数据库标识\n    @Override\n    protected Object determineCurrentLookupKey() {\n        return name.get();\n    }\n}\n~~~\n\n## 4. 取消手动切换数据源标识（Mybatis插件）\n\n源程序需要手动切换数据源标识，即DataType，当数据库方法多起来就会显得代码冗余，这里使用插件的方式\n\n**mybatis插件**\n\n~~~java\n//拦截所有curd方法\n@Intercepts(\n        {@Signature(type = Executor.class, method = \"update\", args = {MappedStatement.class, Object.class}),\n        @Signature(type = Executor.class, method = \"query\", args = {MappedStatement.class, Object.class, RowBounds.class,\n                ResultHandler.class})})\npublic class DynamicDataSourcePlugin implements Interceptor {\n\n\n    @Override\n    public Object intercept(Invocation invocation) throws Throwable {\n        // 拿到当前方法(update、query)所有参数\n        Object[] objects = invocation.getArgs();\n\n        // MappedStatement 封装CRUD所有的元素和SQL\n        MappedStatement ms = (MappedStatement) objects[0];\n        // 读方法\n        if (ms.getSqlCommandType().equals(SqlCommandType.SELECT)) {\n\n            DynamicDataSource.name.set(DataType.GUIGU.getType());\n        } else {\n            // 写方法\n            DynamicDataSource.name.set(DataType.CANAL.getType());\n        }\n        // 修改当前线程要选择的数据源的key\n        return invocation.proceed();\n    }\n\n    @Override\n    public Object plugin(Object target) {\n        if (target instanceof Executor) {\n            return Plugin.wrap(target, this);\n        } else {\n            return target;\n        }\n    }\n\n    @Override\n    public void setProperties(Properties properties) {\n\n    }\n}\n~~~\n\n**插件注册**\n\n~~~java\n@Configuration\n@Slf4j\npublic class DataSourceConfig {\n\n    @Bean\n    @ConfigurationProperties(prefix = \"spring.datasource.datasource1\")\n    public DataSource dataSource1() {\n        // 底层会自动拿到spring.datasource中的配置， 创建一个DruidDataSource\n        DruidDataSource dataSource = DruidDataSourceBuilder.create().build();\n        log.info(\"datasource-1:\"+dataSource);\n        return dataSource;\n    }\n\n    @Bean\n    @ConfigurationProperties(prefix = \"spring.datasource.datasource2\")\n    public DataSource dataSource2() {\n        // 底层会自动拿到spring.datasource中的配置， 创建一个DruidDataSource\n        DruidDataSource dataSource = DruidDataSourceBuilder.create().build();\n        log.info(\"datasource-2:\"+dataSource);\n        return dataSource;\n    }\n\n    //完成mybatis的插件注册，由于plus是对其的增强，所以在plus也可以使用mybatis\n   @Bean\n    public Interceptor dynamicDataSourcePlugin(){\n        return new DynamicDataSourcePlugin();\n    }\n}\n~~~\n\n**修改ServiceImpl**\n\n~~~java\npublic class UserServiceImpl {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    public void insert(){\n        //切换数据源\n//        DynamicDataSource.name.set(DataType.CANAL.getType());\n//        log.info(\"数据源切换成功->\"+DataType.CANAL.getType());\n        int insert = userMapper.insert(User.builder().name(\"cc\").age(24).build());\n        log.info(\"完成数据新增\"+insert);\n    }\n}\n\npublic class ArticleServiceImpl {\n\n    @Autowired\n    private ArticleMapper articleMapper;\n\n    public void selectAll(){\n        //切换数据源\n//        DynamicDataSource.name.set(DataType.GUIGU.getType());\n//        log.info(\"数据源切换成功->\"+DataType.GUIGU.getType());\n        List<Article> articles = articleMapper.selectList(null);\n        articles.forEach(article -> System.out.println(article));\n    }\n}\n~~~\n\n## 5. 基于AOP注解实现数据源自动切换\n\n**（对AOP不了解的同学移步Snowy日志框架博客分享）**\n\n**编写注解对象**\n\n~~~java\n//作用范围（写在方法上）\n@Target(ElementType.METHOD)\n//保留方式（runtime，可以通过反射获取注解）\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface DS {\n\n    DataType DATA_TYPE();\n}\n~~~\n\n**编写通知类**\n\n~~~java\n@Component\n@Slf4j\n@Aspect\npublic class DataSourceAspect {\n\n    //自定义切面\n    @Pointcut(\"@annotation(cc.dynamicdatasource.Annotation.DS)\")\n    public void pointCut(){};\n\n    /**\n     * @param proceedingJoinPoint 通知对象，里面封装了很多属性，例如请求的参数\n     * @return: void\n     * @decription 通过前置通知方法获取相应的注解属性，根据属性完成数据库切换\n     * 或者可以使用前置通知，更加方便（JoinPoint joinpPoint，DS ds）直接通过参数获取注解\n     * @date 2023/6/19 19:33\n    */\n    @Around(\"pointCut()\")\n    public Object doBefore(ProceedingJoinPoint proceedingJoinPoint){\n        Object proceed = null;\n        try {\n            log.info(\"进入方法拦截\");\n            //获取被拦截的方法对象\n            MethodSignature methodSignature = (MethodSignature) proceedingJoinPoint.getSignature();\n            //获取被拦截方法的注解对象\n            DS ds = methodSignature.getMethod().getAnnotation(DS.class);\n            //获取注解的属性\n            String type = ds.DATA_TYPE().getType();\n            //切换数据源\n            DynamicDataSource.name.set(type);\n            log.info(\"切换数据源->\"+type);\n            proceed = proceedingJoinPoint.proceed();\n        } catch (Throwable e) {\n            throw new RuntimeException(e);\n        }\n        return proceed;\n    }\n}\n~~~\n\n**修改服务类**\n\n~~~java\npublic class ArticleServiceImpl {\n\n    @Autowired\n    private ArticleMapper articleMapper;\n\n    @DS(DATA_TYPE = DataType.GUIGU)\n    public void selectAll(){\n        //切换数据源\n//        DynamicDataSource.name.set(DataType.GUIGU.getType());\n//        log.info(\"数据源切换成功->\"+DataType.GUIGU.getType());\n        List<Article> articles = articleMapper.selectList(null);\n        articles.forEach(article -> System.out.println(article));\n    }\n}\n\npublic class UserServiceImpl {\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @DS(DATA_TYPE = DataType.CANAL)\n    public void insert(){\n        //切换数据源\n//        DynamicDataSource.name.set(DataType.CANAL.getType());\n//        log.info(\"数据源切换成功->\"+DataType.CANAL.getType());\n        int insert = userMapper.insert(User.builder().name(\"cc\").age(24).build());\n        log.info(\"完成数据新增\"+insert);\n    }\n}\n~~~\n\n**测试**\n\n~~~\n2023-06-19 19:44:02.514  INFO 2224 --- [           main] c.d.aspect.DataSourceAspect              : 进入方法拦截\n2023-06-19 19:44:02.517  INFO 2224 --- [           main] c.d.aspect.DataSourceAspect              : 切换数据源->guigu\n2023-06-19 19:44:02.865  INFO 2224 --- [           main] com.alibaba.druid.pool.DruidDataSource   : {dataSource-1} inited\nArticle(id=1, author_id=null, category_id=null, views=11, title=1, content=1)\nArticle(id=2, author_id=null, category_id=null, views=22, title=2, content=2)\nArticle(id=3, author_id=null, category_id=null, views=3, title=3, content=3)\nArticle(id=5, author_id=null, category_id=null, views=5, title=5, content=5)\n---------------------------------------------------\n2023-06-19 19:44:02.940  INFO 2224 --- [           main] c.d.aspect.DataSourceAspect              : 进入方法拦截\n2023-06-19 19:44:02.940  INFO 2224 --- [           main] c.d.aspect.DataSourceAspect              : 切换数据源->canal\n2023-06-19 19:44:02.968  INFO 2224 --- [           main] com.alibaba.druid.pool.DruidDataSource   : {dataSource-2} inited\n2023-06-19 19:44:02.978  INFO 2224 --- [           main] c.d.service.UserServiceImpl              : 完成数据新增1\n~~~\n\n## 6. DynamicDataSource 多数据源框架\n\n**引入依赖**\n\n~~~xml\n<dependency>\n    <groupId>com.baomidou</groupId>\n    <artifactId>dynamic-datasource-spring-boot-starter</artifactId>\n    <version>2.5.6</version>\n</dependency>\n~~~\n\n**配置文件**\n\n~~~yaml\nspring:\n  application:\n    name: canal\n  datasource:\n    dynamic:\n      #默认数据库\n      primary: master\n      datasource:\n        master:\n          driver-class-name: com.mysql.cj.jdbc.Driver\n          url: jdbc:mysql://localhost/canal?useUnicode=true&characterEncoding=utf-8&serverTimezone=UTC&useSSL=false\n          username: root\n          password: root\n        #当配置了多个同组数据源，即前缀相同，如slave-1，slave-2，使用注解时仅配置@DS(\"slave\")，就会			#进行数据源的负载均衡，默认是轮询\n        slave:\n          driver-class-name: com.mysql.cj.jdbc.Driver\n          url: jdbc:mysql://localhost:3306/guigu?useUnicode=true&characterEncoding=utf-8&serverTimezone=UTC&useSSL=false\n          username: root\n          password: root\n\n\n\nmybatis-plus:\n  # SQL日志输出\n  configuration:\n    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n~~~\n\n**添加注解**\n\n~~~java\n@DS(\"slave\")\n@Repository\npublic interface ArticleMapper extends BaseMapper<Article> {\n}\n\n@DS(\"master\")\n@Repository\npublic interface UserMapper extends BaseMapper<User> {\n}\n//除了放在类上，也可添加在方法上\n~~~\n\n该数据源框架也是使用注解+AOP+AbstractRoutingDataSource的方式，源码就不进行分析了，博主的AOP比较拉，不太能看懂它的底层逻辑。但是它的数据源存储用的是stack，采用了先进后出的思想去解决多数据源嵌套问题，是真的流批。虽然理解不是很难，但是佩服这样的思想。\n\n## 7. 图解数据源流程\n\n![image.png](https://i0.hdslb.com/bfs/new_dyn/f11d3996371d7b983bd5b209c688203b360421727.png)\n\n关键点是理解dataSource的getConnection()方法，所有的数据源切换都是通过控制返回的数据库连接对象实现的', '介绍多种自定义数据源切换和DynamicDataSourceu框架', 1, '', '1', '0', 41, '0', 1, '2023-06-19 20:57:04', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (36, 'Spring笔记总结', '# 								Springboot\n\n## 1.springboot简述\n\nspringboot对spring的缺点进行了改善和优化，基于约定大于配置的思想，简化了spring的开发。springboot的核心功能是自动配置和起步依赖\n\n## 2.@SpringbootApplication注解\n\n里面包含三个重要的注解，包括@springbootconfiguration、@enableautoconfiguration和@componentscan\n\n### 2.1@SpringbootConfiguration\n\n@SpringBootConfifiguration：等同与@Confifiguration，既标注该类是Spring的一个配置类\n\n### 2.2@EnableAutoConfifiguration\n\n@EnableAutoConfifiguration：SpringBoot自动配置功能开启，该注解里面又包含一个@Import注解，而该注解则是自动配置的关键注解\n\n@Import(AutoConfifigurationImportSelector.class) 导入了AutoConfifigurationImportSelector 类，该类的作用是从 META-INF/spring.factories文件中读取指定类对应的类名称列表。上面配置文件存在大量的以 Configuration 为结尾的类名称，这些类就是存有自动配置信息的类，而 SpringApplication 在获取这些类名后再加载。如果我们没有在配置文件中配置信息，SpringBoot就会读取默认配置，而默认配置存放在 META-INF/springconfiguration-metadata.json中。\n\n### 2.3@ComponentScan\n\n自动扫描包的注解，它会自动扫描主类所在包下所有加了注解的类（@Controller，@Service等），以及配置类\n\n（@Configuration）。\n\n### 2.4两个包扫描注解的区别\n\n@ComponentScan和@EnableAutoConfiguration的不同点\n1.两者虽然都能将带有注解的对象放入ioc容器中，但是它们扫描的范围是不一样的。@ComponentScan扫描的范围默认是它所在的包以及子包中所有带有注解的对象，@EnableAutoConfiguration扫描的范围默认是它所在类。\n2.它们作用的对象不一样，@EnableAutoConfiguration除了扫描本类带有的注解外，还会 借助@Import的支持，收集和注册依赖包中相关的bean定义，将这些bean注入到ioc容器中，在springboot中注入的bean有两部分组成，一部分是自己在代码中写的标注有@Controller,@service,@Respority等注解的业务bean，这一部分bean就由@ComponentScan将它们加入到ioc容器中，还有一部分是springboot自带的相关bean，可以将这部分bean看成是工具bean，这部分bean就是由@EnableAutoConfiguration负责加入到容器中。\n3.@EnableAutoConfiguration可以单独启动springboot项目，而@ComponentScan是不能的。\n\n## 3.@ConfigurationProperties\n\n通过 @ConfigurationProperties(prefifix=\"对象\") 可以将配置文件中的配置自动与实体进行映射，这样可以将yml文件中配置的对象属性直接映射到Bean当中。\n\n```java\n@Controller\n@ConfigurationProperties(prefix = \"user\")\npublic class YmlController2 {\n    private int id;\n    private String username;\n    private List<String> address;\n    private List<Grade> grades;\n}\n```\n\n## 4.yaml文件的内置对象\n\nSpringBoot框架提供了一些生成随机数的方法可以在yml文件中使用：\n\n${random.value} ：生成类似uuid的随机数，没有\"-\"连接\n\n${random.uuid} ：生成一个uuid，有短杠连接\n\n${random.int} ：随机取整型范围内的一个值\n\n${random.int(10)}：随机生成一个10以内的数\n\n${random.int(100,200)}：随机生成一个100-200 范围以内的数\n\n${random.long}：随机取长整型范围内的一个值\n\n## 5.bootStrap配置文件\n\nSpringBoot中有两种容器对象，分别是bootstrap和application，bootstrap是应用程序的父容器，bootstrap加载优先于applicaton。bootstrap配置文件主要对bootstrap容器进行配置，application配置文件是对applicaton容器进行配置。bootstrap配置文件也同样支持properties和yml两种格式，主要用于从外部引入Spring应用程序的配置。\n\nbootstrap配置文件特征\n\nboostrap由父ApplicationContext加载，比applicaton优先加载。\n\nboostrap里面的属性不能被覆盖。\n\nbootstrap与application的应用场景\n\napplication配置文件主要用于SpringBoot项目的自动化配置。\n\nbootstrap配置文件有以下几个应用场景。\n\n1.使用Spring Cloud Config配置中心时，需要在bootstrap配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息。\n\n2.一些固定的不能被覆盖的属性。\n\n## 6.Web组件\n\n以下web组件的使用都需要在springboot的启动类中配置@servletcomponentScan注解\n\n### 6.1servlet组件\n\n```java\n@WebServlet(\"/first\")\npublic class FirstServlet extends HttpServlet {\n    public void doGet(HttpServletRequest request, HttpServletResponse response){\n        System.out.println(\"FirstServlet........\");\n   }\n}\n```\n\n### 6.2filter组件\n\n```java\n@WebFilter(urlPatterns = \"/first\")\npublic class FirstFilter implements Filter{\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException { }\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, 							FilterChain filterChain)throws IOException, ServletException {\n        System.out.println(\"进入FirstFilter\");\n      	filterChain.doFilter(servletRequest,servletResponse);\n        System.out.println(\"离开FirstFilter\");\n    }\n    @Override\n    public void destroy() { }\n}\n```\n\n### 6.3listener组件\n\n```java\n@WebListener\npublic class FirstListener implements ServletContextListener {\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n        System.out.println(\"First ListenerInit......\");\n   }\n    @Override\n    public void contextDestroyed(ServletContextEvent sce){}\n}\n```\n\n##  7.参数校验\n\nSpringBoot自带了validation工具可以从后端对前端传来的参数进行校验，用法如下：\n\n添加起步依赖\n\n```xml\n<!-- 参数校验 -->\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-validation</artifactId>\n</dependency>\n```\n\n编写控制器\n\n在校验参数的注解中添加 message 属性，可以替换异常信息。\n\n```java\n// 该控制器开启参数校验\n@Validated\n@Controller\npublic class TestController {\n    @RequestMapping(\"/t1\")\n    @ResponseBody\n    // 在参数前加校验注解，该注解的意思是字符串参数不能为null\n    public String t1(@NotBlank(message =\"用户名不能为空\" String username){\n        System.out.println(username);\n        return \"请求成功！\";\n   }\n}\n```\n\n![image-20230328232625068](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230328232625068.png)\n\n```java\n@RequestMapping(\"/t2\")\n@ResponseBody\npublic String t2(\n        @NotBlank @Length(min = 1, max = 5) String username,\n        @NotNull @Min(0) @Max(150) Integer age,\n        @NotEmpty @RequestParam List<String> address,\n        @NotBlank @Email String email) {\n    System.out.println(username);\n    System.out.println(age);\n    System.out.println(address);\n    System.out.println(email);\n    return \"请求成功！\";\n}\n```\n\n对象参数校验\n\n```java\npublic class Student {\n    @NotNull(message = \"id不能为空\")\n    private Integer id;\n    @NotBlank(message = \"姓名不能为空\")\n    private String name;\n    // 省略getter/setter/tostring\n}\n```\n\n控制器校验\n\n```java\n@Controller\npublic class TestController2 {\n    @RequestMapping(\"/t3\")\n    @ResponseBody\n    // 校验的对象参数前添加@Validated，并将异常信息封装到BindingResult对象中\n    public String t3(@Validated Student student,BindingResult result) {\n        // 判断是否有参数异常\n        if (result.hasErrors()) {\n            // 所有参数异常\n            List<ObjectError> list = result.getAllErrors();\n            // 遍历参数异常，输出异常信息\n            for (ObjectError err : list) {\n                FieldError fieldError = (FieldError) err;\n                System.out.println(fieldError.getDefaultMessage());\n           	}\n            return \"参数异常\";\n       	}\n        System.out.println(student);\n        return \"请求成功！\";\n   }\n}\n```\n\n## 8.指标监控\n\n![image-20230328233124045](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230328233124045.png)\n\n我们可以使用可视化工具Spring Boot Admin查看actuator生成指标数据。Spring Boot Admin是一个独立的项目，我们需要创建并运行该项目。\n\n### 8.1创建服务端（被监控端）\n\n添加起步依赖\n\n```xml\n<dependency>\n    <groupId>de.codecentric</groupId>\n    <artifactId>spring-boot-admin-starter-server</artifactId>\n</dependency>\n```\n\n修改启动类\n\n```java\n@SpringBootApplication\n@EnableAdminServer //开启Spring Boot Admin服务端\npublic class MyadminApplication {\n    public static void main(String[] args){\n      	SpringApplication.run(MyadminApplication.class, args);\n   	}\n}\n```\n\n### 8.2创建客户端（监控端）\n\n添加起步依赖\n\n```xml\n<dependency>\n    <groupId>de.codecentric</groupId>\n    <artifactId>spring-boot-admin-starter-client</artifactId>\n    <version>2.6.0</version>\n</dependency>\n```\n\n修改配置文件\n\n```yaml\n#Spring boot admin访问地址\nspring.boot.admin.client.url=http://localhost:9090\n```\n\n## 9.SpringTask定时任务\n\n### 9.1应用场景\n\n1.购买会员之后，系统会每天给会员发送资源\n\n2.管理系统定时生成报表\n\n3.系统每天做数据备份和系统清理\n\n### 9.2使用方法\n\n在启动类添加@EnableScheduling注解，开启定时任务配置\n\n在定时类上添加@Component注解，交给spring容器管理\n\n在定时方法上添加@Schedule注解，配置定时任务\n\n### 9.3Cron表达式\n\n@Schedule(cron = \"* * * * * *\")\n\nSpringTask依靠cron表达式配置定时规则，cron表达式是一个字符串分为6-7个域，高版本的spring只支持6个域，每个域代表一个含义，以空格分隔，有如下两种格式\n\n①seconds minutes hours  dayOfMonth month dayOfWeek Yeak\n\n②seconds minutes hours  dayOfMonth month dayOfWeek\n\nseconds：域中可以出现 ，- * /四个字符，以及0-59的整数\n\n*:表示匹配任何值，每秒都会触发\n\n,：表示列出的枚举值\n\n-：表示范围值\n\n/：表示起始时间和间隔时间，5/20表示，5s触发一次，之后每隔20s触发一次\n\nminutes与hours同seconds\n\ndayOfMonth：域中可以出现 ，- * / L W C 以及1-31的整数\n\nC:表示和当前日期关联的几天后，且每月的那天都会触发。\n\nL：表示每个月的最后一天\n\nW:表示最靠近的一个工作日，比如15W，则是最靠近15号的工作日，LW表示最后一个工作日\n\nMonth同seconds\n\ndayOfWeek:域中可出现，- * / L # C以及1-7的整数，或星期的英文缩写\n\nC：表示当前日期的几天后触发，且每周的那天都会触发\n\nL：表示一周的最后一天触发\n\n#：前面的数字用来指定具体的星期数，后面的数字用来指定具体的周数，比如5#3就是第三周的星期四\n\nyear同seconds\n\n### 9.4@Schedule注解参数\n\ncron：cron表达式，定义方法的执行规则\n\nfixedDelay：任务立即执行，之后每隔多久执行一次，上次任务结束后计算下次的间隔时间\n\nfixedRate：任务立即执行，之后每隔多久执行一次，上次任务开始后立即计算下次的间隔时间\n\ninitialDelay：项目启动后不立刻执行定时器，根据initialDelay的值延时执行\n\n## 10. Druid连接池技术\n\n### 10.1 依赖\n\n~~~xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n\n    <dependency>\n        <groupId>com.mysql</groupId>\n        <artifactId>mysql-connector-j</artifactId>\n        <scope>runtime</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <optional>true</optional>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n        <scope>test</scope>\n    </dependency>\n    <!--Druid连接池-->\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid-spring-boot-starter</artifactId>\n        <version>1.2.3</version>\n    </dependency>\n    <!--mybatis-plus-->\n    <dependency>\n        <groupId>com.baomidou</groupId>\n        <artifactId>mybatis-plus-boot-starter</artifactId>\n        <version>3.5.1</version>\n    </dependency>\n</dependencies>\n~~~\n\n### 10.2 配置文件\n\n~~~yaml\n# 数据源配置\nspring:\n  datasource:\n    ######### JDBC 基本配置 #########\n    name: test\n    url: jdbc:mysql://127.0.0.1:3306/guigu?serverTimezone=UTC&useUnicode=true&characterEncoding=UTF8&useSSL=false\n    username: root\n    password: root\n    driver-class-name: com.mysql.jdbc.Driver\n    type: com.alibaba.druid.pool.DruidDataSource\n    # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，\'wall\'用于防火墙\n    filters: stat,wall,log4j\n    # 通过connectProperties属性来打开mergeSql功能；慢SQL记录\n    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000\n    # 超过时间限制是否回收\n    removeAbandoned: true\n    # 超时时间；单位为秒。180秒=3分钟\n    removeAbandonedTimeout: 180\n    # 关闭abanded连接时输出错误日志\n    logAbandoned: true\n\n    ## 配置连接池信息\n    druid:\n      ## 初始化大小，最小，最大\n      initial-size: 5\n      min-idle: 5\n      max-active: 30\n      ## 配置获取连接等待超时的时间\n      max-wait: 60000\n      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒\n      time-between-eviction-runs-millis: 60000\n      # 配置一个连接在池中最小生存的时间，单位是毫秒\n      min-evictable-idle-time-millis: 300000\n      max-pool-prepared-statement-per-connection-size: 20\n      pool-prepared-statements: true\n      # 用来测试连接是否可用的SQL语句\n      validation-query: SELECT 1 FROM DUAL\n      # 应用向连接池申请连接，并且testOnBorrow为false时，连接池将会判断连接是否处于空闲状态，如果是，则验证这条连接是否可用\n      test-while-idle: true\n      # 如果为true，默认是false，应用向连接池申请连接时，连接池会判断这条连接是否是可用的\n      test-on-borrow: false\n      # 如果为true（默认false），当应用使用完连接，连接池回收连接的时候会判断该连接是否还可用\n      test-on-return: false\n\n      ######### 配置statViewFilter（配置Druid后台管理Servlet页面），用于展示Druid的统计信息\n      stat-view-servlet:\n        # sql监控开关\n        enabled: true\n        # 访问内置监控页面的路径，内置监控页面的首页是/druid/index.html\n        url-pattern: /druid/*\n        # 是否允许清空统计数据，重新计算  true:允许  false:不允许\n        reset-enable: true\n        # 配置监控页面访问账号密码\n        login-username: root\n        login-password: root\n        # 允许访问的地址，如果allow没有配置或者为空，则允许所有访问\n        allow: 127.0.0.1\n        # 拒绝访问的地址，deny优先于allow，如果在deny列表中，就算在allow列表中，也会被拒绝\n        deny:\n\n      ######### 配置WebStatFilter，用于采集web关联监控的数据#########\n      web-stat-filter:\n        # web url监控\n        enabled: true\n        # session监控\n        session-stat-enable: true\n        # session的最大个数，默认100\n        session-stat-max-count: 1000\n        # 过滤所有url\n        url-pattern: /*\n        # 排除一些不必要的url\n        exclusions: \"*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*\"\n~~~\n\n### 10.3 配置广告过滤器\n\n~~~java\n@Configuration\n@ConditionalOnWebApplication\n@AutoConfigureAfter(DruidDataSourceAutoConfigure.class)\n@ConditionalOnProperty(name = \"spring.datasource.druid.stat-view-servlet.enabled\", havingValue = \"true\",\n        matchIfMissing = true)\npublic class RemoveDruidAdConfig {\n\n    /**\n     * 除去页面底部的广告\n     * @param properties\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean removeDruidAdfilterRegistrationBean(DruidStatProperties properties){\n\n        //获取web监控页面的参数\n        DruidStatProperties.StatViewServlet config = properties.getStatViewServlet();\n        //提取common.js的配置路径\n        String pattern = config.getUrlPattern()!=null?config.getUrlPattern():\"/druid/*\";\n        String commonJsPattern = pattern.replaceAll(\"\\\\*\",\"js/common.js\");\n\n        final String filePath = \"support/http/resources/js/common.js\";\n\n        //创建filter进行过滤\n        Filter filter = new Filter() {\n            @Override\n            public void init(FilterConfig filterConfig) throws ServletException {\n\n            }\n\n            @Override\n            public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n                chain.doFilter(request,response);\n                //重置缓冲区，响应不会被重置\n                response.resetBuffer();\n                //获取common.js\n                String text = Utils.readFromResource(filePath);\n                //正则替换banner,除去底部的广告信息\n                text = text.replaceAll(\"<a.*?banner\\\"></a><br/>\",\"\");\n                text = text.replaceAll(\"powered.*?shrek.wang</a>\",\"\");\n                response.getWriter().write(text);\n            }\n\n            @Override\n            public void destroy() {\n            }\n        };\n\n        FilterRegistrationBean registrationBean = new FilterRegistrationBean();\n        registrationBean.setFilter(filter);\n        registrationBean.addUrlPatterns(commonJsPattern);\n        return registrationBean;\n    }\n}\n~~~\n\n### 10.4 访问测试\n\n**输入项目地址 http://xxxx/durid/便可进入内置监控页面**\n\n![image-20230621091934344](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230621091934344.png)\n\n### 10.5 未涉及之处\n\n- 项目技术只在会用阶段，还未理解配置文件每个字段的具体作用\n- 数据库连接池的内置监控页面大部分字段不了解，不清楚其具体的监听内容\n\n', 'Spring笔记总结V1.0', 1, '', '1', '0', 7, '0', 1, '2023-06-21 14:08:45', 1, '2023-07-05 16:20:00', 0);
INSERT INTO `cc_article` VALUES (37, 'MyBatis&Plus', '# 																										MyBatis\n\n## 1.MyBatis是什么，有什么用\n\n是什么：mybatis是一个半自动的ORM框架（对象映射框架），即将数据库数据映射成对象信息，实际是对JDBC				的封装使用，但是由于我们还是需要自己编写SQL语句，所以说它是半自动的，区别于Hibernate，那就				是全自动的。\n\n有什么用：封装JDBC操作，使程序员更专注于业务操作，而无法关注链接的创建关闭等操作。在不使用ORM框架					之前，我们需要使用JDBC去连接数据库，进行一列写繁琐，技术含量低的代码编写。例如，想获取一					个班级的学生集合，首先就需要加载驱动（Class.forName(com.msyql.jdbc.Driver)）,获取链接					(DriverManager.getConnection(jdbc:msyql://localhots:3306/dataBase?),\"username\",\"password\"),					准备sql语句（String sql = \"select * from students where student.classId = ?）,预编译处理					（connection.preparedStatement(sql)）,动态注入参数（preparedStatement.setInt(12)）,执行查询						（preparedStatement.excuteQuery()）,处理结果集（resultSet），进行一系列的操作。\n\n​					但是有了ORM框架，以MyBatis为例，仅需要编写mapper.xml文件和创建mapper接口就是可以完成					上述操作。\n\n\n\n## 2.mapper映射文件和mapper接口的注意事项（怎么样生效）\n\n1.mapper的namespace属性要写接口的全名\n\n2.标签的id属性是接口的方法名\n\n3.标签的resultType属性是接口方法的返回值类型（全名）\n\n4.parameterType属性是接口方法参数类型\n\n5.xml的包结构和接口的包结构保持一致\n\n## 3.mapper的创建过程\n\n1.创建（new）sqlsessionFactoryBuilder对象\n\n2.通过工厂构造器对象，build（核心配置文件的io流对象）生成sqlSessionFactory工厂。（构造器模式）\n\n3.通过工厂openSession，创建sqlSession对象。（工厂模式）\n\n4.然后通过getMapper(接口对象)生成代理对象。（动态代理模式）\n\n## 4.动态代理过程（不是很透彻）\n\nSqlSession的getMapper方法，最终调用的是jdk的动态代理方法，生成一个代理对象，类型是传入的接口类型。\n\nMapperProxy对象通过调用MapperMethod的excute方法定义了代理方式，该方法的底层调用的是SqlSession的方法。\n\n## 5.模糊查询\n\nmysql中的模糊查询	select * from student where name like \"%cc%\"\n\nmybatis中的模糊查询	包含${}与#{}两种方式\n\n### 5.1${}注入\n\nselect * from student where name like \"%${value}%\" 注意这里的参数名只能写value\n\n### 5.2#{}注入\n\nselect * from student where name like \"%\"#{name}\"%\" 这里的参数名不固定\n\n注意：因为#{}解析成sql语句的时候，会在变量外侧主动加单引号，所以这里的%需要使用双引号，不能使用单引号。\n\n### 5.3二者区别\n\n1.#代表sql模板的占位符，$表示将字符串拼接到sql模板中\n\n2.#可以防止sql注入，$会有sql注入的情况，因为仅仅是字符串替换\n\n3.还有${}内部的参数名只能写value，而#没有要求\n\n### 5.4其他变形\n\n1.使用bind标签\n\n```xml\n<select id=\"findByUsernameLike\" parameterType=\"string\" 																						resultType=\"com.itbaizhan.pojo.User\">\n  <bind name=\"likeName\" value=\"\'%\'+username+\'%\'\"/>\n   select * from user where username like #{likeName}\n</select>\n```\n\n(多一个步骤，其实和直接使用#{}没什么差别)\n\n2.使用concat函数\n\nselect * from student where name like CONCAT(\'%\',#{name},\'%\')\n\n## 6.sql传参方式\n\n1.顺序传参，使用arg0，arg1或者param1，param2	不推荐使用，代码可读性较差\n\n2.@param传参，@param(\"start\") int start	可以指定参数的名称，更加直观\n\n3.pojo传参，该类属性就是要传递的参数，在sql语句中绑定参数时使用pojo的属性名作为参数名即可\n\n4.map传参，使用map的key作为参数名，value作为注入的值\n\n## 7.主键回填\n\n### 7.1selectKey,获取非自增主键值\n\n```xml\n<selectKey KeyProperty=\"id\" keyColumn=\"id\" resultType=\"int\" order=\"AFTER\">\n	select LAST_INSERT_ID();\n</selectKey>\n```\n\n### 7.2useGeneratedKeys,开启自动获取自增主键值\n\n```xml\n<!--添加用户获取主键值[自增]-->\n<insert id=\"insertUsersGetKey\" useGeneratedKeys=\"true\"\nkeyProperty=\"userid\">\n	insert into users values(default ,#{username},#{usersex})\n</insert>\n```\n\n\n\n## 8.sql查询的字段名和pojo属性名不一致\n\n1.在sql语句中使用别名 tid as id\n\n2.使用自定义映射关系\n\n```xml\n<resultMap id=\"\" type=\"\">\n	<id></id>\n	<result></result>\n</resultMap>\n```\n\n\n\n## 9.sql代码块\n\n```xml\n<sql id=\"suchas\">\n	select * from student\n</sql>\n//注入\n<include refid=\"suchas\"></include> where id = 1;\n```\n\n\n\n## 10.动态sql\n\n```xml\nselect * from user\n<where>\n    <if test=\"username != null and username.length() != 0\">\n        username like \"%\"#{username}\"%\"\n    </if>\n    <if test=\"sex != null\">\n      	sex = #{sex};\n    </if>\n</where>\n```\n\n```xml\nupdate user\n<set>\n	<if test=\"username != null and username.length() != 0\">\n        username like \"%\"#{username}\"%\"\n    </if>\n    <if test=\"sex != null\">\n      	sex = #{sex}\n    </if>\n</set>\n<where>\n    id = #{id}\n</where>\n```\n\n```xml\nselect * from user\n<where>\n    <choose>\n        <when test=\"username != null\"> \n            username like \"%\"#{username}\"%\"\n        </when>\n        <otherwise>\n            id = 1\n        </otherwise>\n    </choose>\n</where>\n    \n```\n\n## 11.动态查询\n\ncollection:遍历的对象类型\n\nopen:开始的sql语句\n\nclose:结束的sql语句\n\nseparator:遍历每项间的分隔符\n\nitem:表示本次遍历获取的元素,遍历list,set,数组时表示每项元素,map的时候表示键值对的值\n\nindex:遍历list,set,数组的时候表示遍历的索引,遍历map的时候表示键值对的键\n\n```xml\ndelete from user\n<where>\n    <foreach open=\"id in (\" close=\")\" separator=\",\" collection=\"array\" item=\"id\">\n        #{id}\n    </foreach>\n</where>\n```\n\n```xml\ninsert into user values\n<foreach collection=\"list/set\" item=\"user\" separator=\",\">\n    (null,#{user.name},#{user.age})\n</foreach>\n```\n\nList<User> findUser(@Param(\"queryMap\") Map<String,Object> map)注意,使用map进行遍历的时候,需要指定map的名称\n\n```xml\nselect * from user\n<where>\n    <foreach collection=\"queryMap\" separator=\"and\" index=\"key\" item=\"value\">\n        ${key} = #{value}\n    </foreach>\n</where>\n```\n\n## 12.SQL缓存\n\n### 12.1介绍\n\n缓存是内存中一块存储数据的区域,目的是提高查询效率.mybatis会将查询结果存储在缓存中,当下次执行相同的sql时,不再访问数据库,而是直接从缓存中获取结果,减少访问数据库的次数,降低服务器的压力\n\n缓存分为一次缓存和二次缓存\n\n### 12.2如何判定两次sql相同\n\n1.查询的sql语句相同\n\n2.传递的参数相同\n\n3.对结果集的要求相同\n\n4.预编译的模板id相同\n\n### 12.3一级缓存原理介绍\n\nmybatis一级缓存也叫本地缓存.sqlsession对象中包含一个excutor对象,里面又包含一个prepetualCache对象,在该对象中存放一级缓存数据.由于一次缓存存储在sqlsession中,所以只有使用同一个sqlsession对象操作数据库时才能共享一次缓存.一级缓存默认开启\n\n如果 SqlSession 调用了 close()方法，会释放掉一级缓存 PerpetualCache 对象，一级缓存将不可用。\n\n 如果 SqlSession 调用了 clearCache()，会清空 PerpetualCache 对象中的数据，但是该对象仍可使用。\n\n SqlSession 中执行了任何一个 update 操作(update()、delete()、insert()) ，都会清空PerpetualCache 对象的数据，但是该对象可以继续使用。\n\n### 12.4二级缓存原理介绍\n\nMyBatis 的二级缓存是 Application 级别的缓存，它可以提高对数据库查询的效率，以提高应用的性能。二级缓存是 SqlSessionFactory 上的缓存，可以是由一个 SqlSessionFactory 创建的不同的 SqlSession 之间共享缓存数据。默认并不开启。SqlSession 在执行 commit()或者 close()的时候将数据放入到二级缓存。二级缓存保存在CachingExcutor对象中,当执行查询sql时,会先去二次缓存查找,再去一次缓存查询,再与数据库交互.二级缓存是默认关闭的.而且缓存的pojo必须实现序列化接口.在映射配置文件中配置<cache/>就可以开启缓存了.\n\n映射语句文件中的所有 select 语句将会被缓存。\n\n映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。\n\n二级缓存是以 namespace 为单位的，不同 namespace 下的操作互不影响\n\n如果在加入<cache/>标签的前提下让个别 select 元素不使用缓存，可以使用 useCache属性，设置为 false。\n\n 缓存会使用默认的 Least Recently Used（LRU，最近最少使用的）算法来收回。\n\n缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用.当集合元素过多时,只能保存1024个对象\n\n缓存会被视为是 read/write(可读/可写)的缓存，意味着对象检索不是共享的，而且可以安全的被调用者修改，不干扰其他调用者或线程所做的潜在修改。\n\n为什么二级缓存需要实现序列化接口呢,因为二级缓存查询到的是对象的数据,然后再把这些数据封装成一个新的对象,尽管对象的内容相同,但是hashcode已经不同了,区别于一级缓存(hashcode相同)\n\n开启二级缓存\n\n![image-20230324013216960](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230324013216960.png)\n\n亦或者在mapper接口上方添加@CacheNamespace(blocking = true),该接口的所有方法都支持二级缓存\n\n## 13.关联查询\n\nassociation:标签是处理单一的关联对象(处理单一属性的关联关系)。\n\nproperty：指定关联对象的属性\n\njavaType：关联对象的类型（可以省略）\n\ncolumn：在新的查询中用哪个列的值作为查询条件(可省略)\n\n一对一关联查询\n\n```xml\n<resultMap id=\"usersAndRolesMapper\" type=\"com.bjsxt.pojo.Users\">\n	<id property=\"userid\" column=\"userid\"/>\n	<result property=\"username\" column=\"username\"/>\n	<result property=\"usersex\" column=\"usersex\"/>\n	<association property=\"roles\" javaType=\"com.bjsxt.pojo.Roles\">\n		<id property=\"roleid\" column=\"roleid\"/>\n		<result property=\"rolename\" column=\"rolename\"/>\n	</association>\n</resultMap>\n```\n\n一对多关联查询\n\ncollection:标签是处理所关联对象是多个的(处理关联属性是集合时的关联关系)。\n\nproperty：指定关联对象的属性\n\njavaType：关联对象的类型（可以省略。默认为 List 类型，如果集合是 Set 类型时需要配置并给定 Set 的全名）\n\nofType：指定集合里存放的对象类型\n\ncolumn：在新的查询中用哪个列的值作为查询条件(可省略)\n\n```xml\n<resultMap id=\"usersAndOrdersMapper\" type=\"com.bjsxt.pojo.Users\">\n	<id property=\"userid\" column=\"userid\"/>\n	<result property=\"username\" column=\"username\"/>\n	<result property=\"usersex\" column=\"usersex\"/>\n	<collection property=\"orders\" ofType=\"com.bjsxt.pojo.Orders\">\n		<id property=\"orderid\" column=\"orderid\"/>\n		<result property=\"orderprice\" column=\"orderprice\"/>\n	</collection>\n</resultMap>\n```\n\n多对多关联查询\n\n```xml\n<resultMap id=\"usersAndOrdersAndItems\" type=\"com.bjsxt.pojo.Users\">\n	<id property=\"userid\" column=\"userid\"/>\n	<result property=\"username\" column=\"username\"/>\n	<result property=\"usersex\" column=\"usersex\"/>\n	<collection property=\"orders\" ofType=\"com.bjsxt.pojo.Orders\">\n		<id property=\"orderid\" column=\"orderid\"/>\n		<result property=\"orderprice\" column=\"orderprice\"/>\n		<collection property=\"items\" ofType=\"com.bjsxt.pojo.Items\">\n			<id property=\"itemid\" column=\"itemid\"/>\n			<result property=\"itemid\" column=\"itemid\"/>\n			<result property=\"itemname\" column=\"itemname\"/>\n			<result property=\"itemprice\" column=\"itemprice\"/>\n		</collection>\n	</collection>\n</resultMap>\n```\n\n## 14.分解式查询\n\n使用内连接或者外连接的方式查询数据。\n\n优点：在一次查询中完成数据的查询操作。降低查询次数提高查询效率。\n\n缺点：如果查询返回的结果集较多会消耗内存空间。\n\n\n\n分解式查询，将查询分解成多个 SQL 语句。(又称N+1查询)\n\n优点：配和着延迟加载可实现结果集分步获取，节省内存空间。\n\n缺点：由于需要执行多次查询，相比连接查询效率低\n\n\n\n使用延迟加载要求：\n\n查询方式需要使用 N+1 次查询。\n\n在映射配置文件或者全局配置文件中开启延迟加载\n\n开启延迟加载方式：\n\n在<association>、<collection>标签中通过 fetchType 属性开启延迟加载，仅针对当前标签生效。fectType:lazy 开启延迟加载，\n\nfectType:eager 开启立即加载。\n\n通过 select 属性指定需要执行的查询的 ID。通过 column 属性指定将封装查询结果对象的哪个属性的值作为下一个查询的查询条件。\n\n在全局配置文件中的<settings>标签中开启延迟加载，所有的 association 和 collection 元素都生效。<setting name=\"lazyLoadingEnabled\" value=\"true\"/>\n\n 配置触发加载方法，lazyLoadTriggerMethods：指定实体对象的哪个方法触发一次加载。\n\n一般情况下,一对一使用立即加载,一对多使用延迟加载\n\n```xml\n<!--延迟加载-->\n<resultMap id=\"usersAndOrdersMapperLazy\" type=\"com.bjsxt.pojo.Users\">\n	<id property=\"userid\" column=\"userid\"/>\n	<result property=\"username\" column=\"username\"/>\n	<result property=\"usersex\" column=\"usersex\"/>\n	<collection property=\"orders\" ofType=\"com.bjsxt.pojo.Orders\"\n		fetchType=\"lazy\" select=\"selectOrdersByUserId\" column=\"userid\"/>\n</resultMap>\n<!--根据用户 ID 查询用户-->\n<select id=\"selectUsersByIdLazy\" resultMap=\"usersAndOrdersMapperLazy\">\n	select * from users where userid = #{userid}\n</select>\n<!--根据用户 ID 查询订单-->\n<select id=\"selectOrdersByUserId\" resultType=\"com.bjsxt.pojo.Orders\">\n	select * from orders where user_id = #{userid}\n</select>\n```\n\n## 15.分页查询\n\n### 15.1RowBounds\n\nRowBounds 是 Mybatis 提供的一个专门处理分页的对象。在 RowBounds 对象中有两个\n\n成员变量：\n\noffset：偏移量，从 0 开始计数\n\nlimit：限制条数\n\n使用 RowBounds 进行分页，非常方便，不需要在 SQL 语句中写 limit，即可完成分页\n\n功能。但是由于它是在 SQL 查询出所有结果的基础上截取数据的，所以在数据量大的 SQL\n\n中并不适用，它更适合在返回数据结果较少的查询中使用。\n\n```java\nList<Users> selectUsersRowBounds(RowBounds rowBounds);\n```\n\n### 15.2SQL语句分页\n\n在分页查询时，如果返回的结果较多，那么需要使用特定的 SQL 语句来实现分页处理。\n\n在 MySQL 数据库中我们可以使用 limit 实现分页。磁盘分页,不会把数据全部加载到内存\n\n```xml\n<!--查询所有数据使用 limit 实现分页处理-->\n<select id=\"selectUsersLimit\" resultType=\"users\">\n	select * from users limit #{offset},#{limit}\n</select>\n```\n\n# 									PLUS\n\n## 1.@mapperscan注解\n\n在springboot启动类中添加@mapperscan注解，扫描mapper文件夹\n\n## 2.开启SQl日志打印\n\n```yaml\nmybatis-plus:\n configuration:\n   log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n```\n\n## 3.sql查询的字段名和pojo属性名不一致\n\n**@TableName**\n\n作用：指定类为哪个表的实体类\n\n位置：类上方\n\n**@TableId**\n\n作用：指定实体类的属性为主键\n\n位置：属性上方\n\n属性：\n\nvalue：主键字段名\n\n![image-20230325001440519](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230325001440519.png)\n\n**@TableField**\n\n作用：在属性和列名不同的情况下，指定映射关系\n\n位置：非主键属性上方\n\n## 4.mybatisplus的基本使用\n\npojomapper.updateById()\n\npojomapper.deleteBatchIds()\n\npojomapper.deleteByMap()\n\npojomapper.selectBatchIds()\n\npojomapper.selectByMap()\n\n## 5.复杂条件查询\n\nMybatis-Plus通过QueryWrapper对象让用户自由的构建SQL条\n\n件，简单便捷，没有额外的负担，能够有效提高开发效率。\n\n![image-20230325001907716](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230325001907716.png)\n\n![image-20230325001935266](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230325001935266.png)\n\n注：构造时使用的是数据库字段，不是Java属性\n\n## 6.分页\n\n在配置类(@configuration)或启动类(@springbootapplication)配置分页插件\n\n```java\n@Bean\npublic MybatisPlusInterceptor mybatisPlusInterceptor() {\n    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();\n    interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));\n    return interceptor;\n}\n```\n\n分页实战\n\n```java\n//创建分页条件，从第0条数据开始，获取两条数据\nPage page = new Page(2,2);\n// 分页查询\nIPage<Student> iPage = studentMapper.selectPage(page, wrapper);\n// 打印分页数据\n    System.out.println(\"结果\n集：\"+iPage.getRecords());\n    System.out.println(\"总页\n数：\"+iPage.getPages());\n    System.out.println(\"总条\n数：\"+iPage.getTotal());\n    System.out.println(\"当前\n页：\"+iPage.getCurrent());\n    System.out.println(\"每页条\n数：\"+iPage.getSize());\n```\n\n## 7.全局配置\n\n假如数据库的所有表都以 tb_ 开头，主键都是自增的。如果针对每一\n\n个实体类都要添加相关注解比较麻烦，可以在SpringBoot配置文件\n\n中进行全局配置，该配置在所有的实体类中都生效。\n\n```yaml\nmybatis-plus:\n  # 全局配置\n global-config:\n   db-config:\n      #主键类型\n     id-type: AUTO\n      # 设置表名前缀\n     table-prefix: tb_\n      # 是否使用驼峰转下划线命名，默认开启\n     table-underline: true\n```\n\n## 8.mybatisplus插件概述\n\n**MyBatis插件机制**\n\nMyBatis插件就是对Executor、StatementHandler、ParameterHandler、ResultSetHandler这四个接口上的方法进行拦截，利用JDK动态代理机制，为这些接口的实现类创建代理对象，在执行方法时，先去执行代理对象的方法，从而执行自己编写的拦截逻辑。\n\nExecutor\n\nMyBatis的内部执行器，它负责调用StatementHandler操作数\n\n据库，并把结果集通过 ResultSetHandler进行自动映射。\n\n\n\nStatementHandler\n\nMyBatis直接让数据库执行sql脚本的对象。\n\n\n\nParameterHandler\n\nMyBatis实现Sql入参设置的对象。\n\n\n\nResultSetHandler\n\nMyBatis把ResultSet集合映射成POJO的接口对象。\n\n常用插件：\n\n自动分页: PaginationInnerInterceptor\n\n防止全表更新与删除: BlockAttackInnerInterceptor\n\n乐观锁: OptimisticLockerInnerInterceptor\n\n这些插件都实现了InnerInterceptor接口\n\n## 9.乐观锁\n\n![image-20230325003409320](C:\\Users\\PC\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230325003409320.png)\n\n注册乐观锁插件addinnerInterceptor\n\n修改实体类，添加version列并在该属性上面增加@Version\n\n修改数据库表，添加一列整型version字段并设置默认值为0\n\n## 10.逻辑删除\n\n在实际开发中，由于数据十分重要，为了避免误删除数据导致数据无法找回，我们往往不会使用物理删除，即从数据库中直接删除数据。而是采用逻辑删除的方式，即不会真正在数据库删除数据，而是通过一个变量代表它被除。\n\ndeleted属性代表该数据是否删除，0代表未删除，1代表已删除。此时增删改查的Sql语句发生变化：\n\n插入: 不作限制\n\n查找: 追加where条件过滤掉已删除数据。\n\n更新: 追加where条件防止更新到已删除数据。\n\n删除: 转变为更新\n\n例如:\n\n删除: update user set deleted=1 where id = 1 and deleted=0\n\n查找: select id,name,deleted from user where deleted=0\n\n```yaml\n# mybatis-plus相关配置\nmybatis-plus:\n  # 全局配置\n global-config:\n   db-config:\n      # 全局逻辑删除的字段名\n     logic-delete-field: deleted\n      # 逻辑已删除值(默认为 1)\n     logic-delete-value: 1\n      # 逻辑未删除值(默认为 0)\n     logic-not-delete-value: 0\n```\n\n修改实体类，添加逻辑删除属性，并在属性上方添加@TableLogic注解\n\n修改数据库表，添加一列整型deleted字段并设置默认值为0\n\n测试删除和查询方法，会看到删除时将deleted字段变为1，查询时添加条件deleted=0\n\n## 11.自动填充\n\n填充配置类，需要交给spring容器管理才可以生效\n\n~~~java\npublic class MyMetaObjectHandler implements MetaObjectHandler {\n\n    /**\n     * @param metaObject 数据对象\n     * @return: void\n     * @decription 当数据对象进行新增的时候，完成相应字段的自动填充\n     * @date 2023/5/5 14:57\n    */\n    @Override\n    public void insertFill(MetaObject metaObject) {\n        Long userId = null;\n  \n        try {\n            userId = SecurityUtils.getUserId();\n        } catch (Exception e) {\n            e.printStackTrace();\n            userId = -1L;//表示是自己创建\n        }\n        this.setFieldValByName(\"createTime\", new Date(), metaObject);\n        this.setFieldValByName(\"createBy\",userId , metaObject);\n        this.setFieldValByName(\"updateTime\", new Date(), metaObject);\n        this.setFieldValByName(\"updateBy\", userId, metaObject);\n    }\n\n    /**\n     * @param metaObject 数据对象\n     * @return: void\n     * @decription 当数据对象完成修改的时候，完成相应字段的自动填充\n     * @date 2023/5/5 15:01\n    */\n    @Override\n    public void updateFill(MetaObject metaObject) {\n        this.setFieldValByName(\"updateTime\", new Date(), metaObject);\n        this.setFieldValByName(\"updateBy\", SecurityUtils.getUserId(), metaObject);\n    }\n}\n~~~\n\n实体类需要加上相应的注解\n\n~~~java\npublic class Tag{\n    \n    private Long id;\n    //标签名\n    private String name;\n	//对象新增时自动填充\n    @TableField(fill = FieldFill.INSERT)\n    private Long createBy;\n\n    @TableField(fill = FieldFill.INSERT)\n    private Date createTime;\n	//对象新增或修改时自动填充\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Long updateBy;\n\n    @TableField(fill = FieldFill.INSERT_UPDATE)\n    private Date updateTime;\n\n    //删除标志（0代表未删除，1代表已删除）\n    private Integer delFlag;\n    //备注\n    private String remark;\n\n}\n~~~\n\n', 'mybatis与plus总结，暂未完结（缺少动态代理和拦截器）', 1, '', '1', '0', 12, '0', 1, '2023-07-04 00:26:59', 1, '2023-07-05 16:20:00', 0);

-- ----------------------------
-- Table structure for cc_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `cc_article_tag`;
CREATE TABLE `cc_article_tag`  (
  `article_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `tag_id` bigint(20) NOT NULL DEFAULT 0 COMMENT '标签id',
  PRIMARY KEY (`article_id`, `tag_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 38 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '文章标签关联表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of cc_article_tag
-- ----------------------------
INSERT INTO `cc_article_tag` VALUES (1, 4);
INSERT INTO `cc_article_tag` VALUES (2, 1);
INSERT INTO `cc_article_tag` VALUES (2, 4);
INSERT INTO `cc_article_tag` VALUES (3, 4);
INSERT INTO `cc_article_tag` VALUES (3, 5);
INSERT INTO `cc_article_tag` VALUES (5, 1);
INSERT INTO `cc_article_tag` VALUES (5, 4);
INSERT INTO `cc_article_tag` VALUES (5, 6);
INSERT INTO `cc_article_tag` VALUES (8, 1);
INSERT INTO `cc_article_tag` VALUES (8, 4);
INSERT INTO `cc_article_tag` VALUES (8, 6);
INSERT INTO `cc_article_tag` VALUES (9, 7);
INSERT INTO `cc_article_tag` VALUES (10, 7);
INSERT INTO `cc_article_tag` VALUES (10, 8);
INSERT INTO `cc_article_tag` VALUES (11, 8);
INSERT INTO `cc_article_tag` VALUES (12, 1);
INSERT INTO `cc_article_tag` VALUES (12, 4);
INSERT INTO `cc_article_tag` VALUES (12, 6);
INSERT INTO `cc_article_tag` VALUES (13, 4);
INSERT INTO `cc_article_tag` VALUES (14, 7);
INSERT INTO `cc_article_tag` VALUES (14, 8);
INSERT INTO `cc_article_tag` VALUES (15, 7);
INSERT INTO `cc_article_tag` VALUES (15, 8);
INSERT INTO `cc_article_tag` VALUES (16, 7);
INSERT INTO `cc_article_tag` VALUES (16, 8);
INSERT INTO `cc_article_tag` VALUES (17, 7);
INSERT INTO `cc_article_tag` VALUES (17, 8);
INSERT INTO `cc_article_tag` VALUES (18, 7);
INSERT INTO `cc_article_tag` VALUES (18, 8);
INSERT INTO `cc_article_tag` VALUES (19, 7);
INSERT INTO `cc_article_tag` VALUES (19, 8);
INSERT INTO `cc_article_tag` VALUES (20, 4);
INSERT INTO `cc_article_tag` VALUES (20, 6);
INSERT INTO `cc_article_tag` VALUES (21, 4);
INSERT INTO `cc_article_tag` VALUES (22, 7);
INSERT INTO `cc_article_tag` VALUES (22, 8);
INSERT INTO `cc_article_tag` VALUES (23, 4);
INSERT INTO `cc_article_tag` VALUES (24, 7);
INSERT INTO `cc_article_tag` VALUES (24, 8);
INSERT INTO `cc_article_tag` VALUES (25, 7);
INSERT INTO `cc_article_tag` VALUES (25, 8);
INSERT INTO `cc_article_tag` VALUES (26, 7);
INSERT INTO `cc_article_tag` VALUES (26, 8);
INSERT INTO `cc_article_tag` VALUES (27, 7);
INSERT INTO `cc_article_tag` VALUES (27, 8);
INSERT INTO `cc_article_tag` VALUES (28, 4);
INSERT INTO `cc_article_tag` VALUES (28, 6);
INSERT INTO `cc_article_tag` VALUES (28, 9);
INSERT INTO `cc_article_tag` VALUES (29, 4);
INSERT INTO `cc_article_tag` VALUES (29, 10);
INSERT INTO `cc_article_tag` VALUES (30, 4);
INSERT INTO `cc_article_tag` VALUES (30, 10);
INSERT INTO `cc_article_tag` VALUES (31, 4);
INSERT INTO `cc_article_tag` VALUES (31, 10);
INSERT INTO `cc_article_tag` VALUES (32, 4);
INSERT INTO `cc_article_tag` VALUES (32, 6);
INSERT INTO `cc_article_tag` VALUES (32, 10);
INSERT INTO `cc_article_tag` VALUES (32, 11);
INSERT INTO `cc_article_tag` VALUES (33, 4);
INSERT INTO `cc_article_tag` VALUES (33, 6);
INSERT INTO `cc_article_tag` VALUES (33, 10);
INSERT INTO `cc_article_tag` VALUES (33, 11);
INSERT INTO `cc_article_tag` VALUES (34, 4);
INSERT INTO `cc_article_tag` VALUES (34, 10);
INSERT INTO `cc_article_tag` VALUES (34, 11);
INSERT INTO `cc_article_tag` VALUES (35, 4);
INSERT INTO `cc_article_tag` VALUES (35, 10);
INSERT INTO `cc_article_tag` VALUES (35, 11);
INSERT INTO `cc_article_tag` VALUES (36, 4);
INSERT INTO `cc_article_tag` VALUES (36, 6);
INSERT INTO `cc_article_tag` VALUES (36, 10);
INSERT INTO `cc_article_tag` VALUES (37, 1);
INSERT INTO `cc_article_tag` VALUES (37, 4);

-- ----------------------------
-- Table structure for cc_audience
-- ----------------------------
DROP TABLE IF EXISTS `cc_audience`;
CREATE TABLE `cc_audience`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键id\r\n',
  `ip` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '请求ip\r\n',
  `address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '归属地',
  `date` datetime(0) NULL DEFAULT NULL COMMENT '浏览时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 346 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of cc_audience
-- ----------------------------
INSERT INTO `cc_audience` VALUES (1, '0:0:0:0:0:0:0:1', NULL, NULL);
INSERT INTO `cc_audience` VALUES (2, '0:0:0:0:0:0:0:1', NULL, NULL);
INSERT INTO `cc_audience` VALUES (3, '0:0:0:0:0:0:0:1', NULL, NULL);
INSERT INTO `cc_audience` VALUES (4, '183.30.179.7', NULL, NULL);
INSERT INTO `cc_audience` VALUES (5, '223.104.122.175', NULL, NULL);
INSERT INTO `cc_audience` VALUES (6, '112.2.251.179', NULL, NULL);
INSERT INTO `cc_audience` VALUES (7, '117.172.173.31', NULL, NULL);
INSERT INTO `cc_audience` VALUES (8, '183.30.179.7', NULL, NULL);
INSERT INTO `cc_audience` VALUES (9, '27.191.196.4', NULL, NULL);
INSERT INTO `cc_audience` VALUES (10, '183.94.140.41', NULL, NULL);
INSERT INTO `cc_audience` VALUES (11, '182.118.239.231', NULL, NULL);
INSERT INTO `cc_audience` VALUES (12, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (13, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (14, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (15, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (16, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (17, '117.150.198.25', NULL, NULL);
INSERT INTO `cc_audience` VALUES (18, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (19, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (20, '117.150.198.134', NULL, NULL);
INSERT INTO `cc_audience` VALUES (21, '117.150.198.134', NULL, NULL);
INSERT INTO `cc_audience` VALUES (22, '117.150.198.134', NULL, NULL);
INSERT INTO `cc_audience` VALUES (23, '222.190.126.147', NULL, NULL);
INSERT INTO `cc_audience` VALUES (24, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (25, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (26, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (27, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (28, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (29, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (30, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (31, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (32, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (33, '112.12.206.161', NULL, NULL);
INSERT INTO `cc_audience` VALUES (34, '112.12.206.161', NULL, NULL);
INSERT INTO `cc_audience` VALUES (35, '112.12.206.161', NULL, NULL);
INSERT INTO `cc_audience` VALUES (36, '112.12.206.161', NULL, NULL);
INSERT INTO `cc_audience` VALUES (37, '112.12.206.161', NULL, NULL);
INSERT INTO `cc_audience` VALUES (38, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (39, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (40, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (41, '14.21.99.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (42, '220.196.237.243', NULL, NULL);
INSERT INTO `cc_audience` VALUES (43, '223.71.6.117', NULL, NULL);
INSERT INTO `cc_audience` VALUES (44, '27.115.124.53', NULL, NULL);
INSERT INTO `cc_audience` VALUES (45, '125.76.217.210', NULL, NULL);
INSERT INTO `cc_audience` VALUES (46, '125.76.217.210', NULL, NULL);
INSERT INTO `cc_audience` VALUES (47, '125.76.217.210', NULL, NULL);
INSERT INTO `cc_audience` VALUES (48, '220.168.87.110', NULL, NULL);
INSERT INTO `cc_audience` VALUES (49, '220.168.87.110', NULL, NULL);
INSERT INTO `cc_audience` VALUES (50, '220.168.87.110', NULL, NULL);
INSERT INTO `cc_audience` VALUES (51, '220.196.194.66', NULL, NULL);
INSERT INTO `cc_audience` VALUES (52, '183.30.176.181', NULL, NULL);
INSERT INTO `cc_audience` VALUES (53, '183.30.176.181', NULL, NULL);
INSERT INTO `cc_audience` VALUES (54, '183.30.176.181', NULL, NULL);
INSERT INTO `cc_audience` VALUES (55, '112.97.209.228', NULL, NULL);
INSERT INTO `cc_audience` VALUES (56, '182.200.73.50', NULL, NULL);
INSERT INTO `cc_audience` VALUES (57, '183.30.176.181', NULL, NULL);
INSERT INTO `cc_audience` VALUES (58, '183.237.77.231', NULL, NULL);
INSERT INTO `cc_audience` VALUES (59, '202.115.9.26', NULL, NULL);
INSERT INTO `cc_audience` VALUES (60, '202.115.9.26', NULL, NULL);
INSERT INTO `cc_audience` VALUES (61, '121.227.96.84', NULL, NULL);
INSERT INTO `cc_audience` VALUES (62, '121.227.96.84', NULL, NULL);
INSERT INTO `cc_audience` VALUES (63, '121.227.96.84', NULL, NULL);
INSERT INTO `cc_audience` VALUES (64, '39.144.187.98', NULL, NULL);
INSERT INTO `cc_audience` VALUES (65, '39.144.187.98', NULL, NULL);
INSERT INTO `cc_audience` VALUES (66, '39.144.187.98', NULL, NULL);
INSERT INTO `cc_audience` VALUES (67, '210.41.102.20', NULL, NULL);
INSERT INTO `cc_audience` VALUES (68, '210.41.102.20', NULL, NULL);
INSERT INTO `cc_audience` VALUES (69, '27.115.124.45', NULL, NULL);
INSERT INTO `cc_audience` VALUES (70, '223.104.195.198', NULL, NULL);
INSERT INTO `cc_audience` VALUES (71, '119.143.16.184', NULL, NULL);
INSERT INTO `cc_audience` VALUES (72, '119.143.16.184', NULL, NULL);
INSERT INTO `cc_audience` VALUES (73, '112.94.98.109', NULL, NULL);
INSERT INTO `cc_audience` VALUES (74, '112.96.196.111', NULL, NULL);
INSERT INTO `cc_audience` VALUES (75, '112.96.196.111', NULL, NULL);
INSERT INTO `cc_audience` VALUES (76, '112.96.196.111', NULL, NULL);
INSERT INTO `cc_audience` VALUES (77, '111.59.124.167', NULL, NULL);
INSERT INTO `cc_audience` VALUES (78, '112.96.196.111', NULL, NULL);
INSERT INTO `cc_audience` VALUES (79, '112.96.196.111', NULL, NULL);
INSERT INTO `cc_audience` VALUES (80, '111.59.124.167', NULL, NULL);
INSERT INTO `cc_audience` VALUES (81, '123.138.186.62', NULL, NULL);
INSERT INTO `cc_audience` VALUES (82, '123.138.186.62', NULL, NULL);
INSERT INTO `cc_audience` VALUES (83, '183.230.42.14', NULL, NULL);
INSERT INTO `cc_audience` VALUES (84, '183.230.42.14', NULL, NULL);
INSERT INTO `cc_audience` VALUES (85, '112.96.57.18', NULL, NULL);
INSERT INTO `cc_audience` VALUES (86, '112.96.57.18', NULL, NULL);
INSERT INTO `cc_audience` VALUES (87, '112.6.224.59', NULL, NULL);
INSERT INTO `cc_audience` VALUES (88, '112.6.224.59', NULL, NULL);
INSERT INTO `cc_audience` VALUES (89, '112.6.224.59', NULL, NULL);
INSERT INTO `cc_audience` VALUES (90, '218.26.159.7', NULL, NULL);
INSERT INTO `cc_audience` VALUES (91, '218.26.159.7', NULL, NULL);
INSERT INTO `cc_audience` VALUES (92, '59.54.58.199', NULL, NULL);
INSERT INTO `cc_audience` VALUES (93, '59.54.58.199', NULL, NULL);
INSERT INTO `cc_audience` VALUES (94, '59.54.58.199', NULL, NULL);
INSERT INTO `cc_audience` VALUES (95, '59.54.58.199', NULL, NULL);
INSERT INTO `cc_audience` VALUES (96, '59.54.58.199', NULL, NULL);
INSERT INTO `cc_audience` VALUES (97, '111.58.52.185', NULL, NULL);
INSERT INTO `cc_audience` VALUES (98, '111.58.52.185', NULL, NULL);
INSERT INTO `cc_audience` VALUES (99, '122.226.61.114', NULL, NULL);
INSERT INTO `cc_audience` VALUES (100, '122.226.61.114', NULL, NULL);
INSERT INTO `cc_audience` VALUES (101, '122.226.61.114', NULL, NULL);
INSERT INTO `cc_audience` VALUES (102, '122.226.61.114', NULL, NULL);
INSERT INTO `cc_audience` VALUES (103, '42.102.130.121', NULL, NULL);
INSERT INTO `cc_audience` VALUES (104, '46.232.120.163', NULL, NULL);
INSERT INTO `cc_audience` VALUES (105, '46.232.120.163', NULL, NULL);
INSERT INTO `cc_audience` VALUES (106, '46.232.120.163', NULL, NULL);
INSERT INTO `cc_audience` VALUES (107, '125.76.217.210', NULL, NULL);
INSERT INTO `cc_audience` VALUES (108, '119.39.32.25', NULL, NULL);
INSERT INTO `cc_audience` VALUES (109, '42.102.139.176', NULL, NULL);
INSERT INTO `cc_audience` VALUES (110, '122.226.61.114', NULL, NULL);
INSERT INTO `cc_audience` VALUES (111, '125.76.217.210', NULL, NULL);
INSERT INTO `cc_audience` VALUES (112, '125.76.217.210', NULL, NULL);
INSERT INTO `cc_audience` VALUES (113, '117.141.253.242', NULL, NULL);
INSERT INTO `cc_audience` VALUES (114, '219.231.161.232', NULL, NULL);
INSERT INTO `cc_audience` VALUES (115, '119.78.133.91', NULL, NULL);
INSERT INTO `cc_audience` VALUES (116, '119.78.133.91', NULL, NULL);
INSERT INTO `cc_audience` VALUES (117, '119.78.133.91', NULL, NULL);
INSERT INTO `cc_audience` VALUES (118, '119.78.133.91', NULL, NULL);
INSERT INTO `cc_audience` VALUES (119, '119.78.133.91', NULL, NULL);
INSERT INTO `cc_audience` VALUES (120, '125.76.217.210', NULL, NULL);
INSERT INTO `cc_audience` VALUES (121, '125.76.217.210', NULL, NULL);
INSERT INTO `cc_audience` VALUES (122, '125.76.217.210', NULL, NULL);
INSERT INTO `cc_audience` VALUES (123, '125.76.217.210', NULL, NULL);
INSERT INTO `cc_audience` VALUES (124, '125.76.217.210', NULL, NULL);
INSERT INTO `cc_audience` VALUES (125, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (126, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (127, '112.43.64.76', NULL, NULL);
INSERT INTO `cc_audience` VALUES (128, '112.43.64.76', NULL, NULL);
INSERT INTO `cc_audience` VALUES (129, '222.84.67.159', NULL, NULL);
INSERT INTO `cc_audience` VALUES (130, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (131, '112.96.65.250', NULL, NULL);
INSERT INTO `cc_audience` VALUES (132, '112.96.65.250', NULL, NULL);
INSERT INTO `cc_audience` VALUES (133, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (134, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (135, '211.90.248.235', NULL, NULL);
INSERT INTO `cc_audience` VALUES (136, '211.90.248.235', NULL, NULL);
INSERT INTO `cc_audience` VALUES (137, '180.162.6.62', NULL, NULL);
INSERT INTO `cc_audience` VALUES (138, '180.162.6.62', NULL, NULL);
INSERT INTO `cc_audience` VALUES (139, '180.162.6.62', NULL, NULL);
INSERT INTO `cc_audience` VALUES (140, '180.162.6.62', NULL, NULL);
INSERT INTO `cc_audience` VALUES (141, '180.162.6.62', NULL, NULL);
INSERT INTO `cc_audience` VALUES (142, '180.162.6.62', NULL, NULL);
INSERT INTO `cc_audience` VALUES (143, '221.198.235.244', NULL, NULL);
INSERT INTO `cc_audience` VALUES (144, '221.198.235.244', NULL, NULL);
INSERT INTO `cc_audience` VALUES (145, '106.33.186.203', NULL, NULL);
INSERT INTO `cc_audience` VALUES (146, '106.33.186.203', NULL, NULL);
INSERT INTO `cc_audience` VALUES (147, '113.88.109.30', NULL, NULL);
INSERT INTO `cc_audience` VALUES (148, '113.88.109.30', NULL, NULL);
INSERT INTO `cc_audience` VALUES (149, '42.227.199.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (150, '42.227.199.204', NULL, NULL);
INSERT INTO `cc_audience` VALUES (151, '223.147.223.109', NULL, NULL);
INSERT INTO `cc_audience` VALUES (152, '223.147.223.109', NULL, NULL);
INSERT INTO `cc_audience` VALUES (153, '111.58.38.9', NULL, NULL);
INSERT INTO `cc_audience` VALUES (154, '218.68.102.139', NULL, NULL);
INSERT INTO `cc_audience` VALUES (155, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (156, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (157, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (158, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (159, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (160, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (161, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (162, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (163, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (164, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (165, '40.77.188.249', NULL, NULL);
INSERT INTO `cc_audience` VALUES (166, '112.96.65.250', NULL, NULL);
INSERT INTO `cc_audience` VALUES (167, '112.96.65.250', NULL, NULL);
INSERT INTO `cc_audience` VALUES (168, '112.96.65.250', NULL, NULL);
INSERT INTO `cc_audience` VALUES (169, '112.96.65.250', NULL, NULL);
INSERT INTO `cc_audience` VALUES (170, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (171, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (172, '117.41.167.243', NULL, NULL);
INSERT INTO `cc_audience` VALUES (173, '211.90.248.62', NULL, NULL);
INSERT INTO `cc_audience` VALUES (174, '211.90.248.62', NULL, NULL);
INSERT INTO `cc_audience` VALUES (175, '211.90.248.62', NULL, NULL);
INSERT INTO `cc_audience` VALUES (176, '101.66.185.39', NULL, NULL);
INSERT INTO `cc_audience` VALUES (177, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (178, '40.77.189.246', NULL, NULL);
INSERT INTO `cc_audience` VALUES (179, '14.21.98.21', NULL, NULL);
INSERT INTO `cc_audience` VALUES (180, '183.30.178.15', NULL, NULL);
INSERT INTO `cc_audience` VALUES (181, '183.30.178.15', NULL, NULL);
INSERT INTO `cc_audience` VALUES (182, '183.30.178.15', NULL, NULL);
INSERT INTO `cc_audience` VALUES (183, '183.30.178.15', NULL, NULL);
INSERT INTO `cc_audience` VALUES (184, '59.37.125.75', NULL, NULL);
INSERT INTO `cc_audience` VALUES (185, '59.37.125.75', NULL, NULL);
INSERT INTO `cc_audience` VALUES (186, '223.104.67.98', NULL, NULL);
INSERT INTO `cc_audience` VALUES (187, '223.104.67.98', NULL, NULL);
INSERT INTO `cc_audience` VALUES (188, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (189, '183.30.178.15', NULL, NULL);
INSERT INTO `cc_audience` VALUES (190, '120.235.177.139', NULL, NULL);
INSERT INTO `cc_audience` VALUES (191, '183.249.13.235', NULL, NULL);
INSERT INTO `cc_audience` VALUES (192, '222.215.246.111', NULL, NULL);
INSERT INTO `cc_audience` VALUES (193, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (194, '183.30.178.15', NULL, NULL);
INSERT INTO `cc_audience` VALUES (195, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (196, '40.77.188.226', NULL, NULL);
INSERT INTO `cc_audience` VALUES (197, '120.230.101.239', NULL, NULL);
INSERT INTO `cc_audience` VALUES (198, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (199, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (200, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (201, '112.97.245.76', NULL, NULL);
INSERT INTO `cc_audience` VALUES (202, '112.97.245.76', NULL, NULL);
INSERT INTO `cc_audience` VALUES (203, '112.97.245.76', NULL, NULL);
INSERT INTO `cc_audience` VALUES (204, '112.97.245.76', NULL, NULL);
INSERT INTO `cc_audience` VALUES (205, '112.97.245.76', NULL, NULL);
INSERT INTO `cc_audience` VALUES (206, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (207, '27.115.124.6', NULL, NULL);
INSERT INTO `cc_audience` VALUES (208, '27.191.196.4', NULL, NULL);
INSERT INTO `cc_audience` VALUES (209, '27.191.196.4', NULL, NULL);
INSERT INTO `cc_audience` VALUES (210, '36.159.194.252', NULL, NULL);
INSERT INTO `cc_audience` VALUES (211, '36.159.194.252', NULL, NULL);
INSERT INTO `cc_audience` VALUES (212, '36.159.194.252', NULL, NULL);
INSERT INTO `cc_audience` VALUES (213, '112.97.245.76', NULL, NULL);
INSERT INTO `cc_audience` VALUES (214, '112.96.85.104', NULL, NULL);
INSERT INTO `cc_audience` VALUES (215, '112.17.237.171', NULL, NULL);
INSERT INTO `cc_audience` VALUES (216, '111.26.2.203', NULL, NULL);
INSERT INTO `cc_audience` VALUES (217, '111.26.2.203', NULL, NULL);
INSERT INTO `cc_audience` VALUES (218, '116.9.113.127', NULL, NULL);
INSERT INTO `cc_audience` VALUES (219, '116.9.113.127', NULL, NULL);
INSERT INTO `cc_audience` VALUES (220, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (221, '129.204.116.160', NULL, NULL);
INSERT INTO `cc_audience` VALUES (222, '129.204.116.160', NULL, NULL);
INSERT INTO `cc_audience` VALUES (223, '220.200.127.203', NULL, NULL);
INSERT INTO `cc_audience` VALUES (224, '219.136.115.225', NULL, NULL);
INSERT INTO `cc_audience` VALUES (225, '219.136.115.225', NULL, NULL);
INSERT INTO `cc_audience` VALUES (226, '223.167.122.52', NULL, NULL);
INSERT INTO `cc_audience` VALUES (227, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (228, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (229, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (230, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (231, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (232, '123.139.34.9', NULL, NULL);
INSERT INTO `cc_audience` VALUES (233, '223.74.181.42', NULL, NULL);
INSERT INTO `cc_audience` VALUES (234, '223.74.181.42', NULL, NULL);
INSERT INTO `cc_audience` VALUES (235, '223.74.181.42', NULL, NULL);
INSERT INTO `cc_audience` VALUES (236, '223.74.181.42', NULL, NULL);
INSERT INTO `cc_audience` VALUES (237, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (238, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (239, '171.15.167.222', NULL, NULL);
INSERT INTO `cc_audience` VALUES (240, '171.15.167.222', NULL, NULL);
INSERT INTO `cc_audience` VALUES (241, '171.15.167.222', NULL, NULL);
INSERT INTO `cc_audience` VALUES (242, '120.235.204.228', NULL, NULL);
INSERT INTO `cc_audience` VALUES (243, '60.190.251.242', NULL, NULL);
INSERT INTO `cc_audience` VALUES (244, '112.96.166.17', NULL, NULL);
INSERT INTO `cc_audience` VALUES (245, '116.232.107.153', NULL, NULL);
INSERT INTO `cc_audience` VALUES (246, '121.10.41.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (247, '222.76.243.169', NULL, NULL);
INSERT INTO `cc_audience` VALUES (248, '222.76.243.169', NULL, NULL);
INSERT INTO `cc_audience` VALUES (249, '121.10.41.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (250, '175.190.123.132', NULL, NULL);
INSERT INTO `cc_audience` VALUES (251, '175.190.123.132', NULL, NULL);
INSERT INTO `cc_audience` VALUES (252, '110.53.5.226', NULL, NULL);
INSERT INTO `cc_audience` VALUES (253, '125.76.217.210', NULL, NULL);
INSERT INTO `cc_audience` VALUES (254, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (255, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (256, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (257, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (258, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (259, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (260, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (261, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (262, '36.98.104.251', NULL, NULL);
INSERT INTO `cc_audience` VALUES (263, '36.98.104.251', NULL, NULL);
INSERT INTO `cc_audience` VALUES (264, '36.98.104.251', NULL, NULL);
INSERT INTO `cc_audience` VALUES (265, '36.98.104.251', NULL, NULL);
INSERT INTO `cc_audience` VALUES (266, '36.98.104.251', NULL, NULL);
INSERT INTO `cc_audience` VALUES (267, '36.98.104.251', NULL, NULL);
INSERT INTO `cc_audience` VALUES (268, '36.98.104.251', NULL, NULL);
INSERT INTO `cc_audience` VALUES (269, '120.230.126.78', NULL, NULL);
INSERT INTO `cc_audience` VALUES (270, '120.230.126.78', NULL, NULL);
INSERT INTO `cc_audience` VALUES (271, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (272, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (273, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (274, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (275, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (276, '14.21.97.238', NULL, NULL);
INSERT INTO `cc_audience` VALUES (277, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (278, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (279, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (280, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (281, '120.242.62.213', NULL, NULL);
INSERT INTO `cc_audience` VALUES (282, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (283, '14.21.99.191', NULL, NULL);
INSERT INTO `cc_audience` VALUES (284, '115.215.118.96', NULL, NULL);
INSERT INTO `cc_audience` VALUES (285, '14.21.98.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (286, '14.21.98.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (287, '14.21.98.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (288, '14.21.98.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (289, '112.97.245.76', NULL, NULL);
INSERT INTO `cc_audience` VALUES (290, '112.97.245.76', NULL, NULL);
INSERT INTO `cc_audience` VALUES (291, '112.97.210.29', NULL, NULL);
INSERT INTO `cc_audience` VALUES (292, '14.21.98.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (293, '14.21.98.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (294, '14.21.98.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (295, '14.21.98.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (296, '125.76.217.210', NULL, NULL);
INSERT INTO `cc_audience` VALUES (297, '125.76.217.210', NULL, NULL);
INSERT INTO `cc_audience` VALUES (298, '125.76.217.210', NULL, NULL);
INSERT INTO `cc_audience` VALUES (299, '120.198.76.105', NULL, NULL);
INSERT INTO `cc_audience` VALUES (300, '120.198.76.105', NULL, NULL);
INSERT INTO `cc_audience` VALUES (301, '112.81.199.170', NULL, NULL);
INSERT INTO `cc_audience` VALUES (302, '112.81.199.170', NULL, NULL);
INSERT INTO `cc_audience` VALUES (303, '112.81.199.170', NULL, NULL);
INSERT INTO `cc_audience` VALUES (304, '223.64.97.183', NULL, NULL);
INSERT INTO `cc_audience` VALUES (305, '223.64.97.183', NULL, NULL);
INSERT INTO `cc_audience` VALUES (306, '223.64.97.183', NULL, NULL);
INSERT INTO `cc_audience` VALUES (307, '153.35.127.190', NULL, NULL);
INSERT INTO `cc_audience` VALUES (308, '153.35.127.190', NULL, NULL);
INSERT INTO `cc_audience` VALUES (309, '119.163.222.91', NULL, NULL);
INSERT INTO `cc_audience` VALUES (310, '111.192.245.119', NULL, NULL);
INSERT INTO `cc_audience` VALUES (311, '119.163.222.91', NULL, NULL);
INSERT INTO `cc_audience` VALUES (312, '111.192.245.119', NULL, NULL);
INSERT INTO `cc_audience` VALUES (313, '180.164.52.154', NULL, NULL);
INSERT INTO `cc_audience` VALUES (314, '180.164.52.154', NULL, NULL);
INSERT INTO `cc_audience` VALUES (315, '180.164.52.154', NULL, NULL);
INSERT INTO `cc_audience` VALUES (316, '180.164.52.154', NULL, NULL);
INSERT INTO `cc_audience` VALUES (317, '180.164.52.154', NULL, NULL);
INSERT INTO `cc_audience` VALUES (318, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (319, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (320, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (321, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (322, '116.29.111.179', NULL, NULL);
INSERT INTO `cc_audience` VALUES (323, '116.29.111.179', NULL, NULL);
INSERT INTO `cc_audience` VALUES (324, '116.29.111.179', NULL, NULL);
INSERT INTO `cc_audience` VALUES (325, '116.29.111.179', NULL, NULL);
INSERT INTO `cc_audience` VALUES (326, '116.29.111.179', NULL, NULL);
INSERT INTO `cc_audience` VALUES (327, '116.29.111.179', NULL, NULL);
INSERT INTO `cc_audience` VALUES (328, '116.29.111.179', NULL, NULL);
INSERT INTO `cc_audience` VALUES (329, '116.29.111.179', NULL, NULL);
INSERT INTO `cc_audience` VALUES (330, '112.97.245.166', NULL, NULL);
INSERT INTO `cc_audience` VALUES (331, '112.97.245.166', NULL, NULL);
INSERT INTO `cc_audience` VALUES (332, '112.97.245.166', NULL, NULL);
INSERT INTO `cc_audience` VALUES (333, '218.13.74.34', NULL, NULL);
INSERT INTO `cc_audience` VALUES (334, '116.29.111.179', NULL, NULL);
INSERT INTO `cc_audience` VALUES (335, '116.29.111.179', NULL, NULL);
INSERT INTO `cc_audience` VALUES (336, '117.34.101.87', NULL, NULL);
INSERT INTO `cc_audience` VALUES (337, '14.21.98.170', NULL, NULL);
INSERT INTO `cc_audience` VALUES (338, '116.29.111.179', NULL, NULL);
INSERT INTO `cc_audience` VALUES (339, '116.29.111.179', NULL, NULL);
INSERT INTO `cc_audience` VALUES (340, '116.29.111.179', NULL, NULL);
INSERT INTO `cc_audience` VALUES (341, '14.21.98.170', NULL, NULL);
INSERT INTO `cc_audience` VALUES (342, '14.21.98.170', NULL, NULL);
INSERT INTO `cc_audience` VALUES (343, '14.21.98.170', NULL, NULL);
INSERT INTO `cc_audience` VALUES (344, '116.29.111.179', NULL, NULL);
INSERT INTO `cc_audience` VALUES (345, '112.97.245.166', NULL, NULL);

-- ----------------------------
-- Table structure for cc_browse_log
-- ----------------------------
DROP TABLE IF EXISTS `cc_browse_log`;
CREATE TABLE `cc_browse_log`  (
  `id` bigint(255) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `ip` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '用户ip',
  `addr` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '用户ip归属地',
  `local_time` datetime(0) NULL DEFAULT NULL COMMENT '发生时间',
  `os` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '操作系统',
  `browser` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '浏览器',
  `log_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '日志名称',
  `method_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '方法名',
  `class_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '类名',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '请求地址',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of cc_browse_log
-- ----------------------------

-- ----------------------------
-- Table structure for cc_category
-- ----------------------------
DROP TABLE IF EXISTS `cc_category`;
CREATE TABLE `cc_category`  (
  `id` bigint(200) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '分类名',
  `pid` bigint(200) NULL DEFAULT -1 COMMENT '父分类id，如果没有父分类为-1',
  `description` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '描述',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '状态0:正常,1禁用',
  `create_by` bigint(200) NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_by` bigint(200) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `del_flag` int(11) NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '分类表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of cc_category
-- ----------------------------
INSERT INTO `cc_category` VALUES (1, 'java', -1, 'wsd', '0', NULL, NULL, NULL, NULL, 0);
INSERT INTO `cc_category` VALUES (2, 'HTML', -1, '前端三剑客', '0', NULL, NULL, NULL, NULL, 0);
INSERT INTO `cc_category` VALUES (3, 'mysql', -1, '数据库', '0', NULL, NULL, NULL, NULL, 0);
INSERT INTO `cc_category` VALUES (4, 'vue', -1, '前端知识', '0', NULL, NULL, NULL, NULL, 0);
INSERT INTO `cc_category` VALUES (5, 'SpringCloud', -1, 'SpringCloud分布式框架', '0', NULL, NULL, NULL, NULL, 1);

-- ----------------------------
-- Table structure for cc_comment
-- ----------------------------
DROP TABLE IF EXISTS `cc_comment`;
CREATE TABLE `cc_comment`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '评论类型（0代表文章评论，1代表友链评论）',
  `article_id` bigint(20) NULL DEFAULT NULL COMMENT '文章id',
  `root_id` bigint(20) NULL DEFAULT -1 COMMENT '根评论id',
  `content` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '评论内容',
  `to_comment_user_id` bigint(20) NULL DEFAULT -1 COMMENT '所回复的目标评论的userid',
  `to_comment_id` bigint(20) NULL DEFAULT -1 COMMENT '回复目标评论id',
  `create_by` bigint(20) NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_by` bigint(20) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `del_flag` int(1) NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 67 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '评论表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of cc_comment
-- ----------------------------
INSERT INTO `cc_comment` VALUES (1, '0', 1, -1, 'asS', -1, -1, 1, '2022-01-29 07:59:22', 1, '2022-01-29 07:59:22', 0);
INSERT INTO `cc_comment` VALUES (2, '0', 1, -1, '[哈哈]SDAS', -1, -1, 1, '2022-01-29 08:01:24', 1, '2022-01-29 08:01:24', 0);
INSERT INTO `cc_comment` VALUES (3, '0', 1, -1, '是大多数', -1, -1, 1, '2022-01-29 16:07:24', 1, '2022-01-29 16:07:24', 0);
INSERT INTO `cc_comment` VALUES (4, '0', 1, -1, '撒大声地', -1, -1, 1, '2022-01-29 16:12:09', 1, '2022-01-29 16:12:09', 0);
INSERT INTO `cc_comment` VALUES (9, '0', 1, 2, '你说什么', 1, 2, 1, '2022-01-29 22:18:40', 1, '2022-01-29 22:18:40', 0);
INSERT INTO `cc_comment` VALUES (10, '0', 1, 2, '哈哈哈哈[哈哈]', 1, 9, 1, '2022-01-29 22:29:15', 1, '2022-01-29 22:29:15', 0);
INSERT INTO `cc_comment` VALUES (11, '0', 1, 2, 'we全文', 1, 10, 3, '2022-01-29 22:29:55', 1, '2022-01-29 22:29:55', 0);
INSERT INTO `cc_comment` VALUES (16, '0', 1, 2, '3333', 1, 11, 1, '2022-01-29 22:34:47', 1, '2022-01-29 22:34:47', 0);
INSERT INTO `cc_comment` VALUES (17, '0', 1, 2, '回复weqedadsd', 3, 11, 1, '2022-01-29 22:38:00', 1, '2022-01-29 22:38:00', 0);
INSERT INTO `cc_comment` VALUES (18, '0', 1, -1, 'sdasd', -1, -1, 1, '2022-01-29 23:18:19', 1, '2022-01-29 23:18:19', 0);
INSERT INTO `cc_comment` VALUES (19, '0', 1, -1, '111', -1, -1, 1, '2022-01-29 23:22:23', 1, '2022-01-29 23:22:23', 0);
INSERT INTO `cc_comment` VALUES (20, '0', 1, 1, '你说啥？', 1, 1, 1, '2022-01-30 10:06:21', 1, '2022-01-30 10:06:21', 0);
INSERT INTO `cc_comment` VALUES (21, '0', 1, -1, '友链添加个呗', -1, -1, 1, '2022-01-30 10:06:50', 1, '2022-01-30 10:06:50', 0);
INSERT INTO `cc_comment` VALUES (22, '1', 1, -1, '友链评论2', -1, -1, 1, '2022-01-30 10:08:28', 1, '2022-01-30 10:08:28', 0);
INSERT INTO `cc_comment` VALUES (23, '1', 1, 22, '回复友链评论3', 1, 22, 1, '2022-01-30 10:08:50', 1, '2022-01-30 10:08:50', 0);
INSERT INTO `cc_comment` VALUES (24, '1', 1, -1, '友链评论4444', -1, -1, 1, '2022-01-30 10:09:03', 1, '2022-01-30 10:09:03', 0);
INSERT INTO `cc_comment` VALUES (25, '1', 1, 22, '收到的', 1, 22, 1, '2022-01-30 10:13:28', 1, '2022-01-30 10:13:28', 0);
INSERT INTO `cc_comment` VALUES (26, '0', 1, -1, 'sda', -1, -1, 1, '2022-01-30 10:39:05', 1, '2022-01-30 10:39:05', 0);
INSERT INTO `cc_comment` VALUES (27, '0', 1, 1, '说你咋地', 1, 20, 14787164048662, '2022-01-30 17:19:30', 14787164048662, '2022-01-30 17:19:30', 0);
INSERT INTO `cc_comment` VALUES (28, '0', 1, 1, 'sdad', 1, 1, 14787164048662, '2022-01-31 11:11:20', 14787164048662, '2022-01-31 11:11:20', 0);
INSERT INTO `cc_comment` VALUES (29, '0', 1, -1, '你说是的ad', -1, -1, 14787164048662, '2022-01-31 14:10:11', 14787164048662, '2022-01-31 14:10:11', 0);
INSERT INTO `cc_comment` VALUES (30, '0', 1, 1, '撒大声地', 1, 1, 14787164048662, '2022-01-31 20:19:18', 14787164048662, '2022-01-31 20:19:18', 0);
INSERT INTO `cc_comment` VALUES (31, '0', 1, -1, 'cc', -1, -1, 1, '2023-05-05 15:15:17', 1, '2023-05-05 15:15:17', 0);
INSERT INTO `cc_comment` VALUES (32, '0', 1, -1, '泰酷辣', -1, -1, 1, '2023-05-05 15:16:06', 1, '2023-05-05 15:16:06', 0);
INSERT INTO `cc_comment` VALUES (38, '0', 1, -1, '求求了，给我过吧', -1, -1, 1, '2023-05-05 19:11:59', 1, '2023-05-05 19:11:59', 0);
INSERT INTO `cc_comment` VALUES (41, '0', 1, -1, 'cc', -1, -1, 1, '2023-05-05 19:26:53', 1, '2023-05-05 19:26:53', 0);
INSERT INTO `cc_comment` VALUES (42, '0', 1, -1, 'context我草泥马\n', -1, -1, 1, '2023-05-05 19:29:34', 1, '2023-05-05 19:29:34', 0);
INSERT INTO `cc_comment` VALUES (43, '0', 1, 42, '太对了', 1, 42, 1, '2023-05-05 19:31:10', 1, '2023-05-05 19:31:10', 0);
INSERT INTO `cc_comment` VALUES (44, '1', 1, -1, 'dadada', -1, -1, 1, '2023-05-05 19:41:31', 1, '2023-05-05 19:41:31', 0);
INSERT INTO `cc_comment` VALUES (47, '0', 1, -1, '傻逼项目', -1, -1, 1, '2023-05-06 17:02:10', 1, '2023-05-06 17:02:10', 0);
INSERT INTO `cc_comment` VALUES (48, '0', 1, 47, '说的太对辣\n[微笑]', 1, 47, 1, '2023-05-06 17:03:41', 1, '2023-05-06 17:03:41', 0);
INSERT INTO `cc_comment` VALUES (49, '0', 1, 47, '我都无语了[生病]', 1, 48, 1, '2023-05-06 17:03:52', 1, '2023-05-06 17:03:52', 0);
INSERT INTO `cc_comment` VALUES (53, '0', 1, -1, 'cc', -1, -1, 1, '2023-05-06 17:25:52', 1, '2023-05-06 17:25:52', 0);
INSERT INTO `cc_comment` VALUES (54, '1', 1, -1, 'cc', -1, -1, 1, '2023-05-06 17:26:01', 1, '2023-05-06 17:26:01', 0);
INSERT INTO `cc_comment` VALUES (55, '1', 1, 54, 'cc', 1, 54, 1, '2023-05-06 17:26:04', 1, '2023-05-06 17:26:04', 0);
INSERT INTO `cc_comment` VALUES (56, '0', 1, -1, '111', -1, -1, 1, '2023-05-06 17:44:03', 1, '2023-05-06 17:44:03', 0);
INSERT INTO `cc_comment` VALUES (57, '1', 1, -1, '11', -1, -1, 1, '2023-05-06 17:44:20', 1, '2023-05-06 17:44:20', 0);
INSERT INTO `cc_comment` VALUES (58, '0', 9, -1, 'awesome', -1, -1, 1, '2023-05-14 20:16:36', 1, '2023-05-14 20:16:36', 0);
INSERT INTO `cc_comment` VALUES (59, '0', 1, -1, '嘻嘻', -1, -1, 1, '2023-05-15 00:07:10', 1, '2023-05-15 00:07:10', 0);
INSERT INTO `cc_comment` VALUES (60, '0', 9, -1, '666[棒棒]', -1, -1, 1, '2023-05-15 08:44:44', 1, '2023-05-15 08:44:44', 0);
INSERT INTO `cc_comment` VALUES (61, '0', 1, -1, '[可爱]', -1, -1, 1, '2023-05-15 09:14:21', 1, '2023-05-15 09:14:21', 0);
INSERT INTO `cc_comment` VALUES (62, '0', 11, -1, '哈哈', -1, -1, 14787164048668, '2023-05-27 14:03:30', 14787164048668, '2023-05-27 14:03:30', 0);
INSERT INTO `cc_comment` VALUES (63, '0', 23, -1, '欢迎大家来参观[嘻嘻][嘻嘻][嘻嘻]', -1, -1, 14787164048663, '2023-06-03 00:40:43', 14787164048663, '2023-06-03 00:40:43', 0);
INSERT INTO `cc_comment` VALUES (64, '1', 1, -1, '666666666666', -1, -1, 14787164048669, '2023-06-18 23:02:29', 14787164048669, '2023-06-18 23:02:29', 0);
INSERT INTO `cc_comment` VALUES (65, '0', 36, -1, '测试头像修改', -1, -1, 14787164048670, '2023-07-02 14:13:32', 14787164048670, '2023-07-02 14:13:32', 0);
INSERT INTO `cc_comment` VALUES (66, '0', 36, -1, '[可怜]', -1, -1, 14787164048670, '2023-07-02 14:14:37', 14787164048670, '2023-07-02 14:14:37', 0);

-- ----------------------------
-- Table structure for cc_link
-- ----------------------------
DROP TABLE IF EXISTS `cc_link`;
CREATE TABLE `cc_link`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `logo` varchar(256) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `description` varchar(512) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `address` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '网站地址',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '2' COMMENT '审核状态 (0代表审核通过，1代表审核未通过，2代表未审核)',
  `create_by` bigint(20) NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_by` bigint(20) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `del_flag` int(1) NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '友链' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of cc_link
-- ----------------------------
INSERT INTO `cc_link` VALUES (1, 'sda', 'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fn1.itc.cn%2Fimg8%2Fwb%2Frecom%2F2016%2F05%2F10%2F146286696706220328.PNG&refer=http%3A%2F%2Fn1.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1646205529&t=f942665181eb9b0685db7a6f59d59975', 'sda', 'https://www.baidu.com', '0', NULL, '2022-01-13 08:25:47', NULL, '2022-01-13 08:36:14', 0);
INSERT INTO `cc_link` VALUES (2, 'sda', 'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fn1.itc.cn%2Fimg8%2Fwb%2Frecom%2F2016%2F05%2F10%2F146286696706220328.PNG&refer=http%3A%2F%2Fn1.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1646205529&t=f942665181eb9b0685db7a6f59d59975', 'dada', 'https://www.qq.com', '0', NULL, '2022-01-13 09:06:10', NULL, '2022-01-13 09:07:09', 0);
INSERT INTO `cc_link` VALUES (3, 'sa', 'https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fn1.itc.cn%2Fimg8%2Fwb%2Frecom%2F2016%2F05%2F10%2F146286696706220328.PNG&refer=http%3A%2F%2Fn1.itc.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1646205529&t=f942665181eb9b0685db7a6f59d59975', 'da', 'https://www.taobao.com', '0', NULL, '2022-01-13 09:23:01', NULL, '2022-01-13 09:23:01', 0);
INSERT INTO `cc_link` VALUES (4, 'ccc', 'cc', 'ccc', 'cc', '2', NULL, NULL, NULL, NULL, 1);
INSERT INTO `cc_link` VALUES (5, 'cc', 'cc', 'cc', 'cc', '0', NULL, NULL, NULL, NULL, 0);

-- ----------------------------
-- Table structure for cc_menu
-- ----------------------------
DROP TABLE IF EXISTS `cc_menu`;
CREATE TABLE `cc_menu`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '菜单ID',
  `menu_name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '菜单名称',
  `parent_id` bigint(20) NULL DEFAULT 0 COMMENT '父菜单ID',
  `order_num` int(4) NULL DEFAULT 0 COMMENT '显示顺序',
  `path` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '路由地址',
  `component` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '组件路径',
  `is_frame` int(1) NULL DEFAULT 1 COMMENT '是否为外链（0是 1否）',
  `menu_type` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '菜单类型（M目录 C菜单 F按钮）',
  `visible` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0' COMMENT '菜单状态（0显示 1隐藏）',
  `status` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0' COMMENT '菜单状态（0正常 1停用）',
  `perms` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '权限标识',
  `icon` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '#' COMMENT '菜单图标',
  `create_by` bigint(20) NULL DEFAULT NULL COMMENT '创建者',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint(20) NULL DEFAULT NULL COMMENT '更新者',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '备注',
  `del_flag` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2032 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '菜单权限表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of cc_menu
-- ----------------------------
INSERT INTO `cc_menu` VALUES (1, '系统管理', 0, 1, 'system', NULL, 1, 'M', '0', '0', '', 'system', 0, '2021-11-12 10:46:19', 0, NULL, '系统管理目录', '0');
INSERT INTO `cc_menu` VALUES (100, '用户管理', 1, 1, 'user', 'system/user/index', 1, 'C', '0', '0', 'system:user:list', 'user', 0, '2021-11-12 10:46:19', 1, '2022-07-31 15:47:58', '用户管理菜单', '0');
INSERT INTO `cc_menu` VALUES (101, '角色管理', 1, 2, 'role', 'system/role/index', 1, 'C', '0', '0', 'system:role:list', 'peoples', 0, '2021-11-12 10:46:19', 0, NULL, '角色管理菜单', '0');
INSERT INTO `cc_menu` VALUES (102, '菜单管理', 1, 3, 'menu', 'system/menu/index', 1, 'C', '0', '0', 'system:menu:list', 'tree-table', 0, '2021-11-12 10:46:19', 0, NULL, '菜单管理菜单', '0');
INSERT INTO `cc_menu` VALUES (1001, '用户查询', 100, 1, '', '', 1, 'F', '0', '0', 'system:user:query', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (1002, '用户新增', 100, 2, '', '', 1, 'F', '0', '0', 'system:user:add', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (1003, '用户修改', 100, 3, '', '', 1, 'F', '0', '0', 'system:user:edit', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (1004, '用户删除', 100, 4, '', '', 1, 'F', '0', '0', 'system:user:remove', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (1005, '用户导出', 100, 5, '', '', 1, 'F', '0', '0', 'system:user:export', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (1006, '用户导入', 100, 6, '', '', 1, 'F', '0', '0', 'system:user:import', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (1007, '重置密码', 100, 7, '', '', 1, 'F', '0', '0', 'system:user:resetPwd', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (1008, '角色查询', 101, 1, '', '', 1, 'F', '0', '0', 'system:role:query', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (1009, '角色新增', 101, 2, '', '', 1, 'F', '0', '0', 'system:role:add', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (1010, '角色修改', 101, 3, '', '', 1, 'F', '0', '0', 'system:role:edit', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (1011, '角色删除', 101, 4, '', '', 1, 'F', '0', '0', 'system:role:remove', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (1012, '角色导出', 101, 5, '', '', 1, 'F', '0', '0', 'system:role:export', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (1013, '菜单查询', 102, 1, '', '', 1, 'F', '0', '0', 'system:menu:query', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (1014, '菜单新增', 102, 2, '', '', 1, 'F', '0', '0', 'system:menu:add', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (1015, '菜单修改', 102, 3, '', '', 1, 'F', '0', '0', 'system:menu:edit', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (1016, '菜单删除', 102, 4, '', '', 1, 'F', '0', '0', 'system:menu:remove', '#', 0, '2021-11-12 10:46:19', 0, NULL, '', '0');
INSERT INTO `cc_menu` VALUES (2017, '内容管理', 0, 4, 'content', NULL, 1, 'M', '0', '0', NULL, 'table', NULL, '2022-01-08 02:44:38', 1, '2022-07-31 12:34:23', '', '0');
INSERT INTO `cc_menu` VALUES (2018, '分类管理', 2017, 1, 'category', 'content/category/index', 1, 'C', '0', '0', 'content:category:list', 'example', NULL, '2022-01-08 02:51:45', NULL, '2022-01-08 02:51:45', '', '0');
INSERT INTO `cc_menu` VALUES (2019, '文章管理', 2017, 0, 'article', 'content/article/index', 1, 'C', '0', '0', 'content:article:list', 'build', NULL, '2022-01-08 02:53:10', NULL, '2022-01-08 02:53:10', '', '0');
INSERT INTO `cc_menu` VALUES (2021, '标签管理', 2017, 6, 'tag', 'content/tag/index', 1, 'C', '0', '0', 'content:tag:index', 'button', NULL, '2022-01-08 02:55:37', NULL, '2022-01-08 02:55:50', '', '0');
INSERT INTO `cc_menu` VALUES (2022, '友链管理', 2017, 4, 'link', 'content/link/index', 1, 'C', '0', '0', 'content:link:list', '404', NULL, '2022-01-08 02:56:50', NULL, '2022-01-08 02:56:50', '', '0');
INSERT INTO `cc_menu` VALUES (2023, '写博文', 0, 0, 'write', 'content/article/write/index', 1, 'C', '0', '0', 'content:article:writer', 'build', NULL, '2022-01-08 03:39:58', 1, '2022-07-31 22:07:05', '', '0');
INSERT INTO `cc_menu` VALUES (2024, '友链新增', 2022, 0, '', NULL, 1, 'F', '0', '0', 'content:link:add', '#', NULL, '2022-01-16 07:59:17', NULL, '2022-01-16 07:59:17', '', '0');
INSERT INTO `cc_menu` VALUES (2025, '友链修改', 2022, 1, '', NULL, 1, 'F', '0', '0', 'content:link:edit', '#', NULL, '2022-01-16 07:59:44', NULL, '2022-01-16 07:59:44', '', '0');
INSERT INTO `cc_menu` VALUES (2026, '友链删除', 2022, 1, '', NULL, 1, 'F', '0', '0', 'content:link:remove', '#', NULL, '2022-01-16 08:00:05', NULL, '2022-01-16 08:00:05', '', '0');
INSERT INTO `cc_menu` VALUES (2027, '友链查询', 2022, 2, '', NULL, 1, 'F', '0', '0', 'content:link:query', '#', NULL, '2022-01-16 08:04:09', NULL, '2022-01-16 08:04:09', '', '0');
INSERT INTO `cc_menu` VALUES (2028, '导出分类', 2018, 1, '', NULL, 1, 'F', '0', '0', 'content:category:export', '#', NULL, '2022-01-21 07:06:59', NULL, '2022-01-21 07:06:59', '', '0');
INSERT INTO `cc_menu` VALUES (2029, 'cc', 0, 4, 'cc', NULL, 1, 'M', '0', '0', NULL, 'eye', 1, '2023-05-10 10:43:27', 1, '2023-05-10 10:43:27', '', '1');
INSERT INTO `cc_menu` VALUES (2030, 'ccc', 0, 5, 'cc', NULL, 1, 'M', '0', '0', NULL, '404', 1, '2023-05-10 14:12:13', 1, '2023-05-10 14:12:13', '', '1');
INSERT INTO `cc_menu` VALUES (2031, '测试cc', 2017, 5, 'ccc', NULL, 1, 'M', '0', '0', NULL, '404', 1, '2023-05-10 14:17:15', 1, '2023-05-10 14:35:17', '', '1');

-- ----------------------------
-- Table structure for cc_role
-- ----------------------------
DROP TABLE IF EXISTS `cc_role`;
CREATE TABLE `cc_role`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  `role_name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '角色名称',
  `role_key` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '角色权限字符串',
  `role_sort` int(4) NOT NULL COMMENT '显示顺序',
  `status` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '角色状态（0正常 1停用）',
  `del_flag` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '0' COMMENT '删除标志（0代表存在 1代表删除）',
  `create_by` bigint(20) NULL DEFAULT NULL COMMENT '创建者',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint(20) NULL DEFAULT NULL COMMENT '更新者',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  `remark` varchar(500) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '角色信息表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of cc_role
-- ----------------------------
INSERT INTO `cc_role` VALUES (1, '超级管理员', 'admin', 1, '0', '0', 0, '2021-11-12 10:46:19', 0, NULL, '超级管理员');
INSERT INTO `cc_role` VALUES (2, '普通角色', 'common', 2, '0', '0', 0, '2021-11-12 10:46:19', 0, '2022-01-01 22:32:58', '普通角色');
INSERT INTO `cc_role` VALUES (11, '嘎嘎嘎', 'aggag', 5, '0', '0', NULL, '2022-01-06 14:07:40', NULL, '2022-01-07 03:48:48', '嘎嘎嘎');
INSERT INTO `cc_role` VALUES (12, '友链审核员', 'link', 1, '0', '0', NULL, '2022-01-16 06:49:30', NULL, '2022-01-16 08:05:09', NULL);

-- ----------------------------
-- Table structure for cc_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `cc_role_menu`;
CREATE TABLE `cc_role_menu`  (
  `role_id` bigint(20) NOT NULL COMMENT '角色ID',
  `menu_id` bigint(20) NOT NULL COMMENT '菜单ID',
  PRIMARY KEY (`role_id`, `menu_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '角色和菜单关联表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of cc_role_menu
-- ----------------------------
INSERT INTO `cc_role_menu` VALUES (0, 0);
INSERT INTO `cc_role_menu` VALUES (2, 1);
INSERT INTO `cc_role_menu` VALUES (2, 102);
INSERT INTO `cc_role_menu` VALUES (2, 1013);
INSERT INTO `cc_role_menu` VALUES (2, 1014);
INSERT INTO `cc_role_menu` VALUES (2, 1015);
INSERT INTO `cc_role_menu` VALUES (2, 1016);
INSERT INTO `cc_role_menu` VALUES (2, 2000);
INSERT INTO `cc_role_menu` VALUES (3, 2);
INSERT INTO `cc_role_menu` VALUES (3, 3);
INSERT INTO `cc_role_menu` VALUES (3, 4);
INSERT INTO `cc_role_menu` VALUES (3, 100);
INSERT INTO `cc_role_menu` VALUES (3, 101);
INSERT INTO `cc_role_menu` VALUES (3, 103);
INSERT INTO `cc_role_menu` VALUES (3, 104);
INSERT INTO `cc_role_menu` VALUES (3, 105);
INSERT INTO `cc_role_menu` VALUES (3, 106);
INSERT INTO `cc_role_menu` VALUES (3, 107);
INSERT INTO `cc_role_menu` VALUES (3, 108);
INSERT INTO `cc_role_menu` VALUES (3, 109);
INSERT INTO `cc_role_menu` VALUES (3, 110);
INSERT INTO `cc_role_menu` VALUES (3, 111);
INSERT INTO `cc_role_menu` VALUES (3, 112);
INSERT INTO `cc_role_menu` VALUES (3, 113);
INSERT INTO `cc_role_menu` VALUES (3, 114);
INSERT INTO `cc_role_menu` VALUES (3, 115);
INSERT INTO `cc_role_menu` VALUES (3, 116);
INSERT INTO `cc_role_menu` VALUES (3, 500);
INSERT INTO `cc_role_menu` VALUES (3, 501);
INSERT INTO `cc_role_menu` VALUES (3, 1001);
INSERT INTO `cc_role_menu` VALUES (3, 1002);
INSERT INTO `cc_role_menu` VALUES (3, 1003);
INSERT INTO `cc_role_menu` VALUES (3, 1004);
INSERT INTO `cc_role_menu` VALUES (3, 1005);
INSERT INTO `cc_role_menu` VALUES (3, 1006);
INSERT INTO `cc_role_menu` VALUES (3, 1007);
INSERT INTO `cc_role_menu` VALUES (3, 1008);
INSERT INTO `cc_role_menu` VALUES (3, 1009);
INSERT INTO `cc_role_menu` VALUES (3, 1010);
INSERT INTO `cc_role_menu` VALUES (3, 1011);
INSERT INTO `cc_role_menu` VALUES (3, 1012);
INSERT INTO `cc_role_menu` VALUES (3, 1017);
INSERT INTO `cc_role_menu` VALUES (3, 1018);
INSERT INTO `cc_role_menu` VALUES (3, 1019);
INSERT INTO `cc_role_menu` VALUES (3, 1020);
INSERT INTO `cc_role_menu` VALUES (3, 1021);
INSERT INTO `cc_role_menu` VALUES (3, 1022);
INSERT INTO `cc_role_menu` VALUES (3, 1023);
INSERT INTO `cc_role_menu` VALUES (3, 1024);
INSERT INTO `cc_role_menu` VALUES (3, 1025);
INSERT INTO `cc_role_menu` VALUES (3, 1026);
INSERT INTO `cc_role_menu` VALUES (3, 1027);
INSERT INTO `cc_role_menu` VALUES (3, 1028);
INSERT INTO `cc_role_menu` VALUES (3, 1029);
INSERT INTO `cc_role_menu` VALUES (3, 1030);
INSERT INTO `cc_role_menu` VALUES (3, 1031);
INSERT INTO `cc_role_menu` VALUES (3, 1032);
INSERT INTO `cc_role_menu` VALUES (3, 1033);
INSERT INTO `cc_role_menu` VALUES (3, 1034);
INSERT INTO `cc_role_menu` VALUES (3, 1035);
INSERT INTO `cc_role_menu` VALUES (3, 1036);
INSERT INTO `cc_role_menu` VALUES (3, 1037);
INSERT INTO `cc_role_menu` VALUES (3, 1038);
INSERT INTO `cc_role_menu` VALUES (3, 1039);
INSERT INTO `cc_role_menu` VALUES (3, 1040);
INSERT INTO `cc_role_menu` VALUES (3, 1041);
INSERT INTO `cc_role_menu` VALUES (3, 1042);
INSERT INTO `cc_role_menu` VALUES (3, 1043);
INSERT INTO `cc_role_menu` VALUES (3, 1044);
INSERT INTO `cc_role_menu` VALUES (3, 1045);
INSERT INTO `cc_role_menu` VALUES (3, 1046);
INSERT INTO `cc_role_menu` VALUES (3, 1047);
INSERT INTO `cc_role_menu` VALUES (3, 1048);
INSERT INTO `cc_role_menu` VALUES (3, 1049);
INSERT INTO `cc_role_menu` VALUES (3, 1050);
INSERT INTO `cc_role_menu` VALUES (3, 1051);
INSERT INTO `cc_role_menu` VALUES (3, 1052);
INSERT INTO `cc_role_menu` VALUES (3, 1053);
INSERT INTO `cc_role_menu` VALUES (3, 1054);
INSERT INTO `cc_role_menu` VALUES (3, 1055);
INSERT INTO `cc_role_menu` VALUES (3, 1056);
INSERT INTO `cc_role_menu` VALUES (3, 1057);
INSERT INTO `cc_role_menu` VALUES (3, 1058);
INSERT INTO `cc_role_menu` VALUES (3, 1059);
INSERT INTO `cc_role_menu` VALUES (3, 1060);
INSERT INTO `cc_role_menu` VALUES (3, 2000);
INSERT INTO `cc_role_menu` VALUES (11, 1);
INSERT INTO `cc_role_menu` VALUES (11, 100);
INSERT INTO `cc_role_menu` VALUES (11, 101);
INSERT INTO `cc_role_menu` VALUES (11, 102);
INSERT INTO `cc_role_menu` VALUES (11, 103);
INSERT INTO `cc_role_menu` VALUES (11, 104);
INSERT INTO `cc_role_menu` VALUES (11, 105);
INSERT INTO `cc_role_menu` VALUES (11, 106);
INSERT INTO `cc_role_menu` VALUES (11, 107);
INSERT INTO `cc_role_menu` VALUES (11, 108);
INSERT INTO `cc_role_menu` VALUES (11, 500);
INSERT INTO `cc_role_menu` VALUES (11, 501);
INSERT INTO `cc_role_menu` VALUES (11, 1001);
INSERT INTO `cc_role_menu` VALUES (11, 1002);
INSERT INTO `cc_role_menu` VALUES (11, 1003);
INSERT INTO `cc_role_menu` VALUES (11, 1004);
INSERT INTO `cc_role_menu` VALUES (11, 1005);
INSERT INTO `cc_role_menu` VALUES (11, 1006);
INSERT INTO `cc_role_menu` VALUES (11, 1007);
INSERT INTO `cc_role_menu` VALUES (11, 1008);
INSERT INTO `cc_role_menu` VALUES (11, 1009);
INSERT INTO `cc_role_menu` VALUES (11, 1010);
INSERT INTO `cc_role_menu` VALUES (11, 1011);
INSERT INTO `cc_role_menu` VALUES (11, 1012);
INSERT INTO `cc_role_menu` VALUES (11, 1013);
INSERT INTO `cc_role_menu` VALUES (11, 1014);
INSERT INTO `cc_role_menu` VALUES (11, 1015);
INSERT INTO `cc_role_menu` VALUES (11, 1016);
INSERT INTO `cc_role_menu` VALUES (11, 1017);
INSERT INTO `cc_role_menu` VALUES (11, 1018);
INSERT INTO `cc_role_menu` VALUES (11, 1019);
INSERT INTO `cc_role_menu` VALUES (11, 1020);
INSERT INTO `cc_role_menu` VALUES (11, 1021);
INSERT INTO `cc_role_menu` VALUES (11, 1022);
INSERT INTO `cc_role_menu` VALUES (11, 1023);
INSERT INTO `cc_role_menu` VALUES (11, 1024);
INSERT INTO `cc_role_menu` VALUES (11, 1025);
INSERT INTO `cc_role_menu` VALUES (11, 1026);
INSERT INTO `cc_role_menu` VALUES (11, 1027);
INSERT INTO `cc_role_menu` VALUES (11, 1028);
INSERT INTO `cc_role_menu` VALUES (11, 1029);
INSERT INTO `cc_role_menu` VALUES (11, 1030);
INSERT INTO `cc_role_menu` VALUES (11, 1031);
INSERT INTO `cc_role_menu` VALUES (11, 1032);
INSERT INTO `cc_role_menu` VALUES (11, 1033);
INSERT INTO `cc_role_menu` VALUES (11, 1034);
INSERT INTO `cc_role_menu` VALUES (11, 1035);
INSERT INTO `cc_role_menu` VALUES (11, 1036);
INSERT INTO `cc_role_menu` VALUES (11, 1037);
INSERT INTO `cc_role_menu` VALUES (11, 1038);
INSERT INTO `cc_role_menu` VALUES (11, 1039);
INSERT INTO `cc_role_menu` VALUES (11, 1040);
INSERT INTO `cc_role_menu` VALUES (11, 1041);
INSERT INTO `cc_role_menu` VALUES (11, 1042);
INSERT INTO `cc_role_menu` VALUES (11, 1043);
INSERT INTO `cc_role_menu` VALUES (11, 1044);
INSERT INTO `cc_role_menu` VALUES (11, 1045);
INSERT INTO `cc_role_menu` VALUES (11, 2000);
INSERT INTO `cc_role_menu` VALUES (11, 2003);
INSERT INTO `cc_role_menu` VALUES (11, 2004);
INSERT INTO `cc_role_menu` VALUES (11, 2005);
INSERT INTO `cc_role_menu` VALUES (11, 2006);
INSERT INTO `cc_role_menu` VALUES (11, 2007);
INSERT INTO `cc_role_menu` VALUES (11, 2008);
INSERT INTO `cc_role_menu` VALUES (11, 2009);
INSERT INTO `cc_role_menu` VALUES (11, 2010);
INSERT INTO `cc_role_menu` VALUES (11, 2011);
INSERT INTO `cc_role_menu` VALUES (11, 2012);
INSERT INTO `cc_role_menu` VALUES (11, 2013);
INSERT INTO `cc_role_menu` VALUES (11, 2014);
INSERT INTO `cc_role_menu` VALUES (12, 2017);
INSERT INTO `cc_role_menu` VALUES (12, 2022);
INSERT INTO `cc_role_menu` VALUES (12, 2024);
INSERT INTO `cc_role_menu` VALUES (12, 2025);
INSERT INTO `cc_role_menu` VALUES (12, 2026);
INSERT INTO `cc_role_menu` VALUES (12, 2027);

-- ----------------------------
-- Table structure for cc_tag
-- ----------------------------
DROP TABLE IF EXISTS `cc_tag`;
CREATE TABLE `cc_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '标签名',
  `create_by` bigint(20) NULL DEFAULT NULL,
  `create_time` datetime(0) NULL DEFAULT NULL,
  `update_by` bigint(20) NULL DEFAULT NULL,
  `update_time` datetime(0) NULL DEFAULT NULL,
  `del_flag` int(1) NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  `remark` varchar(500) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '标签' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of cc_tag
-- ----------------------------
INSERT INTO `cc_tag` VALUES (1, 'Mybatis', NULL, NULL, NULL, '2022-01-11 09:20:50', 0, 'weqwe');
INSERT INTO `cc_tag` VALUES (2, 'asdas', NULL, '2022-01-11 09:20:55', NULL, '2022-01-11 09:20:55', 1, 'weqw');
INSERT INTO `cc_tag` VALUES (3, 'weqw', NULL, '2022-01-11 09:21:07', NULL, '2022-01-11 09:21:07', 1, 'qweqwe');
INSERT INTO `cc_tag` VALUES (4, 'Java', NULL, '2022-01-13 15:22:43', 1, '2023-05-09 16:33:06', 0, '基础');
INSERT INTO `cc_tag` VALUES (5, 'WAD', NULL, '2022-01-13 15:22:47', NULL, '2022-01-13 15:22:47', 1, 'ASDAD');
INSERT INTO `cc_tag` VALUES (6, 'Spring', 1, '2023-05-09 16:31:23', 1, '2023-05-09 16:31:23', 0, 'java核心');
INSERT INTO `cc_tag` VALUES (7, 'vue', 1, '2023-05-14 20:03:15', 1, '2023-05-14 20:03:15', 0, '前端框架');
INSERT INTO `cc_tag` VALUES (8, '日志', 1, '2023-05-14 20:04:20', 1, '2023-05-14 20:04:20', 0, '日志记录');
INSERT INTO `cc_tag` VALUES (9, 'SpringCloud', 1, '2023-06-12 09:55:43', 1, '2023-06-12 09:55:43', 0, 'SpringCloud分布式框架\n');
INSERT INTO `cc_tag` VALUES (10, '总结', 1, '2023-06-12 16:51:46', 1, '2023-06-12 16:51:46', 0, '知识总结');
INSERT INTO `cc_tag` VALUES (11, '开源框架技术', 1, '2023-06-16 22:48:05', 1, '2023-06-16 22:48:05', 0, '学习一些新颖的框架技术，进行流程分析');

-- ----------------------------
-- Table structure for cc_user
-- ----------------------------
DROP TABLE IF EXISTS `cc_user`;
CREATE TABLE `cc_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `user_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'NULL' COMMENT '用户名',
  `nick_name` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'NULL' COMMENT '昵称',
  `password` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT 'NULL' COMMENT '密码',
  `type` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '用户类型：0代表普通用户，1代表管理员',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '0' COMMENT '账号状态（0正常 1停用）',
  `email` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `phonenumber` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '手机号',
  `sex` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '用户性别（0男，1女，2未知）',
  `avatar` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '头像',
  `create_by` bigint(20) NULL DEFAULT NULL COMMENT '创建人的用户id',
  `create_time` datetime(0) NULL DEFAULT NULL COMMENT '创建时间',
  `update_by` bigint(20) NULL DEFAULT NULL COMMENT '更新人',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  `del_flag` int(11) NULL DEFAULT 0 COMMENT '删除标志（0代表未删除，1代表已删除）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 14787164048671 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '用户表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of cc_user
-- ----------------------------
INSERT INTO `cc_user` VALUES (1, 'cc', 'cc', '$2a$10$Jnq31rRkNV3RNzXe0REsEOSKaYK8UgVZZqlNlNXqn.JeVcj2NdeZy', '1', '0', 'ccgccg@yeah.net', '13268014239', '0', 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/06/c9c4abd005c043669e0af0c7e5693edc.png', NULL, '2022-01-05 09:01:56', 1, '2023-05-10 18:34:24', 0);
INSERT INTO `cc_user` VALUES (3, 'cc1', 'weqe', '$2a$10$ydv3rLkteFnRx9xelQ7elOiVhFvXOooA98xCqk/omh7G94R.K/E3O', '1', '0', NULL, NULL, '0', NULL, NULL, '2022-01-05 13:28:43', NULL, '2022-01-05 13:28:43', 0);
INSERT INTO `cc_user` VALUES (4, 'cc2', 'dsadd', '$2a$10$kY4T3SN7i4muBccZppd2OOkhxMN6yt8tND1sF89hXOaFylhY2T3he', '1', '0', '23412332@qq.com', '19098790742', '0', NULL, NULL, NULL, NULL, NULL, 0);
INSERT INTO `cc_user` VALUES (5, 'sg2233', 'tteqe', '', '1', '0', NULL, '18246845873', '1', NULL, NULL, '2022-01-06 03:51:13', NULL, '2022-01-06 07:00:50', 1);
INSERT INTO `cc_user` VALUES (6, 'sangeng', 'sangeng', '$2a$10$Jnq31rRkNV3RNzXe0REsEOSKaYK8UgVZZqlNlNXqn.JeVcj2NdeZy', '1', '0', '2312321', '17777777777', '0', NULL, NULL, '2022-01-16 06:54:26', NULL, '2022-01-16 07:06:34', 1);
INSERT INTO `cc_user` VALUES (14787164048662, 'weixin', 'cc3', '$2a$10$y3k3fnMZsBNihsVLXWfI8uMNueVXBI08k.LzWYaKsW8CW7xXy18wC', '0', '0', 'weixin@qq.com', '13368014239', '0', NULL, -1, '2022-01-30 17:18:44', 1, '2023-05-10 18:39:29', 0);
INSERT INTO `cc_user` VALUES (14787164048663, 'ccg', 'ccg', '$2a$10$lk0mPu.DUrbPFOuSa.52vuZyQrjJnNvwhUZAbEy63VN54TC9VqWLe', '0', '0', 'ccgccg@yeah.net', NULL, '1', 'http://ru8h77emb.hn-bkt.clouddn.com/2023/05/07/a4416178a8a74452a118b3e81703bd60.png', NULL, NULL, NULL, NULL, 0);
INSERT INTO `cc_user` VALUES (14787164048664, 'ccc', 'ccc', '$2a$10$aQnEl8LqDJs1FyNrX0ryqOidQ//2GyWANuTGeA0pcZUD3c/mcczWq', '0', '0', '1321132adada@qq.com', NULL, NULL, NULL, NULL, NULL, NULL, NULL, 1);
INSERT INTO `cc_user` VALUES (14787164048665, 'ccc', 'ccc', '$2a$10$UZy/38O9CizByRGa81FTEe/B6kMZmh/aNADv06/DjJNGFSEtJqXRO', '0', '0', 'ccgccg1@yeah.net', '13268014238', '0', NULL, 1, '2023-05-10 18:42:40', 1, '2023-05-10 18:42:40', 0);
INSERT INTO `cc_user` VALUES (14787164048666, 'Jeas', '稷安思', '$2a$10$nQ1C849RcTVkN0y/MNR0JuO8uZg7Pw.G5VapeP8rhb8CLkoX1mYwm', '0', '0', '1794837325@qq.com', '17873315496', '0', NULL, 1, '2023-05-15 08:46:45', 1, '2023-05-15 08:46:45', 0);
INSERT INTO `cc_user` VALUES (14787164048667, 'admin', 'admin', '$2a$10$47O9/KIjp5RLf.Zwg5.pbea92R5ZqXSfzWfyghMszZXFqcgzknvDm', '0', '0', 'apifox@163.com', NULL, NULL, NULL, -1, '2023-05-21 19:33:40', -1, '2023-05-21 19:33:40', 0);
INSERT INTO `cc_user` VALUES (14787164048668, 'qwer173146', 'skks', '$2a$10$V9GLtRcRoTlCGVh5tCAN1OmfJrkt4XpbRWR7qQDUUfSuAhKCji.ti', '0', '0', '132@qq.com', NULL, NULL, NULL, -1, '2023-05-27 14:03:08', -1, '2023-05-27 14:03:08', 0);
INSERT INTO `cc_user` VALUES (14787164048669, 'sss', 'sss', '$2a$10$eg03hjRIT.0QO8CKODzCDORdG6wAmqPVihNZLsvZM4yVDz5ge9RLu', '0', '0', 'wangm_happy@163.com', NULL, NULL, NULL, -1, '2023-06-18 23:02:21', -1, '2023-06-18 23:02:21', 0);
INSERT INTO `cc_user` VALUES (14787164048670, 'ss', '头像', '$2a$10$9fWsnI/n0RCZLOwRwbjzDO3O5kOFX4GhzIpCxkooodmDhzAP6XtrK', '0', '0', '53396229@qq.com', NULL, '0', 'http://ru8h77emb.hn-bkt.clouddn.com/2023/07/02/7b34d15076b14e0ea4d77cbbb5b57fad.jpg', -1, '2023-07-02 14:12:27', 14787164048670, '2023-07-02 14:14:20', 0);

-- ----------------------------
-- Table structure for cc_user_role
-- ----------------------------
DROP TABLE IF EXISTS `cc_user_role`;
CREATE TABLE `cc_user_role`  (
  `user_id` bigint(20) NOT NULL COMMENT '用户ID',
  `role_id` bigint(20) NOT NULL COMMENT '角色ID',
  PRIMARY KEY (`user_id`, `role_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '用户和角色关联表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of cc_user_role
-- ----------------------------
INSERT INTO `cc_user_role` VALUES (1, 1);
INSERT INTO `cc_user_role` VALUES (2, 2);
INSERT INTO `cc_user_role` VALUES (14787164048662, 2);
INSERT INTO `cc_user_role` VALUES (14787164048665, 2);
INSERT INTO `cc_user_role` VALUES (14787164048666, 1);

SET FOREIGN_KEY_CHECKS = 1;
