# 									博客系统

## 1.父版本管理

在父项目中使用dependencyManagement管理依赖，并不会引入依赖，而是对依赖进行版本控制，等到子项目引入相应的依赖后就不需要填写版本，进行了版本控制。

```xml
<dependencyManagement>
        <dependencies>
            <!-- SpringBoot的依赖配置-->
            <!--对SpringBoot的版本进行配置，以后引入boot的相关依赖则不需要配置版本-->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>2.5.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!--fastjson依赖-->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>1.2.33</version>
            </dependency>
            <!--jwt依赖-->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>0.9.0</version>
            </dependency>

            <!--mybatisPlus依赖-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>3.4.3</version>
            </dependency>

            <!--阿里云OSS-->
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>3.10.2</version>
            </dependency>


            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>easyexcel</artifactId>
                <version>3.0.5</version>
            </dependency>

            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger2</artifactId>
                <version>2.9.2</version>
            </dependency>
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger-ui</artifactId>
                <version>2.9.2</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
```

## 2. Bean对象复制工具类

使用spring的BeanUtils工具类进行属性复制，并使用工作流、反射和泛型集成系统通用的工具类，对数据库返回的一级对象，进行属性的过滤，减少空间和提高安全性。工具的复制原理是根据实体类属性的类型和名称做复制。

```java
/**
     * @param source 原对象
     * @param clazz 复制目标对象的类属性
     * @return: V   目标对象的泛型
     * @decription 通过spring的工具类进行对象复制
     * @date 2023/4/25 13:18
    */
    public static <V> V copyBean(Object source,Class<V> clazz){
        V resutl = null;
        try {
            resutl = clazz.newInstance();
            //复制
            BeanUtils.copyProperties(source,resutl);
        } catch (InstantiationException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
        return resutl;
    }

    /**
     * @param sources 原目标集合
     * @param clazz 目标集合类型
     * @return: java.util.List<V>
     * @decription 通过spring工具类与工作流对集合的全部对象进行属性复制
     * @date 2023/4/25 13:23
    */
    public static <O,V> List<V> copyBeans(List<O> sources,Class<V> clazz){
        List<V> list = sources.stream()
                .map(o -> copyBean(o, clazz))
                .collect(Collectors.toList());
        return list;
    }
```

## 3. QueryWrapper对象进行限制结果条数

### 3.1使用last方法进行limit处理

```java
LambdaQueryWrapper<Article> wrapper = new LambdaQueryWrapper<>();
//排除草稿
wrapper.eq(Article::getStatus, SystemConstant.ARTICLE_STATUS_NORMAL);
//降序
wrapper.orderByDesc(Article::getViewCount);
//最多10条
wrapper.last("limit 10");
List<Article> articles = articleMapper.selectList(wrapper);
return articles;
```

### 3.2使用分页进行limit处理

```java
LambdaQueryWrapper<Article> wrapper = new LambdaQueryWrapper<>();
//排除草稿
wrapper.eq(Article::getStatus, SystemConstant.ARTICLE_STATUS_NORMAL);
//降序
wrapper.orderByDesc(Article::getViewCount);
//最多10条
Page<Article> page = articleMapper.selectPage(new Page<Article>(1,10),wrapper);
List<Article> articles = page.getRecords();
return articles;
```

## 4.跨域处理

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // 设置允许跨域的路径
        registry.addMapping("/**")
                // 设置允许跨域请求的域名
                .allowedOriginPatterns("*")
                // 是否允许cookie
                .allowCredentials(true)
                // 设置允许的请求方式
                .allowedMethods("GET", "POST", "DELETE", "PUT")
                // 设置允许的header属性
                .allowedHeaders("*")
                // 跨域允许时间
                .maxAge(3600);
    }

}
```

## 5.日期格式转换

后端传日期数据到前端的时候，系统使用默认的json转换，不适合阅读习惯，可以使用SpringBoot的@jsonFormat注解，指定json格式。

## 6.动态wrapper

可以使用queryWrapper完成参数的动态注入，类似于动态标签，仅当条件成立的时候，才会添加条件限定

```java
LambdaQueryWrapper<Article> wrapper = new LambdaQueryWrapper<>();
        //状态正常
        wrapper.eq(Article::getStatus,SystemConstant.ARTICLE_STATUS_NORMAL);
        wrapper.eq(Article::getDelFlag,SystemConstant.ARTICLE_STATUS_NORMAL);
        //是否根据博文分类id分页,eq方法的重载，若第一个条件成立，则加入该条件限制查询
        wrapper.eq(Objects.nonNull(categoryId)&&categoryId > 0,Article::getCategoryId,categoryId);
        //排序，根据isTop字段，进行降序排序
        wrapper.orderByDesc(Article::getIsTop);
        //分页查询
        Page<Article> articlePage = articleMapper.selectPage(new Page<Article>(pageNum, pageSize), wrapper);
        articlePage.getRecords().stream()
                .forEach(article -> {
                    Category category = categoryService.getCategoryById(article.getCategoryId());
                    article.setCategoryName(category.getName());
                });
```

## 7. jwt登录工具	

## 8. SpringSecurity登录认证处理类

区别于一般的SpringSecurity登录流程，此时可以自己调用方法进行认证，底层都是使用UserDetailsService，前者是SpringSecurity自己调用完成用户校验，后者是自己使用AuthenticationManager完成用户认证，并拿到用户令牌，而前者需要在securityContextholder（安全上下文）中获取。但是前者验证通过后会把用户的身份信息放入上下文中，而后者需要自己放入。

```java
@Service
public class BlogLoginServiceImpl implements BlogLoginService {

    //用户认证管理器
    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private RedisTemplate<String,Object> redisTemplate;

    @Override
    public ResponseResult<BlogUserLoginVo> login(User user) {
        //登录权证
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());
        //认证信息，该方法会调用userDetailService的认证逻辑，进行判断，此方法会使用UserDetailService进行逻辑判断
        Authentication authentication = authenticationManager.authenticate(authenticationToken);
        //获取认证用户信息
        LoginUser loginUser = (LoginUser) authentication.getPrincipal();
        //认证通过，生成token
        String userId = loginUser.getUser().getId().toString();
        String token = JwtUtil.createJWT(userId);
        //把用户id和用户信息存入redis，过期时间为10分钟
        redisTemplate.opsForValue().set("loginUser:"+userId,loginUser,10, TimeUnit.MINUTES);

        //把token和userInfo封装并返回
        UserInfoVo userInfoVo = BeanCopyUtils.copyBean(loginUser.getUser(), UserInfoVo.class);
        BlogUserLoginVo blogUserLoginVo = new BlogUserLoginVo(token, userInfoVo);
        return ResponseResult.okResult(blogUserLoginVo);
    }
}
```

需要在springSecurity的配置文件中配置使用登录管理器AuthenticationManager

```java
//登录认证器，使用这个类可以管理登录信息，并进行相应处理
    @Bean
    @Override
    protected AuthenticationManager authenticationManager() throws Exception {
        return super.authenticationManager();
    }
```

## 9.登录校验过滤器

使用jwt进行token生成加密，并发送到前端之后，后续请求都会在请求头中附带token信息。此时需要一个过滤器，拦截请求，判断是否可以进行相应的操作。这种做法区别于先前的handlerInterceptor。

### 9.1HandlerInterceptor

```java
//创建登录拦截器
public class JWTInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String token = request.getHeader("token");
        //对令牌进行拦截验证
        JWTUtils.verify(token);
        return true;
    }
}

//配置使用登录拦截器
@Configuration
public class InterceptorConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new JWTInterceptor())
                .addPathPatterns("/**")    //拦截全部请求
                .excludePathPatterns(
                        "/user/goodsSearch/autoSuggest"           //自动补齐关键字
                );                         //放行的请求
    }
}
```

### 9.2 OncePerRequestFilter

```java
//创建登录拦截器
@Component
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;


    @Override
    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {
        //获取请求头中的token
        String token = httpServletRequest.getHeader("token");
        //没有token则需要进行登录
        if(!StringUtils.hasText(token)){
            System.out.println("没有token身份信息，直接放行");
            filterChain.doFilter(httpServletRequest,httpServletResponse);
            return;
        }
        //解析token
        Claims claims = null;
        try {
            claims = JwtUtil.parseJWT(token);
        } catch (Exception e) {
            //token解析错误，重新登录
            System.out.println("token解析错误");
            e.printStackTrace();
            ResponseResult errorResult = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);
            WebUtils.renderString(httpServletResponse, JSON.toJSONString(errorResult));
            return;
        }
        //获取userId
        String userId = claims.getSubject();
        //从redis中获取用户信息
        LoginUser loginUser = (LoginUser) redisTemplate.opsForValue().get("loginUser:" + userId);
        if(Objects.isNull(loginUser)){
            System.out.println("redis身份信息过期，重新登录");
            ResponseResult errorResult = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);
            WebUtils.renderString(httpServletResponse, JSON.toJSONString(errorResult));
            return;
        }
        //将身份信息存入securityContext
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, null);
        SecurityContextHolder.getContext().setAuthentication(authenticationToken);
        //请求跳转
        filterChain.doFilter(httpServletRequest,httpServletResponse);
    }
}

//配置使用拦截器
@Override
    protected void configure(HttpSecurity http) throws Exception {
        //开启跨域
        http.cors();
        //关闭csrf
        http.csrf().disable();
        //配置权限
        http.authorizeRequests().antMatchers("/login").permitAll()
                .antMatchers("/link/getAllLink").authenticated()
                //前台不需要仅限权限管理，不需要登录也可以进行全部操作
                .anyRequest().permitAll();
        //配置登录检验过滤器
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);
    }
```

