# 									博客系统

## 1.父版本管理

在父项目中使用dependencyManagement管理依赖，并不会引入依赖，而是对依赖进行版本控制，等到子项目引入相应的依赖后就不需要填写版本，进行了版本控制。

```xml
<dependencyManagement>
        <dependencies>
            <!-- SpringBoot的依赖配置-->
            <!--对SpringBoot的版本进行配置，以后引入boot的相关依赖则不需要配置版本-->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>2.5.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!--fastjson依赖-->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>1.2.33</version>
            </dependency>
            <!--jwt依赖-->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>0.9.0</version>
            </dependency>

            <!--mybatisPlus依赖-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>3.4.3</version>
            </dependency>

            <!--阿里云OSS-->
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>3.10.2</version>
            </dependency>


            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>easyexcel</artifactId>
                <version>3.0.5</version>
            </dependency>

            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger2</artifactId>
                <version>2.9.2</version>
            </dependency>
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger-ui</artifactId>
                <version>2.9.2</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
```

## 2. Bean对象复制工具类

使用spring的BeanUtils工具类进行属性复制，并使用工作流、反射和泛型集成系统通用的工具类，对数据库返回的一级对象，进行属性的过滤，减少空间和提高安全性

```java
/**
     * @param source 原对象
     * @param clazz 复制目标对象的类属性
     * @return: V   目标对象的泛型
     * @decription 通过spring的工具类进行对象复制
     * @date 2023/4/25 13:18
    */
    public static <V> V copyBean(Object source,Class<V> clazz){
        V resutl = null;
        try {
            resutl = clazz.newInstance();
            //复制
            BeanUtils.copyProperties(source,resutl);
        } catch (InstantiationException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
        return resutl;
    }

    /**
     * @param sources 原目标集合
     * @param clazz 目标集合类型
     * @return: java.util.List<V>
     * @decription 通过spring工具类与工作流对集合的全部对象进行属性复制
     * @date 2023/4/25 13:23
    */
    public static <O,V> List<V> copyBeans(List<O> sources,Class<V> clazz){
        List<V> list = sources.stream()
                .map(o -> copyBean(o, clazz))
                .collect(Collectors.toList());
        return list;
    }
```

## 3. QueryWrapper对象进行限制结果条数

### 3.1使用last方法进行limit处理

```java
LambdaQueryWrapper<Article> wrapper = new LambdaQueryWrapper<>();
//排除草稿
wrapper.eq(Article::getStatus, SystemConstant.ARTICLE_STATUS_NORMAL);
//降序
wrapper.orderByDesc(Article::getViewCount);
//最多10条
wrapper.last("limit 10");
List<Article> articles = articleMapper.selectList(wrapper);
return articles;
```

### 3.2使用分页进行limit处理

```java
LambdaQueryWrapper<Article> wrapper = new LambdaQueryWrapper<>();
//排除草稿
wrapper.eq(Article::getStatus, SystemConstant.ARTICLE_STATUS_NORMAL);
//降序
wrapper.orderByDesc(Article::getViewCount);
//最多10条
Page<Article> page = articleMapper.selectPage(new Page<Article>(1,10),wrapper);
List<Article> articles = page.getRecords();
return articles;
```

## 4.跨域处理

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // 设置允许跨域的路径
        registry.addMapping("/**")
                // 设置允许跨域请求的域名
                .allowedOriginPatterns("*")
                // 是否允许cookie
                .allowCredentials(true)
                // 设置允许的请求方式
                .allowedMethods("GET", "POST", "DELETE", "PUT")
                // 设置允许的header属性
                .allowedHeaders("*")
                // 跨域允许时间
                .maxAge(3600);
    }

}
```

