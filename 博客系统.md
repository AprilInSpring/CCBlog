# 									博客系统

## 1.父版本管理

在父项目中使用dependencyManagement管理依赖，并不会引入依赖，而是对依赖进行版本控制，等到子项目引入相应的依赖后就不需要填写版本，进行了版本控制。

```xml
<dependencyManagement>
        <dependencies>
            <!-- SpringBoot的依赖配置-->
            <!--对SpringBoot的版本进行配置，以后引入boot的相关依赖则不需要配置版本-->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>2.5.0</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!--fastjson依赖-->
            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>fastjson</artifactId>
                <version>1.2.33</version>
            </dependency>
            <!--jwt依赖-->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt</artifactId>
                <version>0.9.0</version>
            </dependency>

            <!--mybatisPlus依赖-->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>3.4.3</version>
            </dependency>

            <!--阿里云OSS-->
            <dependency>
                <groupId>com.aliyun.oss</groupId>
                <artifactId>aliyun-sdk-oss</artifactId>
                <version>3.10.2</version>
            </dependency>


            <dependency>
                <groupId>com.alibaba</groupId>
                <artifactId>easyexcel</artifactId>
                <version>3.0.5</version>
            </dependency>

            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger2</artifactId>
                <version>2.9.2</version>
            </dependency>
            <dependency>
                <groupId>io.springfox</groupId>
                <artifactId>springfox-swagger-ui</artifactId>
                <version>2.9.2</version>
            </dependency>
        </dependencies>
    </dependencyManagement>
```

## 2. Bean对象复制工具类

使用spring的BeanUtils工具类进行属性复制，并使用工作流、反射和泛型集成系统通用的工具类，对数据库返回的一级对象，进行属性的过滤，减少空间和提高安全性。工具的复制原理是根据实体类属性的类型和名称做复制。

```java
/**
     * @param source 原对象
     * @param clazz 复制目标对象的类属性
     * @return: V   目标对象的泛型
     * @decription 通过spring的工具类进行对象复制
     * @date 2023/4/25 13:18
    */
    public static <V> V copyBean(Object source,Class<V> clazz){
        V resutl = null;
        try {
            resutl = clazz.newInstance();
            //复制
            BeanUtils.copyProperties(source,resutl);
        } catch (InstantiationException e) {
            throw new RuntimeException(e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException(e);
        }
        return resutl;
    }

    /**
     * @param sources 原目标集合
     * @param clazz 目标集合类型
     * @return: java.util.List<V>
     * @decription 通过spring工具类与工作流对集合的全部对象进行属性复制
     * @date 2023/4/25 13:23
    */
    public static <O,V> List<V> copyBeans(List<O> sources,Class<V> clazz){
        List<V> list = sources.stream()
                .map(o -> copyBean(o, clazz))
                .collect(Collectors.toList());
        return list;
    }
```

## 3. QueryWrapper对象进行限制结果条数

### 3.1使用last方法进行limit处理

```java
LambdaQueryWrapper<Article> wrapper = new LambdaQueryWrapper<>();
//排除草稿
wrapper.eq(Article::getStatus, SystemConstant.ARTICLE_STATUS_NORMAL);
//降序
wrapper.orderByDesc(Article::getViewCount);
//最多10条
wrapper.last("limit 10");
List<Article> articles = articleMapper.selectList(wrapper);
return articles;
```

### 3.2使用分页进行limit处理

```java
LambdaQueryWrapper<Article> wrapper = new LambdaQueryWrapper<>();
//排除草稿
wrapper.eq(Article::getStatus, SystemConstant.ARTICLE_STATUS_NORMAL);
//降序
wrapper.orderByDesc(Article::getViewCount);
//最多10条
Page<Article> page = articleMapper.selectPage(new Page<Article>(1,10),wrapper);
List<Article> articles = page.getRecords();
return articles;
```

## 4.跨域处理

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // 设置允许跨域的路径
        registry.addMapping("/**")
                // 设置允许跨域请求的域名
                .allowedOriginPatterns("*")
                // 是否允许cookie
                .allowCredentials(true)
                // 设置允许的请求方式
                .allowedMethods("GET", "POST", "DELETE", "PUT")
                // 设置允许的header属性
                .allowedHeaders("*")
                // 跨域允许时间
                .maxAge(3600);
    }

}
```

## 5.日期格式转换

后端传日期数据到前端的时候，系统使用默认的json转换，不适合阅读习惯，可以使用SpringBoot的@jsonFormat注解，指定json格式。

### 5.1日期格式转换工具类

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Bean//使用@Bean注入fastJsonHttpMessageConvert
    public HttpMessageConverter fastJsonHttpMessageConverters() {
        //1.需要定义一个Convert转换消息的对象
        FastJsonHttpMessageConverter fastConverter = new FastJsonHttpMessageConverter();
        FastJsonConfig fastJsonConfig = new FastJsonConfig();
        fastJsonConfig.setSerializerFeatures(SerializerFeature.PrettyFormat);
        fastJsonConfig.setDateFormat("yyyy-MM-dd HH:mm:ss");

        SerializeConfig.globalInstance.put(Long.class, ToStringSerializer.instance);

        fastJsonConfig.setSerializeConfig(SerializeConfig.globalInstance);
        fastConverter.setFastJsonConfig(fastJsonConfig);
        HttpMessageConverter<?> converter = fastConverter;
        return converter;
    }

    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        converters.add(fastJsonHttpMessageConverters());
    }
}
```



## 6.动态wrapper

可以使用queryWrapper完成参数的动态注入，类似于动态标签，仅当条件成立的时候，才会添加条件限定

```java
LambdaQueryWrapper<Article> wrapper = new LambdaQueryWrapper<>();
        //状态正常
        wrapper.eq(Article::getStatus,SystemConstant.ARTICLE_STATUS_NORMAL);
        wrapper.eq(Article::getDelFlag,SystemConstant.ARTICLE_STATUS_NORMAL);
        //是否根据博文分类id分页,eq方法的重载，若第一个条件成立，则加入该条件限制查询
        wrapper.eq(Objects.nonNull(categoryId)&&categoryId > 0,Article::getCategoryId,categoryId);
        //排序，根据isTop字段，进行降序排序
        wrapper.orderByDesc(Article::getIsTop);
        //分页查询
        Page<Article> articlePage = articleMapper.selectPage(new Page<Article>(pageNum, pageSize), wrapper);
        articlePage.getRecords().stream()
                .forEach(article -> {
                    Category category = categoryService.getCategoryById(article.getCategoryId());
                    article.setCategoryName(category.getName());
                });
```

## 7. jwt登录工具	

待更新

## 8. SpringSecurity登录认证处理类

区别于一般的SpringSecurity登录流程，此时可以自己调用方法进行认证，底层都是使用UserDetailsService，前者是SpringSecurity自己调用完成用户校验，后者是自己使用AuthenticationManager完成用户认证，并拿到用户令牌，而前者需要在securityContextholder（安全上下文）中获取。但是前者验证通过后会把用户的身份信息放入上下文中，而后者需要自己放入。

```java
@Service
public class BlogLoginServiceImpl implements BlogLoginService {

    //用户认证管理器
    @Autowired
    private AuthenticationManager authenticationManager;

    @Autowired
    private RedisTemplate<String,Object> redisTemplate;

    @Override
    public ResponseResult<BlogUserLoginVo> login(User user) {
        //登录权证
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());
        //认证信息，该方法会调用userDetailService的认证逻辑，进行判断，此方法会使用UserDetailService进行逻辑判断
        Authentication authentication = authenticationManager.authenticate(authenticationToken);
        //获取认证用户信息
        LoginUser loginUser = (LoginUser) authentication.getPrincipal();
        //认证通过，生成token
        String userId = loginUser.getUser().getId().toString();
        String token = JwtUtil.createJWT(userId);
        //把用户id和用户信息存入redis，过期时间为10分钟
        redisTemplate.opsForValue().set("loginUser:"+userId,loginUser,10, TimeUnit.MINUTES);

        //把token和userInfo封装并返回
        UserInfoVo userInfoVo = BeanCopyUtils.copyBean(loginUser.getUser(), UserInfoVo.class);
        BlogUserLoginVo blogUserLoginVo = new BlogUserLoginVo(token, userInfoVo);
        return ResponseResult.okResult(blogUserLoginVo);
    }
}
```

需要在springSecurity的配置文件中配置使用登录管理器AuthenticationManager

```java
//登录认证器，使用这个类可以管理登录信息，并进行相应处理
    @Bean
    @Override
    protected AuthenticationManager authenticationManager() throws Exception {
        return super.authenticationManager();
    }
```

## 9.登录校验过滤器

使用jwt进行token生成加密，并发送到前端之后，后续请求都会在请求头中附带token信息。此时需要一个过滤器，拦截请求，判断是否可以进行相应的操作。这种做法区别于先前的handlerInterceptor。

### 9.1HandlerInterceptor

```java
//创建登录拦截器
public class JWTInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        String token = request.getHeader("token");
        //对令牌进行拦截验证
        JWTUtils.verify(token);
        return true;
    }
}

//配置使用登录拦截器
@Configuration
public class InterceptorConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new JWTInterceptor())
                .addPathPatterns("/**")    //拦截全部请求
                .excludePathPatterns(
                        "/user/goodsSearch/autoSuggest"           //自动补齐关键字
                );                         //放行的请求
    }
}
```

### 9.2 OncePerRequestFilter

```java
//创建登录拦截器
@Component
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;


    @Override
    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {
        //获取请求头中的token
        String token = httpServletRequest.getHeader("token");
        //没有token则需要进行登录
        if(!StringUtils.hasText(token)){
            System.out.println("没有token身份信息，直接放行");
            filterChain.doFilter(httpServletRequest,httpServletResponse);
            return;
        }
        //解析token
        Claims claims = null;
        try {
            claims = JwtUtil.parseJWT(token);
        } catch (Exception e) {
            //token解析错误，重新登录
            System.out.println("token解析错误");
            e.printStackTrace();
            ResponseResult errorResult = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);
            WebUtils.renderString(httpServletResponse, JSON.toJSONString(errorResult));
            return;
        }
        //获取userId
        String userId = claims.getSubject();
        //从redis中获取用户信息
        LoginUser loginUser = (LoginUser) redisTemplate.opsForValue().get("loginUser:" + userId);
        if(Objects.isNull(loginUser)){
            System.out.println("redis身份信息过期，重新登录");
            ResponseResult errorResult = ResponseResult.errorResult(AppHttpCodeEnum.NEED_LOGIN);
            WebUtils.renderString(httpServletResponse, JSON.toJSONString(errorResult));
            return;
        }
        //将身份信息存入securityContext
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(loginUser, null, null);
        SecurityContextHolder.getContext().setAuthentication(authenticationToken);
        //请求跳转
        filterChain.doFilter(httpServletRequest,httpServletResponse);
    }
}

//配置使用拦截器
@Override
    protected void configure(HttpSecurity http) throws Exception {
        //开启跨域
        http.cors();
        //关闭csrf
        http.csrf().disable();
        //配置权限
        http.authorizeRequests().antMatchers("/login").permitAll()
                .antMatchers("/link/getAllLink").authenticated()
                //前台不需要仅限权限管理，不需要登录也可以进行全部操作
                .anyRequest().permitAll();
        //配置登录检验过滤器
        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);
    }
```

### 9.3 SpringSecurity安全框架知识补充

1.使用该框架进行登录之后，系统框架会自动把用户的信息存入SecurityContextHolder中，这样下次再进行某些	需要登录才能访问的请求的时候，就不需要再重新登录。

2.SecurityContextHolder是基于ThreadLocal实现的，每个线程的身份凭证都是独立的，互不影响。

3.InsufficientAuthenticationException，用户未登录异常类，当用户请求一些需要登录才可以访问的路径的时	        	候，就会抛出此异常

4.BadCredentialsException，当用户输入的密码不匹配的时候，就会抛出此类异常

5.SecurityContextHolder，使用该上下文类，可以设置，获取以及消除认证用户，setContext 可以进行认证用户	的设置；getContext 获取到当前认证用户。clearContext 清除当前的认证用户。



### 9.4 使用自定退出登录功能

```java
public ResponseResult logout() {
        //1.清除redis缓存
        LoginUser loginUser = (LoginUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        Long userId = loginUser.getUser().getId();
        redisTemplate.delete("loginUser:"+userId.toString());
        //2.清除SecurityContext中的凭证信息
        SecurityContextHolder.clearContext();
        return ResponseResult.okResult();
    }
```

```java
//并在security的配置类中取消系统自带的退出登录功能
//禁止security自带的推出登录
http.logout().disable();
```

## 10.afterPropertiesSet方法

在spring的bean的生命周期中，实例化->生成对象->属性填充后会进行afterPropertiesSet方法，这个方法可以用在一些特殊情况中，也就是某个对象的某个属性需要经过外界得到，比如说查询数据库等方式，这时候可以用到spring的该特性，只需要实现InitializingBean即可。而在redis之中，该方法已经别被redis的模板重写，具体的作用是对redis的连接工厂进行一个非空的判断。

![image-20230505101746023](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230505101746023.png)

![image-20230505101748896](C:\Users\PC\AppData\Roaming\Typora\typora-user-images\image-20230505101748896.png)

## 11.Redis序列化

```java
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        //创建模板
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        //设置工厂
        template.setConnectionFactory(connectionFactory);

        // 使用StringRedisSerializer来序列化和反序列化redis的key值
        template.setKeySerializer(new StringRedisSerializer());
        //	使用redis自带的序列化工具，完成值的序列化处理
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());

        // Hash的key也采用StringRedisSerializer的序列化方式
        template.setHashKeySerializer(new StringRedisSerializer());
        //	使用redis自带的序列化工具，完成值的序列化处理
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());

        //已解决，在redisTemplate完成属性注入之后，进行一些初始化操作，具体为设置模板的连接工厂判断，不能为null，否则会抛出异常，
        //该方法就是设置抛出异常，并设置异常信息
        template.afterPropertiesSet();
        return template;
    }
}
```

## 12.OSS七牛云图片存储服务

### 12.1进行七牛图片服务的配置

```yml
oss:
  accessKey: 5-2GlwUhAhcdzxRewexQrBqAVhmfBlOXyi1b5fVH
  secretKey: _HUU99Np_NNMUr--WWPjrpCKGJZqRBvocm8UVvfP
  bucket: ccg
  url: http://ru8h77emb.hn-bkt.clouddn.com/
```

### 12.2使用官方模板进行图片上传并回传图片路径

~~~~java
/**
 * @ClassName UploadServiceImpl
 * @Description 图片上传服务
 * @Author cc
 * @Date 2023/5/6 20:15
 * @Version 1.0
 */
@Service
public class UploadServiceImpl implements UploadService {

    @Value("${oss.accessKey}")
    private String accessKey;

    @Value("${oss.secretKey}")
    private String secretKey;

    @Value("${oss.bucket}")
    private String bucket;

    @Value("${oss.url}")
    private String url;

    @Override
    public ResponseResult uploadImg(MultipartFile img) {
        //获取源文件名
        String originalFilename = img.getOriginalFilename();
        //判断文件后缀，目前只支持jpg和png
        if(!(originalFilename.endsWith("jpg")||originalFilename.endsWith("png"))){
            throw new SystemException(AppHttpCodeEnum.IMG_TYPE_ERROR);
        }
        String imgPath = PathUtils.generateFilePath(originalFilename);
        //进行图片上传到oss，并返回url地址
        String imgUrl = uploadToOOS(img, imgPath);
        return ResponseResult.okResult(imgUrl);
    }

    private String uploadToOOS(MultipartFile img,String filePath){
        //构造一个带指定 Region 对象的配置类
        Configuration cfg = new Configuration(Region.autoRegion());
        //...其他参数参考类注释
        UploadManager uploadManager = new UploadManager(cfg);
        //默认不指定key的情况下，以文件内容的hash值作为文件名
        String key = filePath;

        try {
            InputStream inputStream = img.getInputStream();
            Auth auth = Auth.create(accessKey, secretKey);
            String upToken = auth.uploadToken(bucket);

            try {
                Response response = uploadManager.put(inputStream,key,upToken,null, null);
                //解析上传成功的结果
                DefaultPutRet putRet = new Gson().fromJson(response.bodyString(), DefaultPutRet.class);
                return url+key;
            } catch (QiniuException ex) {
                Response r = ex.response;
                System.err.println(r.toString());
                try {
                    System.err.println(r.bodyString());
                } catch (QiniuException ex2) {
                    //ignore
                }
            }
        } catch (Exception ex) {
            //ignore
        }
        return null;
    }
}
~~~~

## 13.参数校验

SpringBoot自带了validation工具可以从后端对前端传来的参数进行校验，用法如下：添加起步依赖

~~~~xml
<!-- 参数校验 -->
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
~~~~

~~~~java
@Data
@AllArgsConstructor
@NoArgsConstructor
@ApiModel("用户表(CcUser)表实体类")
public class User {
    //主键
    private Long id;
    //用户名
    @NotNull(message = "用户名不能为空")
    @NotBlank(message = "用户名不能为空")
    @ApiModelProperty("用户名")
    private String userName;
    //昵称
    @NotNull(message = "昵称不能为空")
    @NotBlank(message = "昵称不能为空")
    @ApiModelProperty("昵称")
    private String nickName;
    //密码
    @NotNull(message = "密码不能为空")
    @NotBlank(message = "密码不能为空")
    @ApiModelProperty("密码")
    private String password;
    //用户类型：0代表普通用户，1代表管理员
    @ApiModelProperty("用户类型：0代表普通用户，1代表管理员")
    private String type;
    //账号状态（0正常 1停用）
    @ApiModelProperty("账号状态（0正常 1停用）")
    private String status;
    //邮箱
    @NotNull(message = "邮箱不能为空")
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不合法")
    @ApiModelProperty("邮箱")
    private String email;
    //手机号
    @ApiModelProperty("手机号")
    private String phonenumber;
    //用户性别（0男，1女，2未知）
    @ApiModelProperty("用户性别（0男，1女，2未知）")
    private String sex;
    //头像
    @ApiModelProperty("头像")
    private String avatar;
    //创建人的用户id
    private Long createBy;
    //创建时间
    private Date createTime;
    //更新人
    private Long updateBy;
    //更新时间
    private Date updateTime;
    //删除标志（0代表未删除，1代表已删除）
    private Integer delFlag;

}
~~~~

详情请看后续个人博客SpringBoot专栏

## 14.AspectJ框架实现aop日志功能

### 14.1自定义注解，实现注解开启代理

~~~java
//自定义注解实现AOP日志功能
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface SystemLog {
    String Description();
}
~~~

### 14.2配置切面

~~~java
/**
 * @ClassName LogAspect
 * @Description 日志功能工具类
 * @Author cc
 * @Date 2023/5/7 11:29
 * @Version 1.0
 */
@Component
@Aspect
@Slf4j
public class LogAspect {

    {
        System.out.println("对象创建成功");
    }

    //切点，使用了该注解的方法都会被代理
    @Pointcut("@annotation(com.zxnk.annotation.SystemLog)")
    public void pointCut(){}

    //配置环绕通知
    @Around("pointCut()")
    public Object aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        Object result = null;
        try {
            //前置通知
            beforeAdvice(proceedingJoinPoint);
            //方法执行，此代码一定要执行，否则被代理的方法不会执行，没有返回值
            result = proceedingJoinPoint.proceed();
            //后置通知
            afterAdvice(result);
        }finally {
            // 结束后换行
            log.info("=======End=======" + System.lineSeparator());
        }
        return result;
    }

    //前置打印消息
    private void beforeAdvice(ProceedingJoinPoint proceedingJoinPoint){
        //获取请求对象,带有contextHolder的对象都是上下文对象，javaWeb基于面向对象的理念，把请求也封装成上下文对象
        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = requestAttributes.getRequest();

        //获取注解对象
        SystemLog systemLog = getSystemLog(proceedingJoinPoint);

        log.info("=======Start=======");
        // 打印请求 URL
        log.info("URL            : {}",request.getRequestURL());
        // 打印描述信息
        log.info("Description   : {}",systemLog.Description());
        // 打印 Http method
        log.info("HTTP Method    : {}",request.getMethod());
        // 打印调用 controller 的全路径以及执行方法
        log.info("Class Method   : {}.{}",proceedingJoinPoint.getTarget().getClass().getName(),proceedingJoinPoint.getSignature().getName());
        // 打印请求的 IP
        log.info("IP             : {}",request.getRemoteHost());
        // 打印请求入参
        log.info("Request Args   : {}", JSON.toJSON(proceedingJoinPoint.getArgs()));
    }

    //后置打印消息
    private void afterAdvice(Object result){
        // 打印出参
        log.info("Response       : {}",JSON.toJSONString(result));
    }

    //获取注解对象
    private SystemLog getSystemLog(ProceedingJoinPoint proceedingJoinPoint){
        //获取具体的代理方法
        MethodSignature signature = (MethodSignature) proceedingJoinPoint.getSignature();
        //通过方法获取注解
        SystemLog systemLog = signature.getMethod().getAnnotation(SystemLog.class);
        return systemLog;
    }
}
~~~

### 14.3配置切点

~~~java
    @PostMapping("/register")
    @ApiOperation(value = "进行新用户的注册",notes = "用名户、昵称不能重复,密码必须是小写英文字母加数字且长度大于6，而且各类数据均不可为空")
    @SystemLog(Description = "进行用户注册")
    public ResponseResult register(@RequestBody User user){
        return userService.register(user);
    }
~~~

### 14.4知识总结

```java
@Retention(RetentionPolicy.RUNTIME)	//元注解，表示运行时起作用
@Target(ElementType.METHOD)			//元注解，表示该注解作用在方法上
```

```java
//切点，使用了该注解的方法都会被代理
@Pointcut("@annotation(com.zxnk.annotation.SystemLog)")
public void pointCut(){}
```

配置环绕通知的时候，一定要执行proceed方法，否则切点方法无法正常执行

~~~java
//配置环绕通知
    @Around("pointCut()")
    public Object aroundAdvice(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {
        Object result = null;
        try {
            //前置通知
            beforeAdvice(proceedingJoinPoint);
            //方法执行，此代码一定要执行，否则被代理的方法不会执行，没有返回值
            result = proceedingJoinPoint.proceed();
            //后置通知
            afterAdvice(result);
        }finally {
            // 结束后换行
            log.info("=======End=======" + System.lineSeparator());
        }
        return result;
    }
~~~

~~~java
//获取请求对象,带有contextHolder的对象都是上下文对象，javaWeb基于面向对象的理念，把请求也封装成上下文对象，使用该上下文对象可以获取http请求对象，接而获取请求的基本信息
        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        HttpServletRequest request = requestAttributes.getRequest();
~~~

通过切点对象的签名方法进而获取到注解

~~~java
//获取具体的代理方法
MethodSignature signature = (MethodSignature) proceedingJoinPoint.getSignature();
//通过方法获取注解
SystemLog systemLog = signature.getMethod().getAnnotation(SystemLog.class);
~~~

## 15.项目启动任务

### 15.1starter起步依赖

需要后续学习

### 15.2类加载时机

```java
static{
	sout("do something")
}
```

jvm完成该类的加载之后就会执行相应的静态代码块，可实现项目启动任务

### 15.3对象创建时机

```java
@Component
public MyBean{
    {
        sout("do something")
    }
}
```

创建一个bean对象并交给spring容器管理，当spring完成容器初始化，就会创建bean对象放入容器进行管理，此时执行对象创建逻辑，实现项目启动任务

### 15.4Bean对象afterpropertiesSet方法

详情请看文档的第10条总结

### 15.5@postconstruct注解

Bean对象的生命周期包含创建——使用——销毁，Spring可以配置Bean对象在创建和销毁时自动执行的方法：

在bean对象上方使用@postconstruct注解，定义初始化方法

使用@predestory注解，定义销毁时机方法

### 15.6CommandLineRunner接口

实现CommandLineRunner接口，实现run方法，完成数据预热功能

~~~java
/**
 * @ClassName ViewCountRunner
 * @Description 数据预热类，在应用启动成功时，查询数据库，将所有的文章浏览次数存入redis
 * @Author cc
 * @Date 2023/5/7 17:01
 * @Version 1.0
 */
@Component
public class ViewCountRunner implements CommandLineRunner {

    @Autowired
    private ArticleService articleService;
    @Autowired
    private RedisTemplate redisTemplate;

    //启动成功时执行的方法
    @Override
    public void run(String... args) throws Exception {
        //查询所有博文
        List<Article> articles = articleService.findAll();
        //将博文集合转成hashmap存入redis中
        Map<String, Integer> map = articles.stream()
                .collect(Collectors.toMap(article -> article.getId().toString(), article -> article.getViewCount().intValue()));
        //存入redis中
        redisTemplate.opsForHash().putAll("viewCount",map);
    }
}
~~~

## 16.Swagger2入门

### 16.1引入依赖

```xml
		 <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
        </dependency>
```

### 16.2开启swagger2功能注解

```java
@SpringBootApplication
@MapperScan("com.zxnk.mapper")
@EnableAspectJAutoProxy
//开启定时任务
@EnableScheduling
//开启swagger2接口文档
@EnableSwagger2
public class BlogAdminApplication {
    public static void main(String[] args) {
        SpringApplication.run(BlogAdminApplication.class,args);
        System.out.println("博客前台项目启动成功");
    }
}
```

### 16.3接口文档地址

localhost:port/swagger-ui.html

### 16.4具体用法

~~~java
@RestController
@RequestMapping("/article")
@Api(tags = "博客文章控制类",description = "博客文章相应接口")
public class ArticleController {

    @Autowired
    private ArticleService articleService;
    @Autowired
    private CategoryService categoryService;

    @GetMapping("/list")
    @ApiOperation(value = "获取全部文章")
    public List<Article> findAll(){
        return articleService.findAll();
    }

    /**
     * @return: com.zxnk.util.ResponseResult<java.util.List<com.zxnk.dto.HotArticleVo>>
     * @decription 返回最做多点击的10条博文，排除草稿
     * @date 2023/4/25 13:30
    */
    @GetMapping("/hotArticleList")
    @ApiOperation("返回最做多点击的10条博文，排除草稿")
    public ResponseResult<List<HotArticleVo>> hotArticleList(){
        List<Article> result = articleService.hotArticleList();
        List<HotArticleVo> hotArticleVos = BeanCopyUtils.copyBeans(result, HotArticleVo.class);
        return ResponseResult.okResult(hotArticleVos);
    }

    /**
     * @param pageNum 初始页
     * @param pageSize 每页条数
     * @param categoryId 博文类别id
     * @return: com.zxnk.util.ResponseResult<com.zxnk.dto.PageVo>
     * @decription 根据分页条件，对博文进行分页查询，并判断是否选择同一类别下的博文，并且博文的状态必须是正常的，而且对数据采用置顶的排序
     * @date 2023/4/26 10:39
    */
    @GetMapping("/articleList")
    @ApiOperation("根据分页条件，对博文进行分页查询，并判断是否选择同一类别下的博文，并且博文的状态必须是正常的，而且对数据采用置顶的排序")
    @ApiImplicitParams({
            @ApiImplicitParam(name = "pageNum",value = "分页页号"),
            @ApiImplicitParam(name = "pageSize",value = "分页大小"),
            @ApiImplicitParam(name = "categoryId",value = "文章类别id")
    })
    public ResponseResult<PageVo> articleList(@RequestParam(defaultValue = "0")Integer pageNum,
                                              @RequestParam(defaultValue = "10") Integer pageSize,
                                              Long categoryId){
        //获取分页对象
        Page<Article> articlePage = articleService.articleList(pageNum, pageSize, categoryId);
        //获取博文对象
        List<Article> articleList = articlePage.getRecords();
        //完成数据的封装
        List<ArticleVo> articleVoList = BeanCopyUtils.copyBeans(articleList, ArticleVo.class);
        PageVo pageVo = new PageVo(articleVoList, articlePage.getTotal());
        return ResponseResult.okResult(pageVo);
    }

    @ApiOperation("根据id查询相应的文章详情")
    @GetMapping("/{id}")
    @ApiImplicitParam(name = "id",value = "文章id")
    public ResponseResult<ArticleDetailVo> getArticleDetailById(@PathVariable Long id){
        return ResponseResult.okResult(articleService.findById(id));
    }

    @ApiOperation("根据id更新文章的浏览量")
    @PutMapping("/updateViewCount/{id}")
    @ApiImplicitParam(name = "id",value = "文章id")
    public ResponseResult updateViewCount(@PathVariable Long id){
        return articleService.updateViewCountById(id);
    }
}
~~~

```java
//描述类信息
@Api(tags = "博客文章控制类",description = "博客文章相应接口")
//描述方法信息
@ApiOperation("根据id更新文章的浏览量")
//描述请求参数信息
@ApiImplicitParams({
            @ApiImplicitParam(name = "pageNum",value = "分页页号"),
            @ApiImplicitParam(name = "pageSize",value = "分页大小"),
            @ApiImplicitParam(name = "categoryId",value = "文章类别id")
})
//描述实体类信息
@ApiModel("用户表(CcUser)表实体类")
//描述实体类属性信息
@ApiModelProperty("用户名")
```

### 16.5配置类，描述接口文档的配置信息

~~~java
/**
 * @ClassName Swagger2Config
 * @Description swagger2配置类
 * @Author cc
 * @Date 2023/5/7 20:39
 * @Version 1.0
 */
@Configuration
public class Swagger2Config {

    @Bean
    public Docket customDocket() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.zxnk.controller"))
                .build();
    }

    private ApiInfo apiInfo() {
        Contact contact = new Contact("ccg", "http://8.142.134.180", "ccgccg@yeah.net");
        return new ApiInfoBuilder()
                .title("博客系统")
                .description("以下是博客系统的开发文档")
                .contact(contact)   // 联系方式
                .version("1.0.0")  // 版本
                .build();
    }
}
~~~



